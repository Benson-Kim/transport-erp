/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model VerificationToken
 *
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Company
 *
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>;
/**
 * Model Client
 *
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>;
/**
 * Model ClientContact
 *
 */
export type ClientContact = $Result.DefaultSelection<Prisma.$ClientContactPayload>;
/**
 * Model Supplier
 *
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>;
/**
 * Model Service
 *
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>;
/**
 * Model ServiceStatusHistory
 *
 */
export type ServiceStatusHistory = $Result.DefaultSelection<Prisma.$ServiceStatusHistoryPayload>;
/**
 * Model LoadingOrder
 *
 */
export type LoadingOrder = $Result.DefaultSelection<Prisma.$LoadingOrderPayload>;
/**
 * Model ServiceLoadingOrder
 *
 */
export type ServiceLoadingOrder = $Result.DefaultSelection<Prisma.$ServiceLoadingOrderPayload>;
/**
 * Model Invoice
 *
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>;
/**
 * Model InvoiceItem
 *
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>;
/**
 * Model Payment
 *
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>;
/**
 * Model Document
 *
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;
/**
 * Model Notification
 *
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>;
/**
 * Model SystemSetting
 *
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
    SUPER_ADMIN: 'SUPER_ADMIN';
    ADMIN: 'ADMIN';
    MANAGER: 'MANAGER';
    ACCOUNTANT: 'ACCOUNTANT';
    OPERATOR: 'OPERATOR';
    VIEWER: 'VIEWER';
  };

  export type UserRole = (typeof UserRole)[keyof typeof UserRole];

  export const ServiceStatus: {
    DRAFT: 'DRAFT';
    CONFIRMED: 'CONFIRMED';
    IN_PROGRESS: 'IN_PROGRESS';
    COMPLETED: 'COMPLETED';
    CANCELLED: 'CANCELLED';
    INVOICED: 'INVOICED';
    ARCHIVED: 'ARCHIVED';
  };

  export type ServiceStatus = (typeof ServiceStatus)[keyof typeof ServiceStatus];

  export const InvoiceStatus: {
    DRAFT: 'DRAFT';
    SENT: 'SENT';
    VIEWED: 'VIEWED';
    PAID: 'PAID';
    OVERDUE: 'OVERDUE';
    CANCELLED: 'CANCELLED';
  };

  export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus];

  export const PaymentStatus: {
    PENDING: 'PENDING';
    PROCESSING: 'PROCESSING';
    COMPLETED: 'COMPLETED';
    FAILED: 'FAILED';
    REFUNDED: 'REFUNDED';
  };

  export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus];

  export const AuditAction: {
    CREATE: 'CREATE';
    UPDATE: 'UPDATE';
    DELETE: 'DELETE';
    RESTORE: 'RESTORE';
    LOGIN: 'LOGIN';
    LOGOUT: 'LOGOUT';
    EXPORT: 'EXPORT';
    IMPORT: 'IMPORT';
    COMPLETE: 'COMPLETE';
    CANCEL: 'CANCEL';
    SEND_EMAIL: 'SEND_EMAIL';
    GENERATE_DOCUMENT: 'GENERATE_DOCUMENT';
    ARCHIVE: 'ARCHIVE';
  };

  export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction];

  export const DocumentType: {
    LOADING_ORDER: 'LOADING_ORDER';
    INVOICE: 'INVOICE';
    RECEIPT: 'RECEIPT';
    DELIVERY_NOTE: 'DELIVERY_NOTE';
    CONTRACT: 'CONTRACT';
    OTHER: 'OTHER';
  };

  export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType];
}

export type UserRole = $Enums.UserRole;

export const UserRole: typeof $Enums.UserRole;

export type ServiceStatus = $Enums.ServiceStatus;

export const ServiceStatus: typeof $Enums.ServiceStatus;

export type InvoiceStatus = $Enums.InvoiceStatus;

export const InvoiceStatus: typeof $Enums.InvoiceStatus;

export type PaymentStatus = $Enums.PaymentStatus;

export const PaymentStatus: typeof $Enums.PaymentStatus;

export type AuditAction = $Enums.AuditAction;

export const AuditAction: typeof $Enums.AuditAction;

export type DocumentType = $Enums.DocumentType;

export const DocumentType: typeof $Enums.DocumentType;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VerificationTokens
   * const verificationTokens = await prisma.verificationToken.findMany()
   * ```
   */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Clients
   * const clients = await prisma.client.findMany()
   * ```
   */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientContact`: Exposes CRUD operations for the **ClientContact** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ClientContacts
   * const clientContacts = await prisma.clientContact.findMany()
   * ```
   */
  get clientContact(): Prisma.ClientContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Suppliers
   * const suppliers = await prisma.supplier.findMany()
   * ```
   */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Services
   * const services = await prisma.service.findMany()
   * ```
   */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceStatusHistory`: Exposes CRUD operations for the **ServiceStatusHistory** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ServiceStatusHistories
   * const serviceStatusHistories = await prisma.serviceStatusHistory.findMany()
   * ```
   */
  get serviceStatusHistory(): Prisma.ServiceStatusHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loadingOrder`: Exposes CRUD operations for the **LoadingOrder** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LoadingOrders
   * const loadingOrders = await prisma.loadingOrder.findMany()
   * ```
   */
  get loadingOrder(): Prisma.LoadingOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceLoadingOrder`: Exposes CRUD operations for the **ServiceLoadingOrder** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ServiceLoadingOrders
   * const serviceLoadingOrders = await prisma.serviceLoadingOrder.findMany()
   * ```
   */
  get serviceLoadingOrder(): Prisma.ServiceLoadingOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Invoices
   * const invoices = await prisma.invoice.findMany()
   * ```
   */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more InvoiceItems
   * const invoiceItems = await prisma.invoiceItem.findMany()
   * ```
   */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Payments
   * const payments = await prisma.payment.findMany()
   * ```
   */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Documents
   * const documents = await prisma.document.findMany()
   * ```
   */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SystemSettings
   * const systemSettings = await prisma.systemSetting.findMany()
   * ```
   */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Account: 'Account';
    Session: 'Session';
    VerificationToken: 'VerificationToken';
    User: 'User';
    Company: 'Company';
    Client: 'Client';
    ClientContact: 'ClientContact';
    Supplier: 'Supplier';
    Service: 'Service';
    ServiceStatusHistory: 'ServiceStatusHistory';
    LoadingOrder: 'LoadingOrder';
    ServiceLoadingOrder: 'ServiceLoadingOrder';
    Invoice: 'Invoice';
    InvoiceItem: 'InvoiceItem';
    Payment: 'Payment';
    Document: 'Document';
    AuditLog: 'AuditLog';
    Notification: 'Notification';
    SystemSetting: 'SystemSetting';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'account'
        | 'session'
        | 'verificationToken'
        | 'user'
        | 'company'
        | 'client'
        | 'clientContact'
        | 'supplier'
        | 'service'
        | 'serviceStatusHistory'
        | 'loadingOrder'
        | 'serviceLoadingOrder'
        | 'invoice'
        | 'invoiceItem'
        | 'payment'
        | 'document'
        | 'auditLog'
        | 'notification'
        | 'systemSetting';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>;
        fields: Prisma.VerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerificationToken>;
          };
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>;
        fields: Prisma.CompanyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
          };
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
          };
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
          };
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCompany>;
          };
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CompanyGroupByOutputType>[];
          };
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>;
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number;
          };
        };
      };
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>;
        fields: Prisma.ClientFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>;
          };
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>;
          };
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[];
          };
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>;
          };
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[];
          };
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>;
          };
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>;
          };
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[];
          };
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>;
          };
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateClient>;
          };
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClientGroupByOutputType>[];
          };
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>;
            result: $Utils.Optional<ClientCountAggregateOutputType> | number;
          };
        };
      };
      ClientContact: {
        payload: Prisma.$ClientContactPayload<ExtArgs>;
        fields: Prisma.ClientContactFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ClientContactFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ClientContactFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>;
          };
          findFirst: {
            args: Prisma.ClientContactFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ClientContactFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>;
          };
          findMany: {
            args: Prisma.ClientContactFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>[];
          };
          create: {
            args: Prisma.ClientContactCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>;
          };
          createMany: {
            args: Prisma.ClientContactCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ClientContactCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>[];
          };
          delete: {
            args: Prisma.ClientContactDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>;
          };
          update: {
            args: Prisma.ClientContactUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>;
          };
          deleteMany: {
            args: Prisma.ClientContactDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ClientContactUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ClientContactUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>[];
          };
          upsert: {
            args: Prisma.ClientContactUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>;
          };
          aggregate: {
            args: Prisma.ClientContactAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateClientContact>;
          };
          groupBy: {
            args: Prisma.ClientContactGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClientContactGroupByOutputType>[];
          };
          count: {
            args: Prisma.ClientContactCountArgs<ExtArgs>;
            result: $Utils.Optional<ClientContactCountAggregateOutputType> | number;
          };
        };
      };
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>;
        fields: Prisma.SupplierFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[];
          };
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[];
          };
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[];
          };
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSupplier>;
          };
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SupplierGroupByOutputType>[];
          };
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>;
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number;
          };
        };
      };
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>;
        fields: Prisma.ServiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateService>;
          };
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number;
          };
        };
      };
      ServiceStatusHistory: {
        payload: Prisma.$ServiceStatusHistoryPayload<ExtArgs>;
        fields: Prisma.ServiceStatusHistoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceStatusHistoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceStatusHistoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>;
          };
          findFirst: {
            args: Prisma.ServiceStatusHistoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceStatusHistoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>;
          };
          findMany: {
            args: Prisma.ServiceStatusHistoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>[];
          };
          create: {
            args: Prisma.ServiceStatusHistoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>;
          };
          createMany: {
            args: Prisma.ServiceStatusHistoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceStatusHistoryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>[];
          };
          delete: {
            args: Prisma.ServiceStatusHistoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>;
          };
          update: {
            args: Prisma.ServiceStatusHistoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>;
          };
          deleteMany: {
            args: Prisma.ServiceStatusHistoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceStatusHistoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ServiceStatusHistoryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>[];
          };
          upsert: {
            args: Prisma.ServiceStatusHistoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>;
          };
          aggregate: {
            args: Prisma.ServiceStatusHistoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateServiceStatusHistory>;
          };
          groupBy: {
            args: Prisma.ServiceStatusHistoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceStatusHistoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceStatusHistoryCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceStatusHistoryCountAggregateOutputType> | number;
          };
        };
      };
      LoadingOrder: {
        payload: Prisma.$LoadingOrderPayload<ExtArgs>;
        fields: Prisma.LoadingOrderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LoadingOrderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LoadingOrderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>;
          };
          findFirst: {
            args: Prisma.LoadingOrderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LoadingOrderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>;
          };
          findMany: {
            args: Prisma.LoadingOrderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>[];
          };
          create: {
            args: Prisma.LoadingOrderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>;
          };
          createMany: {
            args: Prisma.LoadingOrderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LoadingOrderCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>[];
          };
          delete: {
            args: Prisma.LoadingOrderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>;
          };
          update: {
            args: Prisma.LoadingOrderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>;
          };
          deleteMany: {
            args: Prisma.LoadingOrderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LoadingOrderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LoadingOrderUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>[];
          };
          upsert: {
            args: Prisma.LoadingOrderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LoadingOrderPayload>;
          };
          aggregate: {
            args: Prisma.LoadingOrderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLoadingOrder>;
          };
          groupBy: {
            args: Prisma.LoadingOrderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LoadingOrderGroupByOutputType>[];
          };
          count: {
            args: Prisma.LoadingOrderCountArgs<ExtArgs>;
            result: $Utils.Optional<LoadingOrderCountAggregateOutputType> | number;
          };
        };
      };
      ServiceLoadingOrder: {
        payload: Prisma.$ServiceLoadingOrderPayload<ExtArgs>;
        fields: Prisma.ServiceLoadingOrderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceLoadingOrderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceLoadingOrderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>;
          };
          findFirst: {
            args: Prisma.ServiceLoadingOrderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceLoadingOrderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>;
          };
          findMany: {
            args: Prisma.ServiceLoadingOrderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>[];
          };
          create: {
            args: Prisma.ServiceLoadingOrderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>;
          };
          createMany: {
            args: Prisma.ServiceLoadingOrderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceLoadingOrderCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>[];
          };
          delete: {
            args: Prisma.ServiceLoadingOrderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>;
          };
          update: {
            args: Prisma.ServiceLoadingOrderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>;
          };
          deleteMany: {
            args: Prisma.ServiceLoadingOrderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceLoadingOrderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ServiceLoadingOrderUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>[];
          };
          upsert: {
            args: Prisma.ServiceLoadingOrderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceLoadingOrderPayload>;
          };
          aggregate: {
            args: Prisma.ServiceLoadingOrderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateServiceLoadingOrder>;
          };
          groupBy: {
            args: Prisma.ServiceLoadingOrderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceLoadingOrderGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceLoadingOrderCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceLoadingOrderCountAggregateOutputType> | number;
          };
        };
      };
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>;
        fields: Prisma.InvoiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[];
          };
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[];
          };
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[];
          };
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInvoice>;
          };
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InvoiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>;
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number;
          };
        };
      };
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>;
        fields: Prisma.InvoiceItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>;
          };
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>;
          };
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[];
          };
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>;
          };
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[];
          };
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>;
          };
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>;
          };
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[];
          };
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>;
          };
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInvoiceItem>;
          };
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>;
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number;
          };
        };
      };
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>;
        fields: Prisma.PaymentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePayment>;
          };
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaymentGroupByOutputType>[];
          };
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>;
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number;
          };
        };
      };
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>;
        fields: Prisma.DocumentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDocument>;
          };
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DocumentGroupByOutputType>[];
          };
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>;
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number;
          };
        };
      };
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>;
        fields: Prisma.SystemSettingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>;
          };
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>;
          };
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[];
          };
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>;
          };
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[];
          };
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>;
          };
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>;
          };
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[];
          };
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>;
          };
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSystemSetting>;
          };
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SystemSettingGroupByOutputType>[];
          };
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>;
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit;
    session?: SessionOmit;
    verificationToken?: VerificationTokenOmit;
    user?: UserOmit;
    company?: CompanyOmit;
    client?: ClientOmit;
    clientContact?: ClientContactOmit;
    supplier?: SupplierOmit;
    service?: ServiceOmit;
    serviceStatusHistory?: ServiceStatusHistoryOmit;
    loadingOrder?: LoadingOrderOmit;
    serviceLoadingOrder?: ServiceLoadingOrderOmit;
    invoice?: InvoiceOmit;
    invoiceItem?: InvoiceItemOmit;
    payment?: PaymentOmit;
    document?: DocumentOmit;
    auditLog?: AuditLogOmit;
    notification?: NotificationOmit;
    systemSetting?: SystemSettingOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T['level'] : T>;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number;
    sessions: number;
    services: number;
    assignedServices: number;
    loadingOrders: number;
    invoices: number;
    auditLogs: number;
    notifications: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs;
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
    services?: boolean | UserCountOutputTypeCountServicesArgs;
    assignedServices?: boolean | UserCountOutputTypeCountAssignedServicesArgs;
    loadingOrders?: boolean | UserCountOutputTypeCountLoadingOrdersArgs;
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs;
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs;
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoadingOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LoadingOrderWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvoiceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    asClient: number;
    asSupplier: number;
  };

  export type CompanyCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asClient?: boolean | CompanyCountOutputTypeCountAsClientArgs;
    asSupplier?: boolean | CompanyCountOutputTypeCountAsSupplierArgs;
  };

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAsClientArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClientWhereInput;
  };

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAsSupplierArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SupplierWhereInput;
  };

  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    services: number;
    contacts: number;
    documents: number;
  };

  export type ClientCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    services?: boolean | ClientCountOutputTypeCountServicesArgs;
    contacts?: boolean | ClientCountOutputTypeCountContactsArgs;
    documents?: boolean | ClientCountOutputTypeCountDocumentsArgs;
  };

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountContactsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClientContactWhereInput;
  };

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
  };

  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    services: number;
    invoices: number;
    documents: number;
  };

  export type SupplierCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    services?: boolean | SupplierCountOutputTypeCountServicesArgs;
    invoices?: boolean | SupplierCountOutputTypeCountInvoicesArgs;
    documents?: boolean | SupplierCountOutputTypeCountDocumentsArgs;
  };

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountInvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvoiceWhereInput;
  };

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
  };

  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    loadingOrders: number;
    invoiceItems: number;
    documents: number;
    statusHistory: number;
  };

  export type ServiceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    loadingOrders?: boolean | ServiceCountOutputTypeCountLoadingOrdersArgs;
    invoiceItems?: boolean | ServiceCountOutputTypeCountInvoiceItemsArgs;
    documents?: boolean | ServiceCountOutputTypeCountDocumentsArgs;
    statusHistory?: boolean | ServiceCountOutputTypeCountStatusHistoryArgs;
  };

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountLoadingOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceLoadingOrderWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountInvoiceItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvoiceItemWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountStatusHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceStatusHistoryWhereInput;
  };

  /**
   * Count Type LoadingOrderCountOutputType
   */

  export type LoadingOrderCountOutputType = {
    services: number;
  };

  export type LoadingOrderCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    services?: boolean | LoadingOrderCountOutputTypeCountServicesArgs;
  };

  // Custom InputTypes
  /**
   * LoadingOrderCountOutputType without action
   */
  export type LoadingOrderCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrderCountOutputType
     */
    select?: LoadingOrderCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LoadingOrderCountOutputType without action
   */
  export type LoadingOrderCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceLoadingOrderWhereInput;
  };

  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number;
    payments: number;
  };

  export type InvoiceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs;
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs;
  };

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvoiceItemWhereInput;
  };

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaymentWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountSumAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    provider: number;
    providerAccountId: number;
    refresh_token: number;
    access_token: number;
    expires_at: number;
    token_type: number;
    scope: number;
    id_token: number;
    session_state: number;
    _all: number;
  };

  export type AccountAvgAggregateInputType = {
    expires_at?: true;
  };

  export type AccountSumAggregateInputType = {
    expires_at?: true;
  };

  export type AccountMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AccountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AccountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _avg?: AccountAvgAggregateInputType;
    _sum?: AccountSumAggregateInputType;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    id: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AccountGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
          : GetScalarType<T[P], AccountGroupByOutputType[P]>;
      }
    >
  >;

  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        type?: boolean;
        provider?: boolean;
        providerAccountId?: boolean;
        refresh_token?: boolean;
        access_token?: boolean;
        expires_at?: boolean;
        token_type?: boolean;
        scope?: boolean;
        id_token?: boolean;
        session_state?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['account']
    >;

  export type AccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['account']
  >;

  export type AccountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['account']
  >;

  export type AccountSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    provider?: boolean;
    providerAccountId?: boolean;
    refresh_token?: boolean;
    access_token?: boolean;
    expires_at?: boolean;
    token_type?: boolean;
    scope?: boolean;
    id_token?: boolean;
    session_state?: boolean;
  };

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'userId'
      | 'type'
      | 'provider'
      | 'providerAccountId'
      | 'refresh_token'
      | 'access_token'
      | 'expires_at'
      | 'token_type'
      | 'scope'
      | 'id_token'
      | 'session_state',
      ExtArgs['result']['account']
    >;
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Account';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          userId: string;
          type: string;
          provider: string;
          providerAccountId: string;
          refresh_token: string | null;
          access_token: string | null;
          expires_at: number | null;
          token_type: string | null;
          scope: string | null;
          id_token: string | null;
          session_state: string | null;
        },
        ExtArgs['result']['account']
      >;
      composites: {};
    };

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> =
    $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AccountFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account']; meta: { name: 'Account' } };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<'Account', 'String'>;
    readonly userId: FieldRef<'Account', 'String'>;
    readonly type: FieldRef<'Account', 'String'>;
    readonly provider: FieldRef<'Account', 'String'>;
    readonly providerAccountId: FieldRef<'Account', 'String'>;
    readonly refresh_token: FieldRef<'Account', 'String'>;
    readonly access_token: FieldRef<'Account', 'String'>;
    readonly expires_at: FieldRef<'Account', 'Int'>;
    readonly token_type: FieldRef<'Account', 'String'>;
    readonly scope: FieldRef<'Account', 'String'>;
    readonly id_token: FieldRef<'Account', 'String'>;
    readonly session_state: FieldRef<'Account', 'String'>;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
  };

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    sessionToken: number;
    userId: number;
    expires: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    sessionToken: string;
    userId: string;
    expires: Date;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SessionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
          : GetScalarType<T[P], SessionGroupByOutputType[P]>;
      }
    >
  >;

  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        sessionToken?: boolean;
        userId?: boolean;
        expires?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['session']
    >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['session']
  >;

  export type SessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['session']
  >;

  export type SessionSelectScalar = {
    id?: boolean;
    sessionToken?: boolean;
    userId?: boolean;
    expires?: boolean;
  };

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'id' | 'sessionToken' | 'userId' | 'expires', ExtArgs['result']['session']>;
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Session';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          sessionToken: string;
          userId: string;
          expires: Date;
        },
        ExtArgs['result']['session']
      >;
      composites: {};
    };

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> =
    $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    SessionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session']; meta: { name: 'Session' } };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<'Session', 'String'>;
    readonly sessionToken: FieldRef<'Session', 'String'>;
    readonly userId: FieldRef<'Session', 'String'>;
    readonly expires: FieldRef<'Session', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
  };

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number;
    token: number;
    expires: number;
    _all: number;
  };

  export type VerificationTokenMinAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
    _all?: true;
  };

  export type VerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VerificationTokens
     **/
    _count?: true | VerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
    [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>;
  };

  export type VerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerificationTokenWhereInput;
    orderBy?:
      | VerificationTokenOrderByWithAggregationInput
      | VerificationTokenOrderByWithAggregationInput[];
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum;
    having?: VerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationTokenCountAggregateInputType | true;
    _min?: VerificationTokenMinAggregateInputType;
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type VerificationTokenGroupByOutputType = {
    identifier: string;
    token: string;
    expires: Date;
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VerificationTokenGroupByOutputType, T['by']> & {
          [P in keyof T & keyof VerificationTokenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>;
        }
      >
    >;

  export type VerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs['result']['verificationToken']
  >;

  export type VerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs['result']['verificationToken']
  >;

  export type VerificationTokenSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs['result']['verificationToken']
  >;

  export type VerificationTokenSelectScalar = {
    identifier?: boolean;
    token?: boolean;
    expires?: boolean;
  };

  export type VerificationTokenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'identifier' | 'token' | 'expires',
    ExtArgs['result']['verificationToken']
  >;

  export type $VerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'VerificationToken';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        identifier: string;
        token: string;
        expires: Date;
      },
      ExtArgs['result']['verificationToken']
    >;
    composites: {};
  };

  type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$VerificationTokenPayload, S>;

  type VerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: VerificationTokenCountAggregateInputType | true;
  };

  export interface VerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'];
      meta: { name: 'VerificationToken' };
    };
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     *
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     *
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     *
     */
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     *
     */
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     *
     */
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerificationTokenAggregateArgs>(
      args: Subset<T, VerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>;

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VerificationToken model
     */
    readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<'VerificationToken', 'String'>;
    readonly token: FieldRef<'VerificationToken', 'String'>;
    readonly expires: FieldRef<'VerificationToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>;
  };

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>;
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput;
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>;
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>;
  };

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number;
  };

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    emailVerified: Date | null;
    password: string | null;
    name: string | null;
    role: $Enums.UserRole | null;
    avatar: string | null;
    phone: string | null;
    department: string | null;
    isActive: boolean | null;
    twoFactorEnabled: boolean | null;
    twoFactorSecret: string | null;
    lastLoginAt: Date | null;
    lastLoginIp: string | null;
    passwordChangedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    emailVerified: Date | null;
    password: string | null;
    name: string | null;
    role: $Enums.UserRole | null;
    avatar: string | null;
    phone: string | null;
    department: string | null;
    isActive: boolean | null;
    twoFactorEnabled: boolean | null;
    twoFactorSecret: string | null;
    lastLoginAt: Date | null;
    lastLoginIp: string | null;
    passwordChangedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    emailVerified: number;
    password: number;
    name: number;
    role: number;
    avatar: number;
    phone: number;
    department: number;
    isActive: number;
    twoFactorEnabled: number;
    twoFactorSecret: number;
    lastLoginAt: number;
    lastLoginIp: number;
    passwordChangedAt: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    emailVerified?: true;
    password?: true;
    name?: true;
    role?: true;
    avatar?: true;
    phone?: true;
    department?: true;
    isActive?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    lastLoginAt?: true;
    lastLoginIp?: true;
    passwordChangedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    emailVerified?: true;
    password?: true;
    name?: true;
    role?: true;
    avatar?: true;
    phone?: true;
    department?: true;
    isActive?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    lastLoginAt?: true;
    lastLoginIp?: true;
    passwordChangedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    emailVerified?: true;
    password?: true;
    name?: true;
    role?: true;
    avatar?: true;
    phone?: true;
    department?: true;
    isActive?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    lastLoginAt?: true;
    lastLoginIp?: true;
    passwordChangedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    emailVerified: Date | null;
    password: string | null;
    name: string;
    role: $Enums.UserRole;
    avatar: string | null;
    phone: string | null;
    department: string | null;
    isActive: boolean;
    twoFactorEnabled: boolean;
    twoFactorSecret: string | null;
    lastLoginAt: Date | null;
    lastLoginIp: string | null;
    passwordChangedAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        emailVerified?: boolean;
        password?: boolean;
        name?: boolean;
        role?: boolean;
        avatar?: boolean;
        phone?: boolean;
        department?: boolean;
        isActive?: boolean;
        twoFactorEnabled?: boolean;
        twoFactorSecret?: boolean;
        lastLoginAt?: boolean;
        lastLoginIp?: boolean;
        passwordChangedAt?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        accounts?: boolean | User$accountsArgs<ExtArgs>;
        sessions?: boolean | User$sessionsArgs<ExtArgs>;
        services?: boolean | User$servicesArgs<ExtArgs>;
        assignedServices?: boolean | User$assignedServicesArgs<ExtArgs>;
        loadingOrders?: boolean | User$loadingOrdersArgs<ExtArgs>;
        invoices?: boolean | User$invoicesArgs<ExtArgs>;
        auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
        notifications?: boolean | User$notificationsArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['user']
    >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      password?: boolean;
      name?: boolean;
      role?: boolean;
      avatar?: boolean;
      phone?: boolean;
      department?: boolean;
      isActive?: boolean;
      twoFactorEnabled?: boolean;
      twoFactorSecret?: boolean;
      lastLoginAt?: boolean;
      lastLoginIp?: boolean;
      passwordChangedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      password?: boolean;
      name?: boolean;
      role?: boolean;
      avatar?: boolean;
      phone?: boolean;
      department?: boolean;
      isActive?: boolean;
      twoFactorEnabled?: boolean;
      twoFactorSecret?: boolean;
      lastLoginAt?: boolean;
      lastLoginIp?: boolean;
      passwordChangedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    password?: boolean;
    name?: boolean;
    role?: boolean;
    avatar?: boolean;
    phone?: boolean;
    department?: boolean;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: boolean;
    lastLoginAt?: boolean;
    lastLoginIp?: boolean;
    passwordChangedAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'email'
      | 'emailVerified'
      | 'password'
      | 'name'
      | 'role'
      | 'avatar'
      | 'phone'
      | 'department'
      | 'isActive'
      | 'twoFactorEnabled'
      | 'twoFactorSecret'
      | 'lastLoginAt'
      | 'lastLoginIp'
      | 'passwordChangedAt'
      | 'createdAt'
      | 'updatedAt'
      | 'deletedAt',
      ExtArgs['result']['user']
    >;
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>;
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    services?: boolean | User$servicesArgs<ExtArgs>;
    assignedServices?: boolean | User$assignedServicesArgs<ExtArgs>;
    loadingOrders?: boolean | User$loadingOrdersArgs<ExtArgs>;
    invoices?: boolean | User$invoicesArgs<ExtArgs>;
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
    notifications?: boolean | User$notificationsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'User';
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[];
      sessions: Prisma.$SessionPayload<ExtArgs>[];
      services: Prisma.$ServicePayload<ExtArgs>[];
      assignedServices: Prisma.$ServicePayload<ExtArgs>[];
      loadingOrders: Prisma.$LoadingOrderPayload<ExtArgs>[];
      invoices: Prisma.$InvoicePayload<ExtArgs>[];
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        emailVerified: Date | null;
        password: string | null;
        name: string;
        role: $Enums.UserRole;
        avatar: string | null;
        phone: string | null;
        department: string | null;
        isActive: boolean;
        twoFactorEnabled: boolean;
        twoFactorSecret: string | null;
        lastLoginAt: Date | null;
        lastLoginIp: string | null;
        passwordChangedAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$accountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    services<T extends User$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    assignedServices<T extends User$assignedServicesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$assignedServicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    loadingOrders<T extends User$loadingOrdersArgs<ExtArgs> = {}>(
      args?: Subset<T, User$loadingOrdersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$LoadingOrderPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$invoicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$auditLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$notificationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly emailVerified: FieldRef<'User', 'DateTime'>;
    readonly password: FieldRef<'User', 'String'>;
    readonly name: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'UserRole'>;
    readonly avatar: FieldRef<'User', 'String'>;
    readonly phone: FieldRef<'User', 'String'>;
    readonly department: FieldRef<'User', 'String'>;
    readonly isActive: FieldRef<'User', 'Boolean'>;
    readonly twoFactorEnabled: FieldRef<'User', 'Boolean'>;
    readonly twoFactorSecret: FieldRef<'User', 'String'>;
    readonly lastLoginAt: FieldRef<'User', 'DateTime'>;
    readonly lastLoginIp: FieldRef<'User', 'String'>;
    readonly passwordChangedAt: FieldRef<'User', 'DateTime'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
    readonly deletedAt: FieldRef<'User', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.accounts
   */
  export type User$accountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.services
   */
  export type User$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * User.assignedServices
   */
  export type User$assignedServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * User.loadingOrders
   */
  export type User$loadingOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    where?: LoadingOrderWhereInput;
    orderBy?: LoadingOrderOrderByWithRelationInput | LoadingOrderOrderByWithRelationInput[];
    cursor?: LoadingOrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LoadingOrderScalarFieldEnum | LoadingOrderScalarFieldEnum[];
  };

  /**
   * User.invoices
   */
  export type User$invoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    cursor?: InvoiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * User.notifications
   */
  export type User$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null;
    _min: CompanyMinAggregateOutputType | null;
    _max: CompanyMaxAggregateOutputType | null;
  };

  export type CompanyMinAggregateOutputType = {
    id: string | null;
    code: string | null;
    legalName: string | null;
    tradeName: string | null;
    vatNumber: string | null;
    registrationNo: string | null;
    addressLine1: string | null;
    addressLine2: string | null;
    city: string | null;
    state: string | null;
    postalCode: string | null;
    country: string | null;
    phone: string | null;
    fax: string | null;
    email: string | null;
    website: string | null;
    bankName: string | null;
    bankAccount: string | null;
    swiftCode: string | null;
    iban: string | null;
    currency: string | null;
    timezone: string | null;
    fiscalYearEnd: string | null;
    invoicePrefix: string | null;
    logoUrl: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type CompanyMaxAggregateOutputType = {
    id: string | null;
    code: string | null;
    legalName: string | null;
    tradeName: string | null;
    vatNumber: string | null;
    registrationNo: string | null;
    addressLine1: string | null;
    addressLine2: string | null;
    city: string | null;
    state: string | null;
    postalCode: string | null;
    country: string | null;
    phone: string | null;
    fax: string | null;
    email: string | null;
    website: string | null;
    bankName: string | null;
    bankAccount: string | null;
    swiftCode: string | null;
    iban: string | null;
    currency: string | null;
    timezone: string | null;
    fiscalYearEnd: string | null;
    invoicePrefix: string | null;
    logoUrl: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type CompanyCountAggregateOutputType = {
    id: number;
    code: number;
    legalName: number;
    tradeName: number;
    vatNumber: number;
    registrationNo: number;
    addressLine1: number;
    addressLine2: number;
    city: number;
    state: number;
    postalCode: number;
    country: number;
    phone: number;
    fax: number;
    email: number;
    website: number;
    bankName: number;
    bankAccount: number;
    swiftCode: number;
    iban: number;
    currency: number;
    timezone: number;
    fiscalYearEnd: number;
    invoicePrefix: number;
    logoUrl: number;
    metadata: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type CompanyMinAggregateInputType = {
    id?: true;
    code?: true;
    legalName?: true;
    tradeName?: true;
    vatNumber?: true;
    registrationNo?: true;
    addressLine1?: true;
    addressLine2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    fax?: true;
    email?: true;
    website?: true;
    bankName?: true;
    bankAccount?: true;
    swiftCode?: true;
    iban?: true;
    currency?: true;
    timezone?: true;
    fiscalYearEnd?: true;
    invoicePrefix?: true;
    logoUrl?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type CompanyMaxAggregateInputType = {
    id?: true;
    code?: true;
    legalName?: true;
    tradeName?: true;
    vatNumber?: true;
    registrationNo?: true;
    addressLine1?: true;
    addressLine2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    fax?: true;
    email?: true;
    website?: true;
    bankName?: true;
    bankAccount?: true;
    swiftCode?: true;
    iban?: true;
    currency?: true;
    timezone?: true;
    fiscalYearEnd?: true;
    invoicePrefix?: true;
    logoUrl?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type CompanyCountAggregateInputType = {
    id?: true;
    code?: true;
    legalName?: true;
    tradeName?: true;
    vatNumber?: true;
    registrationNo?: true;
    addressLine1?: true;
    addressLine2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    fax?: true;
    email?: true;
    website?: true;
    bankName?: true;
    bankAccount?: true;
    swiftCode?: true;
    iban?: true;
    currency?: true;
    timezone?: true;
    fiscalYearEnd?: true;
    invoicePrefix?: true;
    logoUrl?: true;
    metadata?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type CompanyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Companies
     **/
    _count?: true | CompanyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CompanyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CompanyMaxAggregateInputType;
  };

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
    [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>;
  };

  export type CompanyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[];
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum;
    having?: CompanyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CompanyCountAggregateInputType | true;
    _min?: CompanyMinAggregateInputType;
    _max?: CompanyMaxAggregateInputType;
  };

  export type CompanyGroupByOutputType = {
    id: string;
    code: string;
    legalName: string;
    tradeName: string | null;
    vatNumber: string;
    registrationNo: string | null;
    addressLine1: string;
    addressLine2: string | null;
    city: string;
    state: string | null;
    postalCode: string;
    country: string;
    phone: string;
    fax: string | null;
    email: string;
    website: string | null;
    bankName: string | null;
    bankAccount: string | null;
    swiftCode: string | null;
    iban: string | null;
    currency: string;
    timezone: string;
    fiscalYearEnd: string | null;
    invoicePrefix: string | null;
    logoUrl: string | null;
    metadata: JsonValue | null;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: CompanyCountAggregateOutputType | null;
    _min: CompanyMinAggregateOutputType | null;
    _max: CompanyMaxAggregateOutputType | null;
  };

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CompanyGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
          : GetScalarType<T[P], CompanyGroupByOutputType[P]>;
      }
    >
  >;

  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        code?: boolean;
        legalName?: boolean;
        tradeName?: boolean;
        vatNumber?: boolean;
        registrationNo?: boolean;
        addressLine1?: boolean;
        addressLine2?: boolean;
        city?: boolean;
        state?: boolean;
        postalCode?: boolean;
        country?: boolean;
        phone?: boolean;
        fax?: boolean;
        email?: boolean;
        website?: boolean;
        bankName?: boolean;
        bankAccount?: boolean;
        swiftCode?: boolean;
        iban?: boolean;
        currency?: boolean;
        timezone?: boolean;
        fiscalYearEnd?: boolean;
        invoicePrefix?: boolean;
        logoUrl?: boolean;
        metadata?: boolean;
        isActive?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        asClient?: boolean | Company$asClientArgs<ExtArgs>;
        asSupplier?: boolean | Company$asSupplierArgs<ExtArgs>;
        _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['company']
    >;

  export type CompanySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      code?: boolean;
      legalName?: boolean;
      tradeName?: boolean;
      vatNumber?: boolean;
      registrationNo?: boolean;
      addressLine1?: boolean;
      addressLine2?: boolean;
      city?: boolean;
      state?: boolean;
      postalCode?: boolean;
      country?: boolean;
      phone?: boolean;
      fax?: boolean;
      email?: boolean;
      website?: boolean;
      bankName?: boolean;
      bankAccount?: boolean;
      swiftCode?: boolean;
      iban?: boolean;
      currency?: boolean;
      timezone?: boolean;
      fiscalYearEnd?: boolean;
      invoicePrefix?: boolean;
      logoUrl?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
    },
    ExtArgs['result']['company']
  >;

  export type CompanySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      code?: boolean;
      legalName?: boolean;
      tradeName?: boolean;
      vatNumber?: boolean;
      registrationNo?: boolean;
      addressLine1?: boolean;
      addressLine2?: boolean;
      city?: boolean;
      state?: boolean;
      postalCode?: boolean;
      country?: boolean;
      phone?: boolean;
      fax?: boolean;
      email?: boolean;
      website?: boolean;
      bankName?: boolean;
      bankAccount?: boolean;
      swiftCode?: boolean;
      iban?: boolean;
      currency?: boolean;
      timezone?: boolean;
      fiscalYearEnd?: boolean;
      invoicePrefix?: boolean;
      logoUrl?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
    },
    ExtArgs['result']['company']
  >;

  export type CompanySelectScalar = {
    id?: boolean;
    code?: boolean;
    legalName?: boolean;
    tradeName?: boolean;
    vatNumber?: boolean;
    registrationNo?: boolean;
    addressLine1?: boolean;
    addressLine2?: boolean;
    city?: boolean;
    state?: boolean;
    postalCode?: boolean;
    country?: boolean;
    phone?: boolean;
    fax?: boolean;
    email?: boolean;
    website?: boolean;
    bankName?: boolean;
    bankAccount?: boolean;
    swiftCode?: boolean;
    iban?: boolean;
    currency?: boolean;
    timezone?: boolean;
    fiscalYearEnd?: boolean;
    invoicePrefix?: boolean;
    logoUrl?: boolean;
    metadata?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'code'
      | 'legalName'
      | 'tradeName'
      | 'vatNumber'
      | 'registrationNo'
      | 'addressLine1'
      | 'addressLine2'
      | 'city'
      | 'state'
      | 'postalCode'
      | 'country'
      | 'phone'
      | 'fax'
      | 'email'
      | 'website'
      | 'bankName'
      | 'bankAccount'
      | 'swiftCode'
      | 'iban'
      | 'currency'
      | 'timezone'
      | 'fiscalYearEnd'
      | 'invoicePrefix'
      | 'logoUrl'
      | 'metadata'
      | 'isActive'
      | 'createdAt'
      | 'updatedAt'
      | 'deletedAt',
      ExtArgs['result']['company']
    >;
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asClient?: boolean | Company$asClientArgs<ExtArgs>;
    asSupplier?: boolean | Company$asSupplierArgs<ExtArgs>;
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CompanyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type CompanyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Company';
      objects: {
        asClient: Prisma.$ClientPayload<ExtArgs>[];
        asSupplier: Prisma.$SupplierPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          code: string;
          legalName: string;
          tradeName: string | null;
          vatNumber: string;
          registrationNo: string | null;
          addressLine1: string;
          addressLine2: string | null;
          city: string;
          state: string | null;
          postalCode: string;
          country: string;
          phone: string;
          fax: string | null;
          email: string;
          website: string | null;
          bankName: string | null;
          bankAccount: string | null;
          swiftCode: string | null;
          iban: string | null;
          currency: string;
          timezone: string;
          fiscalYearEnd: string | null;
          invoicePrefix: string | null;
          logoUrl: string | null;
          metadata: Prisma.JsonValue | null;
          isActive: boolean;
          createdAt: Date;
          updatedAt: Date;
          deletedAt: Date | null;
        },
        ExtArgs['result']['company']
      >;
      composites: {};
    };

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> =
    $Result.GetResult<Prisma.$CompanyPayload, S>;

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    CompanyFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CompanyCountAggregateInputType | true;
  };

  export interface CompanyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company']; meta: { name: 'Company' } };
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(
      args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(
      args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     *
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CompanyFindManyArgs>(
      args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     *
     */
    create<T extends CompanyCreateArgs>(
      args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CompanyCreateManyArgs>(
      args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     *
     */
    delete<T extends CompanyDeleteArgs>(
      args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CompanyUpdateArgs>(
      args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CompanyDeleteManyArgs>(
      args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CompanyUpdateManyArgs>(
      args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(
      args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
     **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CompanyAggregateArgs>(
      args: Subset<T, CompanyAggregateArgs>
    ): Prisma.PrismaPromise<GetCompanyAggregateType<T>>;

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Company model
     */
    readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    asClient<T extends Company$asClientArgs<ExtArgs> = {}>(
      args?: Subset<T, Company$asClientArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    asSupplier<T extends Company$asSupplierArgs<ExtArgs> = {}>(
      args?: Subset<T, Company$asSupplierArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<'Company', 'String'>;
    readonly code: FieldRef<'Company', 'String'>;
    readonly legalName: FieldRef<'Company', 'String'>;
    readonly tradeName: FieldRef<'Company', 'String'>;
    readonly vatNumber: FieldRef<'Company', 'String'>;
    readonly registrationNo: FieldRef<'Company', 'String'>;
    readonly addressLine1: FieldRef<'Company', 'String'>;
    readonly addressLine2: FieldRef<'Company', 'String'>;
    readonly city: FieldRef<'Company', 'String'>;
    readonly state: FieldRef<'Company', 'String'>;
    readonly postalCode: FieldRef<'Company', 'String'>;
    readonly country: FieldRef<'Company', 'String'>;
    readonly phone: FieldRef<'Company', 'String'>;
    readonly fax: FieldRef<'Company', 'String'>;
    readonly email: FieldRef<'Company', 'String'>;
    readonly website: FieldRef<'Company', 'String'>;
    readonly bankName: FieldRef<'Company', 'String'>;
    readonly bankAccount: FieldRef<'Company', 'String'>;
    readonly swiftCode: FieldRef<'Company', 'String'>;
    readonly iban: FieldRef<'Company', 'String'>;
    readonly currency: FieldRef<'Company', 'String'>;
    readonly timezone: FieldRef<'Company', 'String'>;
    readonly fiscalYearEnd: FieldRef<'Company', 'String'>;
    readonly invoicePrefix: FieldRef<'Company', 'String'>;
    readonly logoUrl: FieldRef<'Company', 'String'>;
    readonly metadata: FieldRef<'Company', 'Json'>;
    readonly isActive: FieldRef<'Company', 'Boolean'>;
    readonly createdAt: FieldRef<'Company', 'DateTime'>;
    readonly updatedAt: FieldRef<'Company', 'DateTime'>;
    readonly deletedAt: FieldRef<'Company', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput;
  };

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput;
  };

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
  };

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
  };

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     */
    skip?: number;
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
  };

  /**
   * Company create
   */
  export type CompanyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>;
  };

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Company update
   */
  export type CompanyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>;
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput;
  };

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>;
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput;
    /**
     * Limit how many Companies to update.
     */
    limit?: number;
  };

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>;
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput;
    /**
     * Limit how many Companies to update.
     */
    limit?: number;
  };

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput;
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>;
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>;
  };

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput;
  };

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput;
    /**
     * Limit how many Companies to delete.
     */
    limit?: number;
  };

  /**
   * Company.asClient
   */
  export type Company$asClientArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null;
    where?: ClientWhereInput;
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[];
    cursor?: ClientWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[];
  };

  /**
   * Company.asSupplier
   */
  export type Company$asSupplierArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[];
    cursor?: SupplierWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[];
  };

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
  };

  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null;
    _avg: ClientAvgAggregateOutputType | null;
    _sum: ClientSumAggregateOutputType | null;
    _min: ClientMinAggregateOutputType | null;
    _max: ClientMaxAggregateOutputType | null;
  };

  export type ClientAvgAggregateOutputType = {
    creditLimit: Decimal | null;
    paymentTerms: number | null;
    discount: Decimal | null;
  };

  export type ClientSumAggregateOutputType = {
    creditLimit: Decimal | null;
    paymentTerms: number | null;
    discount: Decimal | null;
  };

  export type ClientMinAggregateOutputType = {
    id: string | null;
    clientCode: string | null;
    companyId: string | null;
    name: string | null;
    tradeName: string | null;
    vatNumber: string | null;
    billingEmail: string | null;
    trafficEmail: string | null;
    contactPerson: string | null;
    contactPhone: string | null;
    contactMobile: string | null;
    creditLimit: Decimal | null;
    paymentTerms: number | null;
    discount: Decimal | null;
    currency: string | null;
    language: string | null;
    sendReminders: boolean | null;
    autoInvoice: boolean | null;
    notes: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type ClientMaxAggregateOutputType = {
    id: string | null;
    clientCode: string | null;
    companyId: string | null;
    name: string | null;
    tradeName: string | null;
    vatNumber: string | null;
    billingEmail: string | null;
    trafficEmail: string | null;
    contactPerson: string | null;
    contactPhone: string | null;
    contactMobile: string | null;
    creditLimit: Decimal | null;
    paymentTerms: number | null;
    discount: Decimal | null;
    currency: string | null;
    language: string | null;
    sendReminders: boolean | null;
    autoInvoice: boolean | null;
    notes: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type ClientCountAggregateOutputType = {
    id: number;
    clientCode: number;
    companyId: number;
    name: number;
    tradeName: number;
    vatNumber: number;
    billingAddress: number;
    shippingAddress: number;
    billingEmail: number;
    trafficEmail: number;
    contactPerson: number;
    contactPhone: number;
    contactMobile: number;
    creditLimit: number;
    paymentTerms: number;
    discount: number;
    currency: number;
    language: number;
    sendReminders: number;
    autoInvoice: number;
    notes: number;
    tags: number;
    metadata: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type ClientAvgAggregateInputType = {
    creditLimit?: true;
    paymentTerms?: true;
    discount?: true;
  };

  export type ClientSumAggregateInputType = {
    creditLimit?: true;
    paymentTerms?: true;
    discount?: true;
  };

  export type ClientMinAggregateInputType = {
    id?: true;
    clientCode?: true;
    companyId?: true;
    name?: true;
    tradeName?: true;
    vatNumber?: true;
    billingEmail?: true;
    trafficEmail?: true;
    contactPerson?: true;
    contactPhone?: true;
    contactMobile?: true;
    creditLimit?: true;
    paymentTerms?: true;
    discount?: true;
    currency?: true;
    language?: true;
    sendReminders?: true;
    autoInvoice?: true;
    notes?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type ClientMaxAggregateInputType = {
    id?: true;
    clientCode?: true;
    companyId?: true;
    name?: true;
    tradeName?: true;
    vatNumber?: true;
    billingEmail?: true;
    trafficEmail?: true;
    contactPerson?: true;
    contactPhone?: true;
    contactMobile?: true;
    creditLimit?: true;
    paymentTerms?: true;
    discount?: true;
    currency?: true;
    language?: true;
    sendReminders?: true;
    autoInvoice?: true;
    notes?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type ClientCountAggregateInputType = {
    id?: true;
    clientCode?: true;
    companyId?: true;
    name?: true;
    tradeName?: true;
    vatNumber?: true;
    billingAddress?: true;
    shippingAddress?: true;
    billingEmail?: true;
    trafficEmail?: true;
    contactPerson?: true;
    contactPhone?: true;
    contactMobile?: true;
    creditLimit?: true;
    paymentTerms?: true;
    discount?: true;
    currency?: true;
    language?: true;
    sendReminders?: true;
    autoInvoice?: true;
    notes?: true;
    tags?: true;
    metadata?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type ClientAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clients.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Clients
     **/
    _count?: true | ClientCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ClientAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ClientSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClientMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClientMaxAggregateInputType;
  };

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
    [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>;
  };

  export type ClientGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[];
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum;
    having?: ClientScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClientCountAggregateInputType | true;
    _avg?: ClientAvgAggregateInputType;
    _sum?: ClientSumAggregateInputType;
    _min?: ClientMinAggregateInputType;
    _max?: ClientMaxAggregateInputType;
  };

  export type ClientGroupByOutputType = {
    id: string;
    clientCode: string;
    companyId: string | null;
    name: string;
    tradeName: string | null;
    vatNumber: string | null;
    billingAddress: JsonValue;
    shippingAddress: JsonValue | null;
    billingEmail: string;
    trafficEmail: string | null;
    contactPerson: string | null;
    contactPhone: string | null;
    contactMobile: string | null;
    creditLimit: Decimal | null;
    paymentTerms: number;
    discount: Decimal | null;
    currency: string;
    language: string;
    sendReminders: boolean;
    autoInvoice: boolean;
    notes: string | null;
    tags: string[];
    metadata: JsonValue | null;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: ClientCountAggregateOutputType | null;
    _avg: ClientAvgAggregateOutputType | null;
    _sum: ClientSumAggregateOutputType | null;
    _min: ClientMinAggregateOutputType | null;
    _max: ClientMaxAggregateOutputType | null;
  };

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ClientGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
          : GetScalarType<T[P], ClientGroupByOutputType[P]>;
      }
    >
  >;

  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        clientCode?: boolean;
        companyId?: boolean;
        name?: boolean;
        tradeName?: boolean;
        vatNumber?: boolean;
        billingAddress?: boolean;
        shippingAddress?: boolean;
        billingEmail?: boolean;
        trafficEmail?: boolean;
        contactPerson?: boolean;
        contactPhone?: boolean;
        contactMobile?: boolean;
        creditLimit?: boolean;
        paymentTerms?: boolean;
        discount?: boolean;
        currency?: boolean;
        language?: boolean;
        sendReminders?: boolean;
        autoInvoice?: boolean;
        notes?: boolean;
        tags?: boolean;
        metadata?: boolean;
        isActive?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        company?: boolean | Client$companyArgs<ExtArgs>;
        services?: boolean | Client$servicesArgs<ExtArgs>;
        contacts?: boolean | Client$contactsArgs<ExtArgs>;
        documents?: boolean | Client$documentsArgs<ExtArgs>;
        _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['client']
    >;

  export type ClientSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      clientCode?: boolean;
      companyId?: boolean;
      name?: boolean;
      tradeName?: boolean;
      vatNumber?: boolean;
      billingAddress?: boolean;
      shippingAddress?: boolean;
      billingEmail?: boolean;
      trafficEmail?: boolean;
      contactPerson?: boolean;
      contactPhone?: boolean;
      contactMobile?: boolean;
      creditLimit?: boolean;
      paymentTerms?: boolean;
      discount?: boolean;
      currency?: boolean;
      language?: boolean;
      sendReminders?: boolean;
      autoInvoice?: boolean;
      notes?: boolean;
      tags?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      company?: boolean | Client$companyArgs<ExtArgs>;
    },
    ExtArgs['result']['client']
  >;

  export type ClientSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      clientCode?: boolean;
      companyId?: boolean;
      name?: boolean;
      tradeName?: boolean;
      vatNumber?: boolean;
      billingAddress?: boolean;
      shippingAddress?: boolean;
      billingEmail?: boolean;
      trafficEmail?: boolean;
      contactPerson?: boolean;
      contactPhone?: boolean;
      contactMobile?: boolean;
      creditLimit?: boolean;
      paymentTerms?: boolean;
      discount?: boolean;
      currency?: boolean;
      language?: boolean;
      sendReminders?: boolean;
      autoInvoice?: boolean;
      notes?: boolean;
      tags?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      company?: boolean | Client$companyArgs<ExtArgs>;
    },
    ExtArgs['result']['client']
  >;

  export type ClientSelectScalar = {
    id?: boolean;
    clientCode?: boolean;
    companyId?: boolean;
    name?: boolean;
    tradeName?: boolean;
    vatNumber?: boolean;
    billingAddress?: boolean;
    shippingAddress?: boolean;
    billingEmail?: boolean;
    trafficEmail?: boolean;
    contactPerson?: boolean;
    contactPhone?: boolean;
    contactMobile?: boolean;
    creditLimit?: boolean;
    paymentTerms?: boolean;
    discount?: boolean;
    currency?: boolean;
    language?: boolean;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: boolean;
    tags?: boolean;
    metadata?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'clientCode'
      | 'companyId'
      | 'name'
      | 'tradeName'
      | 'vatNumber'
      | 'billingAddress'
      | 'shippingAddress'
      | 'billingEmail'
      | 'trafficEmail'
      | 'contactPerson'
      | 'contactPhone'
      | 'contactMobile'
      | 'creditLimit'
      | 'paymentTerms'
      | 'discount'
      | 'currency'
      | 'language'
      | 'sendReminders'
      | 'autoInvoice'
      | 'notes'
      | 'tags'
      | 'metadata'
      | 'isActive'
      | 'createdAt'
      | 'updatedAt'
      | 'deletedAt',
      ExtArgs['result']['client']
    >;
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Client$companyArgs<ExtArgs>;
    services?: boolean | Client$servicesArgs<ExtArgs>;
    contacts?: boolean | Client$contactsArgs<ExtArgs>;
    documents?: boolean | Client$documentsArgs<ExtArgs>;
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ClientIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    company?: boolean | Client$companyArgs<ExtArgs>;
  };
  export type ClientIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    company?: boolean | Client$companyArgs<ExtArgs>;
  };

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Client';
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null;
      services: Prisma.$ServicePayload<ExtArgs>[];
      contacts: Prisma.$ClientContactPayload<ExtArgs>[];
      documents: Prisma.$DocumentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        clientCode: string;
        companyId: string | null;
        name: string;
        tradeName: string | null;
        vatNumber: string | null;
        billingAddress: Prisma.JsonValue;
        shippingAddress: Prisma.JsonValue | null;
        billingEmail: string;
        trafficEmail: string | null;
        contactPerson: string | null;
        contactPhone: string | null;
        contactMobile: string | null;
        creditLimit: Prisma.Decimal | null;
        paymentTerms: number;
        discount: Prisma.Decimal | null;
        currency: string;
        language: string;
        sendReminders: boolean;
        autoInvoice: boolean;
        notes: string | null;
        tags: string[];
        metadata: Prisma.JsonValue | null;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['client']
    >;
    composites: {};
  };

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> =
    $Result.GetResult<Prisma.$ClientPayload, S>;

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ClientFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ClientCountAggregateInputType | true;
  };

  export interface ClientDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client']; meta: { name: 'Client' } };
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(
      args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(
      args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     *
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ClientFindManyArgs>(
      args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     *
     */
    create<T extends ClientCreateArgs>(
      args: SelectSubset<T, ClientCreateArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ClientCreateManyArgs>(
      args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     *
     */
    delete<T extends ClientDeleteArgs>(
      args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ClientUpdateArgs>(
      args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ClientDeleteManyArgs>(
      args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ClientUpdateManyArgs>(
      args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(
      args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
     **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClientAggregateArgs>(
      args: Subset<T, ClientAggregateArgs>
    ): Prisma.PrismaPromise<GetClientAggregateType<T>>;

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Client model
     */
    readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    company<T extends Client$companyArgs<ExtArgs> = {}>(
      args?: Subset<T, Client$companyArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    services<T extends Client$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Client$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    contacts<T extends Client$contactsArgs<ExtArgs> = {}>(
      args?: Subset<T, Client$contactsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    documents<T extends Client$documentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Client$documentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<'Client', 'String'>;
    readonly clientCode: FieldRef<'Client', 'String'>;
    readonly companyId: FieldRef<'Client', 'String'>;
    readonly name: FieldRef<'Client', 'String'>;
    readonly tradeName: FieldRef<'Client', 'String'>;
    readonly vatNumber: FieldRef<'Client', 'String'>;
    readonly billingAddress: FieldRef<'Client', 'Json'>;
    readonly shippingAddress: FieldRef<'Client', 'Json'>;
    readonly billingEmail: FieldRef<'Client', 'String'>;
    readonly trafficEmail: FieldRef<'Client', 'String'>;
    readonly contactPerson: FieldRef<'Client', 'String'>;
    readonly contactPhone: FieldRef<'Client', 'String'>;
    readonly contactMobile: FieldRef<'Client', 'String'>;
    readonly creditLimit: FieldRef<'Client', 'Decimal'>;
    readonly paymentTerms: FieldRef<'Client', 'Int'>;
    readonly discount: FieldRef<'Client', 'Decimal'>;
    readonly currency: FieldRef<'Client', 'String'>;
    readonly language: FieldRef<'Client', 'String'>;
    readonly sendReminders: FieldRef<'Client', 'Boolean'>;
    readonly autoInvoice: FieldRef<'Client', 'Boolean'>;
    readonly notes: FieldRef<'Client', 'String'>;
    readonly tags: FieldRef<'Client', 'String[]'>;
    readonly metadata: FieldRef<'Client', 'Json'>;
    readonly isActive: FieldRef<'Client', 'Boolean'>;
    readonly createdAt: FieldRef<'Client', 'DateTime'>;
    readonly updatedAt: FieldRef<'Client', 'DateTime'>;
    readonly deletedAt: FieldRef<'Client', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null;
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput;
  };

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null;
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput;
  };

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null;
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clients.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[];
  };

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null;
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clients.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[];
  };

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null;
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clients.
     */
    skip?: number;
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[];
  };

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Client
       */
      select?: ClientSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Client
       */
      omit?: ClientOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClientInclude<ExtArgs> | null;
      /**
       * The data needed to create a Client.
       */
      data: XOR<ClientCreateInput, ClientUncheckedCreateInput>;
    };

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Client
       */
      select?: ClientSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Client
       */
      omit?: ClientOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClientInclude<ExtArgs> | null;
      /**
       * The data needed to update a Client.
       */
      data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>;
      /**
       * Choose, which Client to update.
       */
      where: ClientWhereUniqueInput;
    };

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>;
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput;
    /**
     * Limit how many Clients to update.
     */
    limit?: number;
  };

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>;
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput;
    /**
     * Limit how many Clients to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Client
       */
      select?: ClientSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Client
       */
      omit?: ClientOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClientInclude<ExtArgs> | null;
      /**
       * The filter to search for the Client to update in case it exists.
       */
      where: ClientWhereUniqueInput;
      /**
       * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
       */
      create: XOR<ClientCreateInput, ClientUncheckedCreateInput>;
      /**
       * In case the Client was found with the provided `where` argument, update it with this data.
       */
      update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>;
    };

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Client
       */
      select?: ClientSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Client
       */
      omit?: ClientOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClientInclude<ExtArgs> | null;
      /**
       * Filter which Client to delete.
       */
      where: ClientWhereUniqueInput;
    };

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput;
    /**
     * Limit how many Clients to delete.
     */
    limit?: number;
  };

  /**
   * Client.company
   */
  export type Client$companyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    where?: CompanyWhereInput;
  };

  /**
   * Client.services
   */
  export type Client$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Client.contacts
   */
  export type Client$contactsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    where?: ClientContactWhereInput;
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[];
    cursor?: ClientContactWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClientContactScalarFieldEnum | ClientContactScalarFieldEnum[];
  };

  /**
   * Client.documents
   */
  export type Client$documentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    cursor?: DocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Client without action
   */
  export type ClientDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null;
  };

  /**
   * Model ClientContact
   */

  export type AggregateClientContact = {
    _count: ClientContactCountAggregateOutputType | null;
    _min: ClientContactMinAggregateOutputType | null;
    _max: ClientContactMaxAggregateOutputType | null;
  };

  export type ClientContactMinAggregateOutputType = {
    id: string | null;
    clientId: string | null;
    name: string | null;
    position: string | null;
    email: string | null;
    phone: string | null;
    mobile: string | null;
    isPrimary: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ClientContactMaxAggregateOutputType = {
    id: string | null;
    clientId: string | null;
    name: string | null;
    position: string | null;
    email: string | null;
    phone: string | null;
    mobile: string | null;
    isPrimary: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ClientContactCountAggregateOutputType = {
    id: number;
    clientId: number;
    name: number;
    position: number;
    email: number;
    phone: number;
    mobile: number;
    isPrimary: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ClientContactMinAggregateInputType = {
    id?: true;
    clientId?: true;
    name?: true;
    position?: true;
    email?: true;
    phone?: true;
    mobile?: true;
    isPrimary?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ClientContactMaxAggregateInputType = {
    id?: true;
    clientId?: true;
    name?: true;
    position?: true;
    email?: true;
    phone?: true;
    mobile?: true;
    isPrimary?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ClientContactCountAggregateInputType = {
    id?: true;
    clientId?: true;
    name?: true;
    position?: true;
    email?: true;
    phone?: true;
    mobile?: true;
    isPrimary?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ClientContactAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ClientContact to aggregate.
     */
    where?: ClientContactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClientContacts to fetch.
     */
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ClientContactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ClientContacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClientContacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ClientContacts
     **/
    _count?: true | ClientContactCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClientContactMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClientContactMaxAggregateInputType;
  };

  export type GetClientContactAggregateType<T extends ClientContactAggregateArgs> = {
    [P in keyof T & keyof AggregateClientContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContact[P]>
      : GetScalarType<T[P], AggregateClientContact[P]>;
  };

  export type ClientContactGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClientContactWhereInput;
    orderBy?: ClientContactOrderByWithAggregationInput | ClientContactOrderByWithAggregationInput[];
    by: ClientContactScalarFieldEnum[] | ClientContactScalarFieldEnum;
    having?: ClientContactScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClientContactCountAggregateInputType | true;
    _min?: ClientContactMinAggregateInputType;
    _max?: ClientContactMaxAggregateInputType;
  };

  export type ClientContactGroupByOutputType = {
    id: string;
    clientId: string;
    name: string;
    position: string | null;
    email: string;
    phone: string | null;
    mobile: string | null;
    isPrimary: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: ClientContactCountAggregateOutputType | null;
    _min: ClientContactMinAggregateOutputType | null;
    _max: ClientContactMaxAggregateOutputType | null;
  };

  type GetClientContactGroupByPayload<T extends ClientContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientContactGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ClientContactGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ClientContactGroupByOutputType[P]>
          : GetScalarType<T[P], ClientContactGroupByOutputType[P]>;
      }
    >
  >;

  export type ClientContactSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      clientId?: boolean;
      name?: boolean;
      position?: boolean;
      email?: boolean;
      phone?: boolean;
      mobile?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      client?: boolean | ClientDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['clientContact']
  >;

  export type ClientContactSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      clientId?: boolean;
      name?: boolean;
      position?: boolean;
      email?: boolean;
      phone?: boolean;
      mobile?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      client?: boolean | ClientDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['clientContact']
  >;

  export type ClientContactSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      clientId?: boolean;
      name?: boolean;
      position?: boolean;
      email?: boolean;
      phone?: boolean;
      mobile?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      client?: boolean | ClientDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['clientContact']
  >;

  export type ClientContactSelectScalar = {
    id?: boolean;
    clientId?: boolean;
    name?: boolean;
    position?: boolean;
    email?: boolean;
    phone?: boolean;
    mobile?: boolean;
    isPrimary?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ClientContactOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'clientId'
    | 'name'
    | 'position'
    | 'email'
    | 'phone'
    | 'mobile'
    | 'isPrimary'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['clientContact']
  >;
  export type ClientContactInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    client?: boolean | ClientDefaultArgs<ExtArgs>;
  };
  export type ClientContactIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    client?: boolean | ClientDefaultArgs<ExtArgs>;
  };
  export type ClientContactIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    client?: boolean | ClientDefaultArgs<ExtArgs>;
  };

  export type $ClientContactPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ClientContact';
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        clientId: string;
        name: string;
        position: string | null;
        email: string;
        phone: string | null;
        mobile: string | null;
        isPrimary: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['clientContact']
    >;
    composites: {};
  };

  type ClientContactGetPayload<S extends boolean | null | undefined | ClientContactDefaultArgs> =
    $Result.GetResult<Prisma.$ClientContactPayload, S>;

  type ClientContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientContactCountAggregateInputType | true;
    };

  export interface ClientContactDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ClientContact'];
      meta: { name: 'ClientContact' };
    };
    /**
     * Find zero or one ClientContact that matches the filter.
     * @param {ClientContactFindUniqueArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientContactFindUniqueArgs>(
      args: SelectSubset<T, ClientContactFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientContactClient<
      $Result.GetResult<
        Prisma.$ClientContactPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ClientContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientContactFindUniqueOrThrowArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientContactFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ClientContactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContactClient<
      $Result.GetResult<
        Prisma.$ClientContactPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ClientContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactFindFirstArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientContactFindFirstArgs>(
      args?: SelectSubset<T, ClientContactFindFirstArgs<ExtArgs>>
    ): Prisma__ClientContactClient<
      $Result.GetResult<
        Prisma.$ClientContactPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ClientContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactFindFirstOrThrowArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientContactFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClientContactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientContactClient<
      $Result.GetResult<
        Prisma.$ClientContactPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ClientContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContacts
     * const clientContacts = await prisma.clientContact.findMany()
     *
     * // Get first 10 ClientContacts
     * const clientContacts = await prisma.clientContact.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const clientContactWithIdOnly = await prisma.clientContact.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ClientContactFindManyArgs>(
      args?: SelectSubset<T, ClientContactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ClientContact.
     * @param {ClientContactCreateArgs} args - Arguments to create a ClientContact.
     * @example
     * // Create one ClientContact
     * const ClientContact = await prisma.clientContact.create({
     *   data: {
     *     // ... data to create a ClientContact
     *   }
     * })
     *
     */
    create<T extends ClientContactCreateArgs>(
      args: SelectSubset<T, ClientContactCreateArgs<ExtArgs>>
    ): Prisma__ClientContactClient<
      $Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ClientContacts.
     * @param {ClientContactCreateManyArgs} args - Arguments to create many ClientContacts.
     * @example
     * // Create many ClientContacts
     * const clientContact = await prisma.clientContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ClientContactCreateManyArgs>(
      args?: SelectSubset<T, ClientContactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ClientContacts and returns the data saved in the database.
     * @param {ClientContactCreateManyAndReturnArgs} args - Arguments to create many ClientContacts.
     * @example
     * // Create many ClientContacts
     * const clientContact = await prisma.clientContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ClientContacts and only return the `id`
     * const clientContactWithIdOnly = await prisma.clientContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ClientContactCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ClientContactCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ClientContactPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ClientContact.
     * @param {ClientContactDeleteArgs} args - Arguments to delete one ClientContact.
     * @example
     * // Delete one ClientContact
     * const ClientContact = await prisma.clientContact.delete({
     *   where: {
     *     // ... filter to delete one ClientContact
     *   }
     * })
     *
     */
    delete<T extends ClientContactDeleteArgs>(
      args: SelectSubset<T, ClientContactDeleteArgs<ExtArgs>>
    ): Prisma__ClientContactClient<
      $Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ClientContact.
     * @param {ClientContactUpdateArgs} args - Arguments to update one ClientContact.
     * @example
     * // Update one ClientContact
     * const clientContact = await prisma.clientContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ClientContactUpdateArgs>(
      args: SelectSubset<T, ClientContactUpdateArgs<ExtArgs>>
    ): Prisma__ClientContactClient<
      $Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ClientContacts.
     * @param {ClientContactDeleteManyArgs} args - Arguments to filter ClientContacts to delete.
     * @example
     * // Delete a few ClientContacts
     * const { count } = await prisma.clientContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ClientContactDeleteManyArgs>(
      args?: SelectSubset<T, ClientContactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ClientContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContacts
     * const clientContact = await prisma.clientContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ClientContactUpdateManyArgs>(
      args: SelectSubset<T, ClientContactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ClientContacts and returns the data updated in the database.
     * @param {ClientContactUpdateManyAndReturnArgs} args - Arguments to update many ClientContacts.
     * @example
     * // Update many ClientContacts
     * const clientContact = await prisma.clientContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ClientContacts and only return the `id`
     * const clientContactWithIdOnly = await prisma.clientContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ClientContactUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ClientContactUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ClientContactPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ClientContact.
     * @param {ClientContactUpsertArgs} args - Arguments to update or create a ClientContact.
     * @example
     * // Update or create a ClientContact
     * const clientContact = await prisma.clientContact.upsert({
     *   create: {
     *     // ... data to create a ClientContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContact we want to update
     *   }
     * })
     */
    upsert<T extends ClientContactUpsertArgs>(
      args: SelectSubset<T, ClientContactUpsertArgs<ExtArgs>>
    ): Prisma__ClientContactClient<
      $Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ClientContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactCountArgs} args - Arguments to filter ClientContacts to count.
     * @example
     * // Count the number of ClientContacts
     * const count = await prisma.clientContact.count({
     *   where: {
     *     // ... the filter for the ClientContacts we want to count
     *   }
     * })
     **/
    count<T extends ClientContactCountArgs>(
      args?: Subset<T, ClientContactCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContactCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ClientContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClientContactAggregateArgs>(
      args: Subset<T, ClientContactAggregateArgs>
    ): Prisma.PrismaPromise<GetClientContactAggregateType<T>>;

    /**
     * Group by ClientContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ClientContactGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContactGroupByArgs['orderBy'] }
        : { orderBy?: ClientContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ClientContactGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetClientContactGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ClientContact model
     */
    readonly fields: ClientContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientContactClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClientDefaultArgs<ExtArgs>>
    ): Prisma__ClientClient<
      | $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ClientContact model
   */
  interface ClientContactFieldRefs {
    readonly id: FieldRef<'ClientContact', 'String'>;
    readonly clientId: FieldRef<'ClientContact', 'String'>;
    readonly name: FieldRef<'ClientContact', 'String'>;
    readonly position: FieldRef<'ClientContact', 'String'>;
    readonly email: FieldRef<'ClientContact', 'String'>;
    readonly phone: FieldRef<'ClientContact', 'String'>;
    readonly mobile: FieldRef<'ClientContact', 'String'>;
    readonly isPrimary: FieldRef<'ClientContact', 'Boolean'>;
    readonly createdAt: FieldRef<'ClientContact', 'DateTime'>;
    readonly updatedAt: FieldRef<'ClientContact', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ClientContact findUnique
   */
  export type ClientContactFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * Filter, which ClientContact to fetch.
     */
    where: ClientContactWhereUniqueInput;
  };

  /**
   * ClientContact findUniqueOrThrow
   */
  export type ClientContactFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * Filter, which ClientContact to fetch.
     */
    where: ClientContactWhereUniqueInput;
  };

  /**
   * ClientContact findFirst
   */
  export type ClientContactFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * Filter, which ClientContact to fetch.
     */
    where?: ClientContactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClientContacts to fetch.
     */
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ClientContacts.
     */
    cursor?: ClientContactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ClientContacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClientContacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ClientContacts.
     */
    distinct?: ClientContactScalarFieldEnum | ClientContactScalarFieldEnum[];
  };

  /**
   * ClientContact findFirstOrThrow
   */
  export type ClientContactFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * Filter, which ClientContact to fetch.
     */
    where?: ClientContactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClientContacts to fetch.
     */
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ClientContacts.
     */
    cursor?: ClientContactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ClientContacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClientContacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ClientContacts.
     */
    distinct?: ClientContactScalarFieldEnum | ClientContactScalarFieldEnum[];
  };

  /**
   * ClientContact findMany
   */
  export type ClientContactFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * Filter, which ClientContacts to fetch.
     */
    where?: ClientContactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClientContacts to fetch.
     */
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ClientContacts.
     */
    cursor?: ClientContactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ClientContacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClientContacts.
     */
    skip?: number;
    distinct?: ClientContactScalarFieldEnum | ClientContactScalarFieldEnum[];
  };

  /**
   * ClientContact create
   */
  export type ClientContactCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * The data needed to create a ClientContact.
     */
    data: XOR<ClientContactCreateInput, ClientContactUncheckedCreateInput>;
  };

  /**
   * ClientContact createMany
   */
  export type ClientContactCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ClientContacts.
     */
    data: ClientContactCreateManyInput | ClientContactCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ClientContact createManyAndReturn
   */
  export type ClientContactCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * The data used to create many ClientContacts.
     */
    data: ClientContactCreateManyInput | ClientContactCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ClientContact update
   */
  export type ClientContactUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * The data needed to update a ClientContact.
     */
    data: XOR<ClientContactUpdateInput, ClientContactUncheckedUpdateInput>;
    /**
     * Choose, which ClientContact to update.
     */
    where: ClientContactWhereUniqueInput;
  };

  /**
   * ClientContact updateMany
   */
  export type ClientContactUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ClientContacts.
     */
    data: XOR<ClientContactUpdateManyMutationInput, ClientContactUncheckedUpdateManyInput>;
    /**
     * Filter which ClientContacts to update
     */
    where?: ClientContactWhereInput;
    /**
     * Limit how many ClientContacts to update.
     */
    limit?: number;
  };

  /**
   * ClientContact updateManyAndReturn
   */
  export type ClientContactUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * The data used to update ClientContacts.
     */
    data: XOR<ClientContactUpdateManyMutationInput, ClientContactUncheckedUpdateManyInput>;
    /**
     * Filter which ClientContacts to update
     */
    where?: ClientContactWhereInput;
    /**
     * Limit how many ClientContacts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ClientContact upsert
   */
  export type ClientContactUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * The filter to search for the ClientContact to update in case it exists.
     */
    where: ClientContactWhereUniqueInput;
    /**
     * In case the ClientContact found by the `where` argument doesn't exist, create a new ClientContact with this data.
     */
    create: XOR<ClientContactCreateInput, ClientContactUncheckedCreateInput>;
    /**
     * In case the ClientContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientContactUpdateInput, ClientContactUncheckedUpdateInput>;
  };

  /**
   * ClientContact delete
   */
  export type ClientContactDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
    /**
     * Filter which ClientContact to delete.
     */
    where: ClientContactWhereUniqueInput;
  };

  /**
   * ClientContact deleteMany
   */
  export type ClientContactDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ClientContacts to delete
     */
    where?: ClientContactWhereInput;
    /**
     * Limit how many ClientContacts to delete.
     */
    limit?: number;
  };

  /**
   * ClientContact without action
   */
  export type ClientContactDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null;
  };

  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null;
    _avg: SupplierAvgAggregateOutputType | null;
    _sum: SupplierSumAggregateOutputType | null;
    _min: SupplierMinAggregateOutputType | null;
    _max: SupplierMaxAggregateOutputType | null;
  };

  export type SupplierAvgAggregateOutputType = {
    irpfRate: Decimal | null;
    vatRate: Decimal | null;
    paymentTerms: number | null;
  };

  export type SupplierSumAggregateOutputType = {
    irpfRate: Decimal | null;
    vatRate: Decimal | null;
    paymentTerms: number | null;
  };

  export type SupplierMinAggregateOutputType = {
    id: string | null;
    supplierCode: string | null;
    companyId: string | null;
    name: string | null;
    tradeName: string | null;
    vatNumber: string | null;
    addressLine1: string | null;
    addressLine2: string | null;
    city: string | null;
    state: string | null;
    postalCode: string | null;
    country: string | null;
    email: string | null;
    phone: string | null;
    fax: string | null;
    contactPerson: string | null;
    contactMobile: string | null;
    irpfRate: Decimal | null;
    vatRate: Decimal | null;
    paymentTerms: number | null;
    paymentMethod: string | null;
    bankName: string | null;
    bankAccount: string | null;
    swiftCode: string | null;
    iban: string | null;
    currency: string | null;
    autoApprove: boolean | null;
    requirePO: boolean | null;
    notes: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type SupplierMaxAggregateOutputType = {
    id: string | null;
    supplierCode: string | null;
    companyId: string | null;
    name: string | null;
    tradeName: string | null;
    vatNumber: string | null;
    addressLine1: string | null;
    addressLine2: string | null;
    city: string | null;
    state: string | null;
    postalCode: string | null;
    country: string | null;
    email: string | null;
    phone: string | null;
    fax: string | null;
    contactPerson: string | null;
    contactMobile: string | null;
    irpfRate: Decimal | null;
    vatRate: Decimal | null;
    paymentTerms: number | null;
    paymentMethod: string | null;
    bankName: string | null;
    bankAccount: string | null;
    swiftCode: string | null;
    iban: string | null;
    currency: string | null;
    autoApprove: boolean | null;
    requirePO: boolean | null;
    notes: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type SupplierCountAggregateOutputType = {
    id: number;
    supplierCode: number;
    companyId: number;
    name: number;
    tradeName: number;
    vatNumber: number;
    addressLine1: number;
    addressLine2: number;
    city: number;
    state: number;
    postalCode: number;
    country: number;
    email: number;
    phone: number;
    fax: number;
    contactPerson: number;
    contactMobile: number;
    irpfRate: number;
    vatRate: number;
    paymentTerms: number;
    paymentMethod: number;
    bankName: number;
    bankAccount: number;
    swiftCode: number;
    iban: number;
    currency: number;
    autoApprove: number;
    requirePO: number;
    notes: number;
    tags: number;
    metadata: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type SupplierAvgAggregateInputType = {
    irpfRate?: true;
    vatRate?: true;
    paymentTerms?: true;
  };

  export type SupplierSumAggregateInputType = {
    irpfRate?: true;
    vatRate?: true;
    paymentTerms?: true;
  };

  export type SupplierMinAggregateInputType = {
    id?: true;
    supplierCode?: true;
    companyId?: true;
    name?: true;
    tradeName?: true;
    vatNumber?: true;
    addressLine1?: true;
    addressLine2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    email?: true;
    phone?: true;
    fax?: true;
    contactPerson?: true;
    contactMobile?: true;
    irpfRate?: true;
    vatRate?: true;
    paymentTerms?: true;
    paymentMethod?: true;
    bankName?: true;
    bankAccount?: true;
    swiftCode?: true;
    iban?: true;
    currency?: true;
    autoApprove?: true;
    requirePO?: true;
    notes?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type SupplierMaxAggregateInputType = {
    id?: true;
    supplierCode?: true;
    companyId?: true;
    name?: true;
    tradeName?: true;
    vatNumber?: true;
    addressLine1?: true;
    addressLine2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    email?: true;
    phone?: true;
    fax?: true;
    contactPerson?: true;
    contactMobile?: true;
    irpfRate?: true;
    vatRate?: true;
    paymentTerms?: true;
    paymentMethod?: true;
    bankName?: true;
    bankAccount?: true;
    swiftCode?: true;
    iban?: true;
    currency?: true;
    autoApprove?: true;
    requirePO?: true;
    notes?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type SupplierCountAggregateInputType = {
    id?: true;
    supplierCode?: true;
    companyId?: true;
    name?: true;
    tradeName?: true;
    vatNumber?: true;
    addressLine1?: true;
    addressLine2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    email?: true;
    phone?: true;
    fax?: true;
    contactPerson?: true;
    contactMobile?: true;
    irpfRate?: true;
    vatRate?: true;
    paymentTerms?: true;
    paymentMethod?: true;
    bankName?: true;
    bankAccount?: true;
    swiftCode?: true;
    iban?: true;
    currency?: true;
    autoApprove?: true;
    requirePO?: true;
    notes?: true;
    tags?: true;
    metadata?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type SupplierAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Suppliers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Suppliers
     **/
    _count?: true | SupplierCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SupplierAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SupplierSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SupplierMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SupplierMaxAggregateInputType;
  };

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
    [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>;
  };

  export type SupplierGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[];
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum;
    having?: SupplierScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SupplierCountAggregateInputType | true;
    _avg?: SupplierAvgAggregateInputType;
    _sum?: SupplierSumAggregateInputType;
    _min?: SupplierMinAggregateInputType;
    _max?: SupplierMaxAggregateInputType;
  };

  export type SupplierGroupByOutputType = {
    id: string;
    supplierCode: string;
    companyId: string | null;
    name: string;
    tradeName: string | null;
    vatNumber: string | null;
    addressLine1: string;
    addressLine2: string | null;
    city: string;
    state: string | null;
    postalCode: string;
    country: string;
    email: string;
    phone: string | null;
    fax: string | null;
    contactPerson: string | null;
    contactMobile: string | null;
    irpfRate: Decimal | null;
    vatRate: Decimal;
    paymentTerms: number;
    paymentMethod: string | null;
    bankName: string | null;
    bankAccount: string | null;
    swiftCode: string | null;
    iban: string | null;
    currency: string;
    autoApprove: boolean;
    requirePO: boolean;
    notes: string | null;
    tags: string[];
    metadata: JsonValue | null;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: SupplierCountAggregateOutputType | null;
    _avg: SupplierAvgAggregateOutputType | null;
    _sum: SupplierSumAggregateOutputType | null;
    _min: SupplierMinAggregateOutputType | null;
    _max: SupplierMaxAggregateOutputType | null;
  };

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SupplierGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
          : GetScalarType<T[P], SupplierGroupByOutputType[P]>;
      }
    >
  >;

  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        supplierCode?: boolean;
        companyId?: boolean;
        name?: boolean;
        tradeName?: boolean;
        vatNumber?: boolean;
        addressLine1?: boolean;
        addressLine2?: boolean;
        city?: boolean;
        state?: boolean;
        postalCode?: boolean;
        country?: boolean;
        email?: boolean;
        phone?: boolean;
        fax?: boolean;
        contactPerson?: boolean;
        contactMobile?: boolean;
        irpfRate?: boolean;
        vatRate?: boolean;
        paymentTerms?: boolean;
        paymentMethod?: boolean;
        bankName?: boolean;
        bankAccount?: boolean;
        swiftCode?: boolean;
        iban?: boolean;
        currency?: boolean;
        autoApprove?: boolean;
        requirePO?: boolean;
        notes?: boolean;
        tags?: boolean;
        metadata?: boolean;
        isActive?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        company?: boolean | Supplier$companyArgs<ExtArgs>;
        services?: boolean | Supplier$servicesArgs<ExtArgs>;
        invoices?: boolean | Supplier$invoicesArgs<ExtArgs>;
        documents?: boolean | Supplier$documentsArgs<ExtArgs>;
        _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['supplier']
    >;

  export type SupplierSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      supplierCode?: boolean;
      companyId?: boolean;
      name?: boolean;
      tradeName?: boolean;
      vatNumber?: boolean;
      addressLine1?: boolean;
      addressLine2?: boolean;
      city?: boolean;
      state?: boolean;
      postalCode?: boolean;
      country?: boolean;
      email?: boolean;
      phone?: boolean;
      fax?: boolean;
      contactPerson?: boolean;
      contactMobile?: boolean;
      irpfRate?: boolean;
      vatRate?: boolean;
      paymentTerms?: boolean;
      paymentMethod?: boolean;
      bankName?: boolean;
      bankAccount?: boolean;
      swiftCode?: boolean;
      iban?: boolean;
      currency?: boolean;
      autoApprove?: boolean;
      requirePO?: boolean;
      notes?: boolean;
      tags?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      company?: boolean | Supplier$companyArgs<ExtArgs>;
    },
    ExtArgs['result']['supplier']
  >;

  export type SupplierSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      supplierCode?: boolean;
      companyId?: boolean;
      name?: boolean;
      tradeName?: boolean;
      vatNumber?: boolean;
      addressLine1?: boolean;
      addressLine2?: boolean;
      city?: boolean;
      state?: boolean;
      postalCode?: boolean;
      country?: boolean;
      email?: boolean;
      phone?: boolean;
      fax?: boolean;
      contactPerson?: boolean;
      contactMobile?: boolean;
      irpfRate?: boolean;
      vatRate?: boolean;
      paymentTerms?: boolean;
      paymentMethod?: boolean;
      bankName?: boolean;
      bankAccount?: boolean;
      swiftCode?: boolean;
      iban?: boolean;
      currency?: boolean;
      autoApprove?: boolean;
      requirePO?: boolean;
      notes?: boolean;
      tags?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      company?: boolean | Supplier$companyArgs<ExtArgs>;
    },
    ExtArgs['result']['supplier']
  >;

  export type SupplierSelectScalar = {
    id?: boolean;
    supplierCode?: boolean;
    companyId?: boolean;
    name?: boolean;
    tradeName?: boolean;
    vatNumber?: boolean;
    addressLine1?: boolean;
    addressLine2?: boolean;
    city?: boolean;
    state?: boolean;
    postalCode?: boolean;
    country?: boolean;
    email?: boolean;
    phone?: boolean;
    fax?: boolean;
    contactPerson?: boolean;
    contactMobile?: boolean;
    irpfRate?: boolean;
    vatRate?: boolean;
    paymentTerms?: boolean;
    paymentMethod?: boolean;
    bankName?: boolean;
    bankAccount?: boolean;
    swiftCode?: boolean;
    iban?: boolean;
    currency?: boolean;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: boolean;
    tags?: boolean;
    metadata?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'supplierCode'
      | 'companyId'
      | 'name'
      | 'tradeName'
      | 'vatNumber'
      | 'addressLine1'
      | 'addressLine2'
      | 'city'
      | 'state'
      | 'postalCode'
      | 'country'
      | 'email'
      | 'phone'
      | 'fax'
      | 'contactPerson'
      | 'contactMobile'
      | 'irpfRate'
      | 'vatRate'
      | 'paymentTerms'
      | 'paymentMethod'
      | 'bankName'
      | 'bankAccount'
      | 'swiftCode'
      | 'iban'
      | 'currency'
      | 'autoApprove'
      | 'requirePO'
      | 'notes'
      | 'tags'
      | 'metadata'
      | 'isActive'
      | 'createdAt'
      | 'updatedAt'
      | 'deletedAt',
      ExtArgs['result']['supplier']
    >;
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      company?: boolean | Supplier$companyArgs<ExtArgs>;
      services?: boolean | Supplier$servicesArgs<ExtArgs>;
      invoices?: boolean | Supplier$invoicesArgs<ExtArgs>;
      documents?: boolean | Supplier$documentsArgs<ExtArgs>;
      _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type SupplierIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    company?: boolean | Supplier$companyArgs<ExtArgs>;
  };
  export type SupplierIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    company?: boolean | Supplier$companyArgs<ExtArgs>;
  };

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Supplier';
      objects: {
        company: Prisma.$CompanyPayload<ExtArgs> | null;
        services: Prisma.$ServicePayload<ExtArgs>[];
        invoices: Prisma.$InvoicePayload<ExtArgs>[];
        documents: Prisma.$DocumentPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          supplierCode: string;
          companyId: string | null;
          name: string;
          tradeName: string | null;
          vatNumber: string | null;
          addressLine1: string;
          addressLine2: string | null;
          city: string;
          state: string | null;
          postalCode: string;
          country: string;
          email: string;
          phone: string | null;
          fax: string | null;
          contactPerson: string | null;
          contactMobile: string | null;
          irpfRate: Prisma.Decimal | null;
          vatRate: Prisma.Decimal;
          paymentTerms: number;
          paymentMethod: string | null;
          bankName: string | null;
          bankAccount: string | null;
          swiftCode: string | null;
          iban: string | null;
          currency: string;
          autoApprove: boolean;
          requirePO: boolean;
          notes: string | null;
          tags: string[];
          metadata: Prisma.JsonValue | null;
          isActive: boolean;
          createdAt: Date;
          updatedAt: Date;
          deletedAt: Date | null;
        },
        ExtArgs['result']['supplier']
      >;
      composites: {};
    };

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> =
    $Result.GetResult<Prisma.$SupplierPayload, S>;

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    SupplierFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SupplierCountAggregateInputType | true;
  };

  export interface SupplierDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Supplier'];
      meta: { name: 'Supplier' };
    };
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(
      args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(
      args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     *
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SupplierFindManyArgs>(
      args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     *
     */
    create<T extends SupplierCreateArgs>(
      args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SupplierCreateManyArgs>(
      args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     *
     */
    delete<T extends SupplierDeleteArgs>(
      args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SupplierUpdateArgs>(
      args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SupplierDeleteManyArgs>(
      args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SupplierUpdateManyArgs>(
      args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(
      args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
     **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SupplierAggregateArgs>(
      args: Subset<T, SupplierAggregateArgs>
    ): Prisma.PrismaPromise<GetSupplierAggregateType<T>>;

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Supplier model
     */
    readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    company<T extends Supplier$companyArgs<ExtArgs> = {}>(
      args?: Subset<T, Supplier$companyArgs<ExtArgs>>
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    services<T extends Supplier$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Supplier$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    invoices<T extends Supplier$invoicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Supplier$invoicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    documents<T extends Supplier$documentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Supplier$documentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<'Supplier', 'String'>;
    readonly supplierCode: FieldRef<'Supplier', 'String'>;
    readonly companyId: FieldRef<'Supplier', 'String'>;
    readonly name: FieldRef<'Supplier', 'String'>;
    readonly tradeName: FieldRef<'Supplier', 'String'>;
    readonly vatNumber: FieldRef<'Supplier', 'String'>;
    readonly addressLine1: FieldRef<'Supplier', 'String'>;
    readonly addressLine2: FieldRef<'Supplier', 'String'>;
    readonly city: FieldRef<'Supplier', 'String'>;
    readonly state: FieldRef<'Supplier', 'String'>;
    readonly postalCode: FieldRef<'Supplier', 'String'>;
    readonly country: FieldRef<'Supplier', 'String'>;
    readonly email: FieldRef<'Supplier', 'String'>;
    readonly phone: FieldRef<'Supplier', 'String'>;
    readonly fax: FieldRef<'Supplier', 'String'>;
    readonly contactPerson: FieldRef<'Supplier', 'String'>;
    readonly contactMobile: FieldRef<'Supplier', 'String'>;
    readonly irpfRate: FieldRef<'Supplier', 'Decimal'>;
    readonly vatRate: FieldRef<'Supplier', 'Decimal'>;
    readonly paymentTerms: FieldRef<'Supplier', 'Int'>;
    readonly paymentMethod: FieldRef<'Supplier', 'String'>;
    readonly bankName: FieldRef<'Supplier', 'String'>;
    readonly bankAccount: FieldRef<'Supplier', 'String'>;
    readonly swiftCode: FieldRef<'Supplier', 'String'>;
    readonly iban: FieldRef<'Supplier', 'String'>;
    readonly currency: FieldRef<'Supplier', 'String'>;
    readonly autoApprove: FieldRef<'Supplier', 'Boolean'>;
    readonly requirePO: FieldRef<'Supplier', 'Boolean'>;
    readonly notes: FieldRef<'Supplier', 'String'>;
    readonly tags: FieldRef<'Supplier', 'String[]'>;
    readonly metadata: FieldRef<'Supplier', 'Json'>;
    readonly isActive: FieldRef<'Supplier', 'Boolean'>;
    readonly createdAt: FieldRef<'Supplier', 'DateTime'>;
    readonly updatedAt: FieldRef<'Supplier', 'DateTime'>;
    readonly deletedAt: FieldRef<'Supplier', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput;
  };

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput;
  };

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Suppliers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[];
  };

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Suppliers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[];
  };

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Suppliers.
     */
    skip?: number;
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[];
  };

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>;
  };

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>;
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput;
  };

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>;
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput;
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number;
  };

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>;
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput;
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput;
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>;
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>;
  };

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput;
  };

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput;
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number;
  };

  /**
   * Supplier.company
   */
  export type Supplier$companyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    where?: CompanyWhereInput;
  };

  /**
   * Supplier.services
   */
  export type Supplier$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Supplier.invoices
   */
  export type Supplier$invoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    cursor?: InvoiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * Supplier.documents
   */
  export type Supplier$documentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    cursor?: DocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
  };

  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null;
    _avg: ServiceAvgAggregateOutputType | null;
    _sum: ServiceSumAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  export type ServiceAvgAggregateOutputType = {
    distance: number | null;
    costAmount: Decimal | null;
    saleAmount: Decimal | null;
    margin: Decimal | null;
    marginPercentage: Decimal | null;
    costVatRate: Decimal | null;
    costVatAmount: Decimal | null;
    saleVatRate: Decimal | null;
    saleVatAmount: Decimal | null;
  };

  export type ServiceSumAggregateOutputType = {
    distance: number | null;
    costAmount: Decimal | null;
    saleAmount: Decimal | null;
    margin: Decimal | null;
    marginPercentage: Decimal | null;
    costVatRate: Decimal | null;
    costVatAmount: Decimal | null;
    saleVatRate: Decimal | null;
    saleVatAmount: Decimal | null;
  };

  export type ServiceMinAggregateOutputType = {
    id: string | null;
    serviceNumber: string | null;
    date: Date | null;
    clientId: string | null;
    supplierId: string | null;
    createdById: string | null;
    assignedToId: string | null;
    description: string | null;
    reference: string | null;
    origin: string | null;
    destination: string | null;
    distance: number | null;
    vehicleType: string | null;
    vehiclePlate: string | null;
    driverName: string | null;
    costAmount: Decimal | null;
    costCurrency: string | null;
    saleAmount: Decimal | null;
    saleCurrency: string | null;
    margin: Decimal | null;
    marginPercentage: Decimal | null;
    costVatRate: Decimal | null;
    costVatAmount: Decimal | null;
    saleVatRate: Decimal | null;
    saleVatAmount: Decimal | null;
    status: $Enums.ServiceStatus | null;
    completedAt: Date | null;
    cancelledAt: Date | null;
    cancellationReason: string | null;
    archivedAt: Date | null;
    notes: string | null;
    internalNotes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type ServiceMaxAggregateOutputType = {
    id: string | null;
    serviceNumber: string | null;
    date: Date | null;
    clientId: string | null;
    supplierId: string | null;
    createdById: string | null;
    assignedToId: string | null;
    description: string | null;
    reference: string | null;
    origin: string | null;
    destination: string | null;
    distance: number | null;
    vehicleType: string | null;
    vehiclePlate: string | null;
    driverName: string | null;
    costAmount: Decimal | null;
    costCurrency: string | null;
    saleAmount: Decimal | null;
    saleCurrency: string | null;
    margin: Decimal | null;
    marginPercentage: Decimal | null;
    costVatRate: Decimal | null;
    costVatAmount: Decimal | null;
    saleVatRate: Decimal | null;
    saleVatAmount: Decimal | null;
    status: $Enums.ServiceStatus | null;
    completedAt: Date | null;
    cancelledAt: Date | null;
    cancellationReason: string | null;
    archivedAt: Date | null;
    notes: string | null;
    internalNotes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type ServiceCountAggregateOutputType = {
    id: number;
    serviceNumber: number;
    date: number;
    clientId: number;
    supplierId: number;
    createdById: number;
    assignedToId: number;
    description: number;
    reference: number;
    origin: number;
    destination: number;
    distance: number;
    vehicleType: number;
    vehiclePlate: number;
    driverName: number;
    costAmount: number;
    costCurrency: number;
    saleAmount: number;
    saleCurrency: number;
    margin: number;
    marginPercentage: number;
    costVatRate: number;
    costVatAmount: number;
    saleVatRate: number;
    saleVatAmount: number;
    status: number;
    completedAt: number;
    cancelledAt: number;
    cancellationReason: number;
    archivedAt: number;
    notes: number;
    internalNotes: number;
    attachments: number;
    customFields: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type ServiceAvgAggregateInputType = {
    distance?: true;
    costAmount?: true;
    saleAmount?: true;
    margin?: true;
    marginPercentage?: true;
    costVatRate?: true;
    costVatAmount?: true;
    saleVatRate?: true;
    saleVatAmount?: true;
  };

  export type ServiceSumAggregateInputType = {
    distance?: true;
    costAmount?: true;
    saleAmount?: true;
    margin?: true;
    marginPercentage?: true;
    costVatRate?: true;
    costVatAmount?: true;
    saleVatRate?: true;
    saleVatAmount?: true;
  };

  export type ServiceMinAggregateInputType = {
    id?: true;
    serviceNumber?: true;
    date?: true;
    clientId?: true;
    supplierId?: true;
    createdById?: true;
    assignedToId?: true;
    description?: true;
    reference?: true;
    origin?: true;
    destination?: true;
    distance?: true;
    vehicleType?: true;
    vehiclePlate?: true;
    driverName?: true;
    costAmount?: true;
    costCurrency?: true;
    saleAmount?: true;
    saleCurrency?: true;
    margin?: true;
    marginPercentage?: true;
    costVatRate?: true;
    costVatAmount?: true;
    saleVatRate?: true;
    saleVatAmount?: true;
    status?: true;
    completedAt?: true;
    cancelledAt?: true;
    cancellationReason?: true;
    archivedAt?: true;
    notes?: true;
    internalNotes?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type ServiceMaxAggregateInputType = {
    id?: true;
    serviceNumber?: true;
    date?: true;
    clientId?: true;
    supplierId?: true;
    createdById?: true;
    assignedToId?: true;
    description?: true;
    reference?: true;
    origin?: true;
    destination?: true;
    distance?: true;
    vehicleType?: true;
    vehiclePlate?: true;
    driverName?: true;
    costAmount?: true;
    costCurrency?: true;
    saleAmount?: true;
    saleCurrency?: true;
    margin?: true;
    marginPercentage?: true;
    costVatRate?: true;
    costVatAmount?: true;
    saleVatRate?: true;
    saleVatAmount?: true;
    status?: true;
    completedAt?: true;
    cancelledAt?: true;
    cancellationReason?: true;
    archivedAt?: true;
    notes?: true;
    internalNotes?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type ServiceCountAggregateInputType = {
    id?: true;
    serviceNumber?: true;
    date?: true;
    clientId?: true;
    supplierId?: true;
    createdById?: true;
    assignedToId?: true;
    description?: true;
    reference?: true;
    origin?: true;
    destination?: true;
    distance?: true;
    vehicleType?: true;
    vehiclePlate?: true;
    driverName?: true;
    costAmount?: true;
    costCurrency?: true;
    saleAmount?: true;
    saleCurrency?: true;
    margin?: true;
    marginPercentage?: true;
    costVatRate?: true;
    costVatAmount?: true;
    saleVatRate?: true;
    saleVatAmount?: true;
    status?: true;
    completedAt?: true;
    cancelledAt?: true;
    cancellationReason?: true;
    archivedAt?: true;
    notes?: true;
    internalNotes?: true;
    attachments?: true;
    customFields?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type ServiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Services
     **/
    _count?: true | ServiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceMaxAggregateInputType;
  };

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
    [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>;
  };

  export type ServiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[];
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum;
    having?: ServiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceCountAggregateInputType | true;
    _avg?: ServiceAvgAggregateInputType;
    _sum?: ServiceSumAggregateInputType;
    _min?: ServiceMinAggregateInputType;
    _max?: ServiceMaxAggregateInputType;
  };

  export type ServiceGroupByOutputType = {
    id: string;
    serviceNumber: string;
    date: Date;
    clientId: string;
    supplierId: string;
    createdById: string;
    assignedToId: string | null;
    description: string;
    reference: string | null;
    origin: string;
    destination: string;
    distance: number | null;
    vehicleType: string | null;
    vehiclePlate: string | null;
    driverName: string | null;
    costAmount: Decimal;
    costCurrency: string;
    saleAmount: Decimal;
    saleCurrency: string;
    margin: Decimal;
    marginPercentage: Decimal;
    costVatRate: Decimal;
    costVatAmount: Decimal;
    saleVatRate: Decimal;
    saleVatAmount: Decimal;
    status: $Enums.ServiceStatus;
    completedAt: Date | null;
    cancelledAt: Date | null;
    cancellationReason: string | null;
    archivedAt: Date | null;
    notes: string | null;
    internalNotes: string | null;
    attachments: string[];
    customFields: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: ServiceCountAggregateOutputType | null;
    _avg: ServiceAvgAggregateOutputType | null;
    _sum: ServiceSumAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ServiceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
          : GetScalarType<T[P], ServiceGroupByOutputType[P]>;
      }
    >
  >;

  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        serviceNumber?: boolean;
        date?: boolean;
        clientId?: boolean;
        supplierId?: boolean;
        createdById?: boolean;
        assignedToId?: boolean;
        description?: boolean;
        reference?: boolean;
        origin?: boolean;
        destination?: boolean;
        distance?: boolean;
        vehicleType?: boolean;
        vehiclePlate?: boolean;
        driverName?: boolean;
        costAmount?: boolean;
        costCurrency?: boolean;
        saleAmount?: boolean;
        saleCurrency?: boolean;
        margin?: boolean;
        marginPercentage?: boolean;
        costVatRate?: boolean;
        costVatAmount?: boolean;
        saleVatRate?: boolean;
        saleVatAmount?: boolean;
        status?: boolean;
        completedAt?: boolean;
        cancelledAt?: boolean;
        cancellationReason?: boolean;
        archivedAt?: boolean;
        notes?: boolean;
        internalNotes?: boolean;
        attachments?: boolean;
        customFields?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        client?: boolean | ClientDefaultArgs<ExtArgs>;
        supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
        assignedTo?: boolean | Service$assignedToArgs<ExtArgs>;
        loadingOrders?: boolean | Service$loadingOrdersArgs<ExtArgs>;
        invoiceItems?: boolean | Service$invoiceItemsArgs<ExtArgs>;
        documents?: boolean | Service$documentsArgs<ExtArgs>;
        statusHistory?: boolean | Service$statusHistoryArgs<ExtArgs>;
        _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['service']
    >;

  export type ServiceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceNumber?: boolean;
      date?: boolean;
      clientId?: boolean;
      supplierId?: boolean;
      createdById?: boolean;
      assignedToId?: boolean;
      description?: boolean;
      reference?: boolean;
      origin?: boolean;
      destination?: boolean;
      distance?: boolean;
      vehicleType?: boolean;
      vehiclePlate?: boolean;
      driverName?: boolean;
      costAmount?: boolean;
      costCurrency?: boolean;
      saleAmount?: boolean;
      saleCurrency?: boolean;
      margin?: boolean;
      marginPercentage?: boolean;
      costVatRate?: boolean;
      costVatAmount?: boolean;
      saleVatRate?: boolean;
      saleVatAmount?: boolean;
      status?: boolean;
      completedAt?: boolean;
      cancelledAt?: boolean;
      cancellationReason?: boolean;
      archivedAt?: boolean;
      notes?: boolean;
      internalNotes?: boolean;
      attachments?: boolean;
      customFields?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      client?: boolean | ClientDefaultArgs<ExtArgs>;
      supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      assignedTo?: boolean | Service$assignedToArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceNumber?: boolean;
      date?: boolean;
      clientId?: boolean;
      supplierId?: boolean;
      createdById?: boolean;
      assignedToId?: boolean;
      description?: boolean;
      reference?: boolean;
      origin?: boolean;
      destination?: boolean;
      distance?: boolean;
      vehicleType?: boolean;
      vehiclePlate?: boolean;
      driverName?: boolean;
      costAmount?: boolean;
      costCurrency?: boolean;
      saleAmount?: boolean;
      saleCurrency?: boolean;
      margin?: boolean;
      marginPercentage?: boolean;
      costVatRate?: boolean;
      costVatAmount?: boolean;
      saleVatRate?: boolean;
      saleVatAmount?: boolean;
      status?: boolean;
      completedAt?: boolean;
      cancelledAt?: boolean;
      cancellationReason?: boolean;
      archivedAt?: boolean;
      notes?: boolean;
      internalNotes?: boolean;
      attachments?: boolean;
      customFields?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      client?: boolean | ClientDefaultArgs<ExtArgs>;
      supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      assignedTo?: boolean | Service$assignedToArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectScalar = {
    id?: boolean;
    serviceNumber?: boolean;
    date?: boolean;
    clientId?: boolean;
    supplierId?: boolean;
    createdById?: boolean;
    assignedToId?: boolean;
    description?: boolean;
    reference?: boolean;
    origin?: boolean;
    destination?: boolean;
    distance?: boolean;
    vehicleType?: boolean;
    vehiclePlate?: boolean;
    driverName?: boolean;
    costAmount?: boolean;
    costCurrency?: boolean;
    saleAmount?: boolean;
    saleCurrency?: boolean;
    margin?: boolean;
    marginPercentage?: boolean;
    costVatRate?: boolean;
    costVatAmount?: boolean;
    saleVatRate?: boolean;
    saleVatAmount?: boolean;
    status?: boolean;
    completedAt?: boolean;
    cancelledAt?: boolean;
    cancellationReason?: boolean;
    archivedAt?: boolean;
    notes?: boolean;
    internalNotes?: boolean;
    attachments?: boolean;
    customFields?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'serviceNumber'
      | 'date'
      | 'clientId'
      | 'supplierId'
      | 'createdById'
      | 'assignedToId'
      | 'description'
      | 'reference'
      | 'origin'
      | 'destination'
      | 'distance'
      | 'vehicleType'
      | 'vehiclePlate'
      | 'driverName'
      | 'costAmount'
      | 'costCurrency'
      | 'saleAmount'
      | 'saleCurrency'
      | 'margin'
      | 'marginPercentage'
      | 'costVatRate'
      | 'costVatAmount'
      | 'saleVatRate'
      | 'saleVatAmount'
      | 'status'
      | 'completedAt'
      | 'cancelledAt'
      | 'cancellationReason'
      | 'archivedAt'
      | 'notes'
      | 'internalNotes'
      | 'attachments'
      | 'customFields'
      | 'createdAt'
      | 'updatedAt'
      | 'deletedAt',
      ExtArgs['result']['service']
    >;
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>;
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    assignedTo?: boolean | Service$assignedToArgs<ExtArgs>;
    loadingOrders?: boolean | Service$loadingOrdersArgs<ExtArgs>;
    invoiceItems?: boolean | Service$invoiceItemsArgs<ExtArgs>;
    documents?: boolean | Service$documentsArgs<ExtArgs>;
    statusHistory?: boolean | Service$statusHistoryArgs<ExtArgs>;
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ServiceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    client?: boolean | ClientDefaultArgs<ExtArgs>;
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    assignedTo?: boolean | Service$assignedToArgs<ExtArgs>;
  };
  export type ServiceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    client?: boolean | ClientDefaultArgs<ExtArgs>;
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    assignedTo?: boolean | Service$assignedToArgs<ExtArgs>;
  };

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Service';
      objects: {
        client: Prisma.$ClientPayload<ExtArgs>;
        supplier: Prisma.$SupplierPayload<ExtArgs>;
        createdBy: Prisma.$UserPayload<ExtArgs>;
        assignedTo: Prisma.$UserPayload<ExtArgs> | null;
        loadingOrders: Prisma.$ServiceLoadingOrderPayload<ExtArgs>[];
        invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[];
        documents: Prisma.$DocumentPayload<ExtArgs>[];
        statusHistory: Prisma.$ServiceStatusHistoryPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          serviceNumber: string;
          date: Date;
          clientId: string;
          supplierId: string;
          createdById: string;
          assignedToId: string | null;
          description: string;
          reference: string | null;
          origin: string;
          destination: string;
          distance: number | null;
          vehicleType: string | null;
          vehiclePlate: string | null;
          driverName: string | null;
          costAmount: Prisma.Decimal;
          costCurrency: string;
          saleAmount: Prisma.Decimal;
          saleCurrency: string;
          margin: Prisma.Decimal;
          marginPercentage: Prisma.Decimal;
          costVatRate: Prisma.Decimal;
          costVatAmount: Prisma.Decimal;
          saleVatRate: Prisma.Decimal;
          saleVatAmount: Prisma.Decimal;
          status: $Enums.ServiceStatus;
          completedAt: Date | null;
          cancelledAt: Date | null;
          cancellationReason: string | null;
          archivedAt: Date | null;
          notes: string | null;
          internalNotes: string | null;
          attachments: string[];
          customFields: Prisma.JsonValue | null;
          createdAt: Date;
          updatedAt: Date;
          deletedAt: Date | null;
        },
        ExtArgs['result']['service']
      >;
      composites: {};
    };

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> =
    $Result.GetResult<Prisma.$ServicePayload, S>;

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ServiceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ServiceCountAggregateInputType | true;
  };

  export interface ServiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service']; meta: { name: 'Service' } };
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     *
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceFindManyArgs>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     *
     */
    create<T extends ServiceCreateArgs>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceCreateManyArgs>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     *
     */
    delete<T extends ServiceDeleteArgs>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceUpdateArgs>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceDeleteManyArgs>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceUpdateManyArgs>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
     **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceAggregateArgs>(
      args: Subset<T, ServiceAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceAggregateType<T>>;

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Service model
     */
    readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClientDefaultArgs<ExtArgs>>
    ): Prisma__ClientClient<
      | $Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SupplierDefaultArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      | $Result.GetResult<
          Prisma.$SupplierPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    assignedTo<T extends Service$assignedToArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$assignedToArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    loadingOrders<T extends Service$loadingOrdersArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$loadingOrdersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    invoiceItems<T extends Service$invoiceItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$invoiceItemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    documents<T extends Service$documentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$documentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    statusHistory<T extends Service$statusHistoryArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$statusHistoryArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<'Service', 'String'>;
    readonly serviceNumber: FieldRef<'Service', 'String'>;
    readonly date: FieldRef<'Service', 'DateTime'>;
    readonly clientId: FieldRef<'Service', 'String'>;
    readonly supplierId: FieldRef<'Service', 'String'>;
    readonly createdById: FieldRef<'Service', 'String'>;
    readonly assignedToId: FieldRef<'Service', 'String'>;
    readonly description: FieldRef<'Service', 'String'>;
    readonly reference: FieldRef<'Service', 'String'>;
    readonly origin: FieldRef<'Service', 'String'>;
    readonly destination: FieldRef<'Service', 'String'>;
    readonly distance: FieldRef<'Service', 'Int'>;
    readonly vehicleType: FieldRef<'Service', 'String'>;
    readonly vehiclePlate: FieldRef<'Service', 'String'>;
    readonly driverName: FieldRef<'Service', 'String'>;
    readonly costAmount: FieldRef<'Service', 'Decimal'>;
    readonly costCurrency: FieldRef<'Service', 'String'>;
    readonly saleAmount: FieldRef<'Service', 'Decimal'>;
    readonly saleCurrency: FieldRef<'Service', 'String'>;
    readonly margin: FieldRef<'Service', 'Decimal'>;
    readonly marginPercentage: FieldRef<'Service', 'Decimal'>;
    readonly costVatRate: FieldRef<'Service', 'Decimal'>;
    readonly costVatAmount: FieldRef<'Service', 'Decimal'>;
    readonly saleVatRate: FieldRef<'Service', 'Decimal'>;
    readonly saleVatAmount: FieldRef<'Service', 'Decimal'>;
    readonly status: FieldRef<'Service', 'ServiceStatus'>;
    readonly completedAt: FieldRef<'Service', 'DateTime'>;
    readonly cancelledAt: FieldRef<'Service', 'DateTime'>;
    readonly cancellationReason: FieldRef<'Service', 'String'>;
    readonly archivedAt: FieldRef<'Service', 'DateTime'>;
    readonly notes: FieldRef<'Service', 'String'>;
    readonly internalNotes: FieldRef<'Service', 'String'>;
    readonly attachments: FieldRef<'Service', 'String[]'>;
    readonly customFields: FieldRef<'Service', 'Json'>;
    readonly createdAt: FieldRef<'Service', 'DateTime'>;
    readonly updatedAt: FieldRef<'Service', 'DateTime'>;
    readonly deletedAt: FieldRef<'Service', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service create
   */
  export type ServiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
  };

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service update
   */
  export type ServiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to update.
     */
    limit?: number;
  };

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput;
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
  };

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to delete.
     */
    limit?: number;
  };

  /**
   * Service.assignedTo
   */
  export type Service$assignedToArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Service.loadingOrders
   */
  export type Service$loadingOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    where?: ServiceLoadingOrderWhereInput;
    orderBy?:
      | ServiceLoadingOrderOrderByWithRelationInput
      | ServiceLoadingOrderOrderByWithRelationInput[];
    cursor?: ServiceLoadingOrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceLoadingOrderScalarFieldEnum | ServiceLoadingOrderScalarFieldEnum[];
  };

  /**
   * Service.invoiceItems
   */
  export type Service$invoiceItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    where?: InvoiceItemWhereInput;
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[];
    cursor?: InvoiceItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[];
  };

  /**
   * Service.documents
   */
  export type Service$documentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    cursor?: DocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Service.statusHistory
   */
  export type Service$statusHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    where?: ServiceStatusHistoryWhereInput;
    orderBy?:
      | ServiceStatusHistoryOrderByWithRelationInput
      | ServiceStatusHistoryOrderByWithRelationInput[];
    cursor?: ServiceStatusHistoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceStatusHistoryScalarFieldEnum | ServiceStatusHistoryScalarFieldEnum[];
  };

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
  };

  /**
   * Model ServiceStatusHistory
   */

  export type AggregateServiceStatusHistory = {
    _count: ServiceStatusHistoryCountAggregateOutputType | null;
    _min: ServiceStatusHistoryMinAggregateOutputType | null;
    _max: ServiceStatusHistoryMaxAggregateOutputType | null;
  };

  export type ServiceStatusHistoryMinAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    fromStatus: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus | null;
    reason: string | null;
    changedBy: string | null;
    changedAt: Date | null;
  };

  export type ServiceStatusHistoryMaxAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    fromStatus: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus | null;
    reason: string | null;
    changedBy: string | null;
    changedAt: Date | null;
  };

  export type ServiceStatusHistoryCountAggregateOutputType = {
    id: number;
    serviceId: number;
    fromStatus: number;
    toStatus: number;
    reason: number;
    changedBy: number;
    changedAt: number;
    _all: number;
  };

  export type ServiceStatusHistoryMinAggregateInputType = {
    id?: true;
    serviceId?: true;
    fromStatus?: true;
    toStatus?: true;
    reason?: true;
    changedBy?: true;
    changedAt?: true;
  };

  export type ServiceStatusHistoryMaxAggregateInputType = {
    id?: true;
    serviceId?: true;
    fromStatus?: true;
    toStatus?: true;
    reason?: true;
    changedBy?: true;
    changedAt?: true;
  };

  export type ServiceStatusHistoryCountAggregateInputType = {
    id?: true;
    serviceId?: true;
    fromStatus?: true;
    toStatus?: true;
    reason?: true;
    changedBy?: true;
    changedAt?: true;
    _all?: true;
  };

  export type ServiceStatusHistoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceStatusHistory to aggregate.
     */
    where?: ServiceStatusHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceStatusHistories to fetch.
     */
    orderBy?:
      | ServiceStatusHistoryOrderByWithRelationInput
      | ServiceStatusHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceStatusHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceStatusHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceStatusHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ServiceStatusHistories
     **/
    _count?: true | ServiceStatusHistoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceStatusHistoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceStatusHistoryMaxAggregateInputType;
  };

  export type GetServiceStatusHistoryAggregateType<T extends ServiceStatusHistoryAggregateArgs> = {
    [P in keyof T & keyof AggregateServiceStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceStatusHistory[P]>
      : GetScalarType<T[P], AggregateServiceStatusHistory[P]>;
  };

  export type ServiceStatusHistoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceStatusHistoryWhereInput;
    orderBy?:
      | ServiceStatusHistoryOrderByWithAggregationInput
      | ServiceStatusHistoryOrderByWithAggregationInput[];
    by: ServiceStatusHistoryScalarFieldEnum[] | ServiceStatusHistoryScalarFieldEnum;
    having?: ServiceStatusHistoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceStatusHistoryCountAggregateInputType | true;
    _min?: ServiceStatusHistoryMinAggregateInputType;
    _max?: ServiceStatusHistoryMaxAggregateInputType;
  };

  export type ServiceStatusHistoryGroupByOutputType = {
    id: string;
    serviceId: string;
    fromStatus: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus;
    reason: string | null;
    changedBy: string;
    changedAt: Date;
    _count: ServiceStatusHistoryCountAggregateOutputType | null;
    _min: ServiceStatusHistoryMinAggregateOutputType | null;
    _max: ServiceStatusHistoryMaxAggregateOutputType | null;
  };

  type GetServiceStatusHistoryGroupByPayload<T extends ServiceStatusHistoryGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ServiceStatusHistoryGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ServiceStatusHistoryGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceStatusHistoryGroupByOutputType[P]>;
        }
      >
    >;

  export type ServiceStatusHistorySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      fromStatus?: boolean;
      toStatus?: boolean;
      reason?: boolean;
      changedBy?: boolean;
      changedAt?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceStatusHistory']
  >;

  export type ServiceStatusHistorySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      fromStatus?: boolean;
      toStatus?: boolean;
      reason?: boolean;
      changedBy?: boolean;
      changedAt?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceStatusHistory']
  >;

  export type ServiceStatusHistorySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      fromStatus?: boolean;
      toStatus?: boolean;
      reason?: boolean;
      changedBy?: boolean;
      changedAt?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceStatusHistory']
  >;

  export type ServiceStatusHistorySelectScalar = {
    id?: boolean;
    serviceId?: boolean;
    fromStatus?: boolean;
    toStatus?: boolean;
    reason?: boolean;
    changedBy?: boolean;
    changedAt?: boolean;
  };

  export type ServiceStatusHistoryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'serviceId' | 'fromStatus' | 'toStatus' | 'reason' | 'changedBy' | 'changedAt',
    ExtArgs['result']['serviceStatusHistory']
  >;
  export type ServiceStatusHistoryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type ServiceStatusHistoryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type ServiceStatusHistoryIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $ServiceStatusHistoryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ServiceStatusHistory';
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        serviceId: string;
        fromStatus: $Enums.ServiceStatus | null;
        toStatus: $Enums.ServiceStatus;
        reason: string | null;
        changedBy: string;
        changedAt: Date;
      },
      ExtArgs['result']['serviceStatusHistory']
    >;
    composites: {};
  };

  type ServiceStatusHistoryGetPayload<
    S extends boolean | null | undefined | ServiceStatusHistoryDefaultArgs,
  > = $Result.GetResult<Prisma.$ServiceStatusHistoryPayload, S>;

  type ServiceStatusHistoryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ServiceStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ServiceStatusHistoryCountAggregateInputType | true;
  };

  export interface ServiceStatusHistoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ServiceStatusHistory'];
      meta: { name: 'ServiceStatusHistory' };
    };
    /**
     * Find zero or one ServiceStatusHistory that matches the filter.
     * @param {ServiceStatusHistoryFindUniqueArgs} args - Arguments to find a ServiceStatusHistory
     * @example
     * // Get one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceStatusHistoryFindUniqueArgs>(
      args: SelectSubset<T, ServiceStatusHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceStatusHistoryClient<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ServiceStatusHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceStatusHistory
     * @example
     * // Get one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceStatusHistoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceStatusHistoryClient<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ServiceStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryFindFirstArgs} args - Arguments to find a ServiceStatusHistory
     * @example
     * // Get one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceStatusHistoryFindFirstArgs>(
      args?: SelectSubset<T, ServiceStatusHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceStatusHistoryClient<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ServiceStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a ServiceStatusHistory
     * @example
     * // Get one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceStatusHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceStatusHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceStatusHistoryClient<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ServiceStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceStatusHistories
     * const serviceStatusHistories = await prisma.serviceStatusHistory.findMany()
     *
     * // Get first 10 ServiceStatusHistories
     * const serviceStatusHistories = await prisma.serviceStatusHistory.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceStatusHistoryWithIdOnly = await prisma.serviceStatusHistory.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceStatusHistoryFindManyArgs>(
      args?: SelectSubset<T, ServiceStatusHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ServiceStatusHistory.
     * @param {ServiceStatusHistoryCreateArgs} args - Arguments to create a ServiceStatusHistory.
     * @example
     * // Create one ServiceStatusHistory
     * const ServiceStatusHistory = await prisma.serviceStatusHistory.create({
     *   data: {
     *     // ... data to create a ServiceStatusHistory
     *   }
     * })
     *
     */
    create<T extends ServiceStatusHistoryCreateArgs>(
      args: SelectSubset<T, ServiceStatusHistoryCreateArgs<ExtArgs>>
    ): Prisma__ServiceStatusHistoryClient<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ServiceStatusHistories.
     * @param {ServiceStatusHistoryCreateManyArgs} args - Arguments to create many ServiceStatusHistories.
     * @example
     * // Create many ServiceStatusHistories
     * const serviceStatusHistory = await prisma.serviceStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceStatusHistoryCreateManyArgs>(
      args?: SelectSubset<T, ServiceStatusHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ServiceStatusHistories and returns the data saved in the database.
     * @param {ServiceStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many ServiceStatusHistories.
     * @example
     * // Create many ServiceStatusHistories
     * const serviceStatusHistory = await prisma.serviceStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ServiceStatusHistories and only return the `id`
     * const serviceStatusHistoryWithIdOnly = await prisma.serviceStatusHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceStatusHistoryCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceStatusHistoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ServiceStatusHistory.
     * @param {ServiceStatusHistoryDeleteArgs} args - Arguments to delete one ServiceStatusHistory.
     * @example
     * // Delete one ServiceStatusHistory
     * const ServiceStatusHistory = await prisma.serviceStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one ServiceStatusHistory
     *   }
     * })
     *
     */
    delete<T extends ServiceStatusHistoryDeleteArgs>(
      args: SelectSubset<T, ServiceStatusHistoryDeleteArgs<ExtArgs>>
    ): Prisma__ServiceStatusHistoryClient<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ServiceStatusHistory.
     * @param {ServiceStatusHistoryUpdateArgs} args - Arguments to update one ServiceStatusHistory.
     * @example
     * // Update one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceStatusHistoryUpdateArgs>(
      args: SelectSubset<T, ServiceStatusHistoryUpdateArgs<ExtArgs>>
    ): Prisma__ServiceStatusHistoryClient<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ServiceStatusHistories.
     * @param {ServiceStatusHistoryDeleteManyArgs} args - Arguments to filter ServiceStatusHistories to delete.
     * @example
     * // Delete a few ServiceStatusHistories
     * const { count } = await prisma.serviceStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceStatusHistoryDeleteManyArgs>(
      args?: SelectSubset<T, ServiceStatusHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ServiceStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceStatusHistories
     * const serviceStatusHistory = await prisma.serviceStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceStatusHistoryUpdateManyArgs>(
      args: SelectSubset<T, ServiceStatusHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ServiceStatusHistories and returns the data updated in the database.
     * @param {ServiceStatusHistoryUpdateManyAndReturnArgs} args - Arguments to update many ServiceStatusHistories.
     * @example
     * // Update many ServiceStatusHistories
     * const serviceStatusHistory = await prisma.serviceStatusHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ServiceStatusHistories and only return the `id`
     * const serviceStatusHistoryWithIdOnly = await prisma.serviceStatusHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ServiceStatusHistoryUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ServiceStatusHistoryUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ServiceStatusHistory.
     * @param {ServiceStatusHistoryUpsertArgs} args - Arguments to update or create a ServiceStatusHistory.
     * @example
     * // Update or create a ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.upsert({
     *   create: {
     *     // ... data to create a ServiceStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceStatusHistoryUpsertArgs>(
      args: SelectSubset<T, ServiceStatusHistoryUpsertArgs<ExtArgs>>
    ): Prisma__ServiceStatusHistoryClient<
      $Result.GetResult<
        Prisma.$ServiceStatusHistoryPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ServiceStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryCountArgs} args - Arguments to filter ServiceStatusHistories to count.
     * @example
     * // Count the number of ServiceStatusHistories
     * const count = await prisma.serviceStatusHistory.count({
     *   where: {
     *     // ... the filter for the ServiceStatusHistories we want to count
     *   }
     * })
     **/
    count<T extends ServiceStatusHistoryCountArgs>(
      args?: Subset<T, ServiceStatusHistoryCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceStatusHistoryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ServiceStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceStatusHistoryAggregateArgs>(
      args: Subset<T, ServiceStatusHistoryAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceStatusHistoryAggregateType<T>>;

    /**
     * Group by ServiceStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceStatusHistoryGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetServiceStatusHistoryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ServiceStatusHistory model
     */
    readonly fields: ServiceStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceStatusHistoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ServiceStatusHistory model
   */
  interface ServiceStatusHistoryFieldRefs {
    readonly id: FieldRef<'ServiceStatusHistory', 'String'>;
    readonly serviceId: FieldRef<'ServiceStatusHistory', 'String'>;
    readonly fromStatus: FieldRef<'ServiceStatusHistory', 'ServiceStatus'>;
    readonly toStatus: FieldRef<'ServiceStatusHistory', 'ServiceStatus'>;
    readonly reason: FieldRef<'ServiceStatusHistory', 'String'>;
    readonly changedBy: FieldRef<'ServiceStatusHistory', 'String'>;
    readonly changedAt: FieldRef<'ServiceStatusHistory', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ServiceStatusHistory findUnique
   */
  export type ServiceStatusHistoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceStatusHistory to fetch.
     */
    where: ServiceStatusHistoryWhereUniqueInput;
  };

  /**
   * ServiceStatusHistory findUniqueOrThrow
   */
  export type ServiceStatusHistoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceStatusHistory to fetch.
     */
    where: ServiceStatusHistoryWhereUniqueInput;
  };

  /**
   * ServiceStatusHistory findFirst
   */
  export type ServiceStatusHistoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceStatusHistory to fetch.
     */
    where?: ServiceStatusHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceStatusHistories to fetch.
     */
    orderBy?:
      | ServiceStatusHistoryOrderByWithRelationInput
      | ServiceStatusHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceStatusHistories.
     */
    cursor?: ServiceStatusHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceStatusHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceStatusHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceStatusHistories.
     */
    distinct?: ServiceStatusHistoryScalarFieldEnum | ServiceStatusHistoryScalarFieldEnum[];
  };

  /**
   * ServiceStatusHistory findFirstOrThrow
   */
  export type ServiceStatusHistoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceStatusHistory to fetch.
     */
    where?: ServiceStatusHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceStatusHistories to fetch.
     */
    orderBy?:
      | ServiceStatusHistoryOrderByWithRelationInput
      | ServiceStatusHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceStatusHistories.
     */
    cursor?: ServiceStatusHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceStatusHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceStatusHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceStatusHistories.
     */
    distinct?: ServiceStatusHistoryScalarFieldEnum | ServiceStatusHistoryScalarFieldEnum[];
  };

  /**
   * ServiceStatusHistory findMany
   */
  export type ServiceStatusHistoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceStatusHistories to fetch.
     */
    where?: ServiceStatusHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceStatusHistories to fetch.
     */
    orderBy?:
      | ServiceStatusHistoryOrderByWithRelationInput
      | ServiceStatusHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ServiceStatusHistories.
     */
    cursor?: ServiceStatusHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceStatusHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceStatusHistories.
     */
    skip?: number;
    distinct?: ServiceStatusHistoryScalarFieldEnum | ServiceStatusHistoryScalarFieldEnum[];
  };

  /**
   * ServiceStatusHistory create
   */
  export type ServiceStatusHistoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a ServiceStatusHistory.
     */
    data: XOR<ServiceStatusHistoryCreateInput, ServiceStatusHistoryUncheckedCreateInput>;
  };

  /**
   * ServiceStatusHistory createMany
   */
  export type ServiceStatusHistoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ServiceStatusHistories.
     */
    data: ServiceStatusHistoryCreateManyInput | ServiceStatusHistoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ServiceStatusHistory createManyAndReturn
   */
  export type ServiceStatusHistoryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * The data used to create many ServiceStatusHistories.
     */
    data: ServiceStatusHistoryCreateManyInput | ServiceStatusHistoryCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ServiceStatusHistory update
   */
  export type ServiceStatusHistoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a ServiceStatusHistory.
     */
    data: XOR<ServiceStatusHistoryUpdateInput, ServiceStatusHistoryUncheckedUpdateInput>;
    /**
     * Choose, which ServiceStatusHistory to update.
     */
    where: ServiceStatusHistoryWhereUniqueInput;
  };

  /**
   * ServiceStatusHistory updateMany
   */
  export type ServiceStatusHistoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ServiceStatusHistories.
     */
    data: XOR<
      ServiceStatusHistoryUpdateManyMutationInput,
      ServiceStatusHistoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which ServiceStatusHistories to update
     */
    where?: ServiceStatusHistoryWhereInput;
    /**
     * Limit how many ServiceStatusHistories to update.
     */
    limit?: number;
  };

  /**
   * ServiceStatusHistory updateManyAndReturn
   */
  export type ServiceStatusHistoryUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * The data used to update ServiceStatusHistories.
     */
    data: XOR<
      ServiceStatusHistoryUpdateManyMutationInput,
      ServiceStatusHistoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which ServiceStatusHistories to update
     */
    where?: ServiceStatusHistoryWhereInput;
    /**
     * Limit how many ServiceStatusHistories to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ServiceStatusHistory upsert
   */
  export type ServiceStatusHistoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the ServiceStatusHistory to update in case it exists.
     */
    where: ServiceStatusHistoryWhereUniqueInput;
    /**
     * In case the ServiceStatusHistory found by the `where` argument doesn't exist, create a new ServiceStatusHistory with this data.
     */
    create: XOR<ServiceStatusHistoryCreateInput, ServiceStatusHistoryUncheckedCreateInput>;
    /**
     * In case the ServiceStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceStatusHistoryUpdateInput, ServiceStatusHistoryUncheckedUpdateInput>;
  };

  /**
   * ServiceStatusHistory delete
   */
  export type ServiceStatusHistoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
    /**
     * Filter which ServiceStatusHistory to delete.
     */
    where: ServiceStatusHistoryWhereUniqueInput;
  };

  /**
   * ServiceStatusHistory deleteMany
   */
  export type ServiceStatusHistoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceStatusHistories to delete
     */
    where?: ServiceStatusHistoryWhereInput;
    /**
     * Limit how many ServiceStatusHistories to delete.
     */
    limit?: number;
  };

  /**
   * ServiceStatusHistory without action
   */
  export type ServiceStatusHistoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceStatusHistory
     */
    omit?: ServiceStatusHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null;
  };

  /**
   * Model LoadingOrder
   */

  export type AggregateLoadingOrder = {
    _count: LoadingOrderCountAggregateOutputType | null;
    _avg: LoadingOrderAvgAggregateOutputType | null;
    _sum: LoadingOrderSumAggregateOutputType | null;
    _min: LoadingOrderMinAggregateOutputType | null;
    _max: LoadingOrderMaxAggregateOutputType | null;
  };

  export type LoadingOrderAvgAggregateOutputType = {
    pdfSize: number | null;
  };

  export type LoadingOrderSumAggregateOutputType = {
    pdfSize: number | null;
  };

  export type LoadingOrderMinAggregateOutputType = {
    id: string | null;
    orderNumber: string | null;
    generatedAt: Date | null;
    generatedById: string | null;
    clientId: string | null;
    notes: string | null;
    pdfPath: string | null;
    pdfGeneratedAt: Date | null;
    pdfSize: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type LoadingOrderMaxAggregateOutputType = {
    id: string | null;
    orderNumber: string | null;
    generatedAt: Date | null;
    generatedById: string | null;
    clientId: string | null;
    notes: string | null;
    pdfPath: string | null;
    pdfGeneratedAt: Date | null;
    pdfSize: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type LoadingOrderCountAggregateOutputType = {
    id: number;
    orderNumber: number;
    generatedAt: number;
    generatedById: number;
    clientId: number;
    notes: number;
    pdfPath: number;
    pdfGeneratedAt: number;
    pdfSize: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type LoadingOrderAvgAggregateInputType = {
    pdfSize?: true;
  };

  export type LoadingOrderSumAggregateInputType = {
    pdfSize?: true;
  };

  export type LoadingOrderMinAggregateInputType = {
    id?: true;
    orderNumber?: true;
    generatedAt?: true;
    generatedById?: true;
    clientId?: true;
    notes?: true;
    pdfPath?: true;
    pdfGeneratedAt?: true;
    pdfSize?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type LoadingOrderMaxAggregateInputType = {
    id?: true;
    orderNumber?: true;
    generatedAt?: true;
    generatedById?: true;
    clientId?: true;
    notes?: true;
    pdfPath?: true;
    pdfGeneratedAt?: true;
    pdfSize?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type LoadingOrderCountAggregateInputType = {
    id?: true;
    orderNumber?: true;
    generatedAt?: true;
    generatedById?: true;
    clientId?: true;
    notes?: true;
    pdfPath?: true;
    pdfGeneratedAt?: true;
    pdfSize?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type LoadingOrderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LoadingOrder to aggregate.
     */
    where?: LoadingOrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LoadingOrders to fetch.
     */
    orderBy?: LoadingOrderOrderByWithRelationInput | LoadingOrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LoadingOrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LoadingOrders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LoadingOrders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LoadingOrders
     **/
    _count?: true | LoadingOrderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LoadingOrderAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LoadingOrderSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LoadingOrderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LoadingOrderMaxAggregateInputType;
  };

  export type GetLoadingOrderAggregateType<T extends LoadingOrderAggregateArgs> = {
    [P in keyof T & keyof AggregateLoadingOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoadingOrder[P]>
      : GetScalarType<T[P], AggregateLoadingOrder[P]>;
  };

  export type LoadingOrderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LoadingOrderWhereInput;
    orderBy?: LoadingOrderOrderByWithAggregationInput | LoadingOrderOrderByWithAggregationInput[];
    by: LoadingOrderScalarFieldEnum[] | LoadingOrderScalarFieldEnum;
    having?: LoadingOrderScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LoadingOrderCountAggregateInputType | true;
    _avg?: LoadingOrderAvgAggregateInputType;
    _sum?: LoadingOrderSumAggregateInputType;
    _min?: LoadingOrderMinAggregateInputType;
    _max?: LoadingOrderMaxAggregateInputType;
  };

  export type LoadingOrderGroupByOutputType = {
    id: string;
    orderNumber: string;
    generatedAt: Date;
    generatedById: string;
    clientId: string | null;
    notes: string | null;
    pdfPath: string | null;
    pdfGeneratedAt: Date | null;
    pdfSize: number | null;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: LoadingOrderCountAggregateOutputType | null;
    _avg: LoadingOrderAvgAggregateOutputType | null;
    _sum: LoadingOrderSumAggregateOutputType | null;
    _min: LoadingOrderMinAggregateOutputType | null;
    _max: LoadingOrderMaxAggregateOutputType | null;
  };

  type GetLoadingOrderGroupByPayload<T extends LoadingOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoadingOrderGroupByOutputType, T['by']> & {
        [P in keyof T & keyof LoadingOrderGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], LoadingOrderGroupByOutputType[P]>
          : GetScalarType<T[P], LoadingOrderGroupByOutputType[P]>;
      }
    >
  >;

  export type LoadingOrderSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderNumber?: boolean;
      generatedAt?: boolean;
      generatedById?: boolean;
      clientId?: boolean;
      notes?: boolean;
      pdfPath?: boolean;
      pdfGeneratedAt?: boolean;
      pdfSize?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      generatedBy?: boolean | UserDefaultArgs<ExtArgs>;
      services?: boolean | LoadingOrder$servicesArgs<ExtArgs>;
      _count?: boolean | LoadingOrderCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['loadingOrder']
  >;

  export type LoadingOrderSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderNumber?: boolean;
      generatedAt?: boolean;
      generatedById?: boolean;
      clientId?: boolean;
      notes?: boolean;
      pdfPath?: boolean;
      pdfGeneratedAt?: boolean;
      pdfSize?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      generatedBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['loadingOrder']
  >;

  export type LoadingOrderSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderNumber?: boolean;
      generatedAt?: boolean;
      generatedById?: boolean;
      clientId?: boolean;
      notes?: boolean;
      pdfPath?: boolean;
      pdfGeneratedAt?: boolean;
      pdfSize?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      generatedBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['loadingOrder']
  >;

  export type LoadingOrderSelectScalar = {
    id?: boolean;
    orderNumber?: boolean;
    generatedAt?: boolean;
    generatedById?: boolean;
    clientId?: boolean;
    notes?: boolean;
    pdfPath?: boolean;
    pdfGeneratedAt?: boolean;
    pdfSize?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type LoadingOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'orderNumber'
      | 'generatedAt'
      | 'generatedById'
      | 'clientId'
      | 'notes'
      | 'pdfPath'
      | 'pdfGeneratedAt'
      | 'pdfSize'
      | 'metadata'
      | 'createdAt'
      | 'updatedAt'
      | 'deletedAt',
      ExtArgs['result']['loadingOrder']
    >;
  export type LoadingOrderInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    generatedBy?: boolean | UserDefaultArgs<ExtArgs>;
    services?: boolean | LoadingOrder$servicesArgs<ExtArgs>;
    _count?: boolean | LoadingOrderCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type LoadingOrderIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    generatedBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type LoadingOrderIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    generatedBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $LoadingOrderPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'LoadingOrder';
    objects: {
      generatedBy: Prisma.$UserPayload<ExtArgs>;
      services: Prisma.$ServiceLoadingOrderPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        orderNumber: string;
        generatedAt: Date;
        generatedById: string;
        clientId: string | null;
        notes: string | null;
        pdfPath: string | null;
        pdfGeneratedAt: Date | null;
        pdfSize: number | null;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['loadingOrder']
    >;
    composites: {};
  };

  type LoadingOrderGetPayload<S extends boolean | null | undefined | LoadingOrderDefaultArgs> =
    $Result.GetResult<Prisma.$LoadingOrderPayload, S>;

  type LoadingOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoadingOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoadingOrderCountAggregateInputType | true;
    };

  export interface LoadingOrderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['LoadingOrder'];
      meta: { name: 'LoadingOrder' };
    };
    /**
     * Find zero or one LoadingOrder that matches the filter.
     * @param {LoadingOrderFindUniqueArgs} args - Arguments to find a LoadingOrder
     * @example
     * // Get one LoadingOrder
     * const loadingOrder = await prisma.loadingOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoadingOrderFindUniqueArgs>(
      args: SelectSubset<T, LoadingOrderFindUniqueArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      $Result.GetResult<
        Prisma.$LoadingOrderPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one LoadingOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoadingOrderFindUniqueOrThrowArgs} args - Arguments to find a LoadingOrder
     * @example
     * // Get one LoadingOrder
     * const loadingOrder = await prisma.loadingOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoadingOrderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LoadingOrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      $Result.GetResult<
        Prisma.$LoadingOrderPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LoadingOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadingOrderFindFirstArgs} args - Arguments to find a LoadingOrder
     * @example
     * // Get one LoadingOrder
     * const loadingOrder = await prisma.loadingOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoadingOrderFindFirstArgs>(
      args?: SelectSubset<T, LoadingOrderFindFirstArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      $Result.GetResult<
        Prisma.$LoadingOrderPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LoadingOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadingOrderFindFirstOrThrowArgs} args - Arguments to find a LoadingOrder
     * @example
     * // Get one LoadingOrder
     * const loadingOrder = await prisma.loadingOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoadingOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LoadingOrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      $Result.GetResult<
        Prisma.$LoadingOrderPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more LoadingOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadingOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoadingOrders
     * const loadingOrders = await prisma.loadingOrder.findMany()
     *
     * // Get first 10 LoadingOrders
     * const loadingOrders = await prisma.loadingOrder.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const loadingOrderWithIdOnly = await prisma.loadingOrder.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LoadingOrderFindManyArgs>(
      args?: SelectSubset<T, LoadingOrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LoadingOrderPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a LoadingOrder.
     * @param {LoadingOrderCreateArgs} args - Arguments to create a LoadingOrder.
     * @example
     * // Create one LoadingOrder
     * const LoadingOrder = await prisma.loadingOrder.create({
     *   data: {
     *     // ... data to create a LoadingOrder
     *   }
     * })
     *
     */
    create<T extends LoadingOrderCreateArgs>(
      args: SelectSubset<T, LoadingOrderCreateArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      $Result.GetResult<Prisma.$LoadingOrderPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many LoadingOrders.
     * @param {LoadingOrderCreateManyArgs} args - Arguments to create many LoadingOrders.
     * @example
     * // Create many LoadingOrders
     * const loadingOrder = await prisma.loadingOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LoadingOrderCreateManyArgs>(
      args?: SelectSubset<T, LoadingOrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many LoadingOrders and returns the data saved in the database.
     * @param {LoadingOrderCreateManyAndReturnArgs} args - Arguments to create many LoadingOrders.
     * @example
     * // Create many LoadingOrders
     * const loadingOrder = await prisma.loadingOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many LoadingOrders and only return the `id`
     * const loadingOrderWithIdOnly = await prisma.loadingOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LoadingOrderCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LoadingOrderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LoadingOrderPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a LoadingOrder.
     * @param {LoadingOrderDeleteArgs} args - Arguments to delete one LoadingOrder.
     * @example
     * // Delete one LoadingOrder
     * const LoadingOrder = await prisma.loadingOrder.delete({
     *   where: {
     *     // ... filter to delete one LoadingOrder
     *   }
     * })
     *
     */
    delete<T extends LoadingOrderDeleteArgs>(
      args: SelectSubset<T, LoadingOrderDeleteArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      $Result.GetResult<Prisma.$LoadingOrderPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one LoadingOrder.
     * @param {LoadingOrderUpdateArgs} args - Arguments to update one LoadingOrder.
     * @example
     * // Update one LoadingOrder
     * const loadingOrder = await prisma.loadingOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LoadingOrderUpdateArgs>(
      args: SelectSubset<T, LoadingOrderUpdateArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      $Result.GetResult<Prisma.$LoadingOrderPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more LoadingOrders.
     * @param {LoadingOrderDeleteManyArgs} args - Arguments to filter LoadingOrders to delete.
     * @example
     * // Delete a few LoadingOrders
     * const { count } = await prisma.loadingOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LoadingOrderDeleteManyArgs>(
      args?: SelectSubset<T, LoadingOrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LoadingOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadingOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoadingOrders
     * const loadingOrder = await prisma.loadingOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LoadingOrderUpdateManyArgs>(
      args: SelectSubset<T, LoadingOrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LoadingOrders and returns the data updated in the database.
     * @param {LoadingOrderUpdateManyAndReturnArgs} args - Arguments to update many LoadingOrders.
     * @example
     * // Update many LoadingOrders
     * const loadingOrder = await prisma.loadingOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more LoadingOrders and only return the `id`
     * const loadingOrderWithIdOnly = await prisma.loadingOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LoadingOrderUpdateManyAndReturnArgs>(
      args: SelectSubset<T, LoadingOrderUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LoadingOrderPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one LoadingOrder.
     * @param {LoadingOrderUpsertArgs} args - Arguments to update or create a LoadingOrder.
     * @example
     * // Update or create a LoadingOrder
     * const loadingOrder = await prisma.loadingOrder.upsert({
     *   create: {
     *     // ... data to create a LoadingOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoadingOrder we want to update
     *   }
     * })
     */
    upsert<T extends LoadingOrderUpsertArgs>(
      args: SelectSubset<T, LoadingOrderUpsertArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      $Result.GetResult<Prisma.$LoadingOrderPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of LoadingOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadingOrderCountArgs} args - Arguments to filter LoadingOrders to count.
     * @example
     * // Count the number of LoadingOrders
     * const count = await prisma.loadingOrder.count({
     *   where: {
     *     // ... the filter for the LoadingOrders we want to count
     *   }
     * })
     **/
    count<T extends LoadingOrderCountArgs>(
      args?: Subset<T, LoadingOrderCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoadingOrderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LoadingOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadingOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LoadingOrderAggregateArgs>(
      args: Subset<T, LoadingOrderAggregateArgs>
    ): Prisma.PrismaPromise<GetLoadingOrderAggregateType<T>>;

    /**
     * Group by LoadingOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadingOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LoadingOrderGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoadingOrderGroupByArgs['orderBy'] }
        : { orderBy?: LoadingOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LoadingOrderGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetLoadingOrderGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LoadingOrder model
     */
    readonly fields: LoadingOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoadingOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoadingOrderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    generatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    services<T extends LoadingOrder$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, LoadingOrder$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LoadingOrder model
   */
  interface LoadingOrderFieldRefs {
    readonly id: FieldRef<'LoadingOrder', 'String'>;
    readonly orderNumber: FieldRef<'LoadingOrder', 'String'>;
    readonly generatedAt: FieldRef<'LoadingOrder', 'DateTime'>;
    readonly generatedById: FieldRef<'LoadingOrder', 'String'>;
    readonly clientId: FieldRef<'LoadingOrder', 'String'>;
    readonly notes: FieldRef<'LoadingOrder', 'String'>;
    readonly pdfPath: FieldRef<'LoadingOrder', 'String'>;
    readonly pdfGeneratedAt: FieldRef<'LoadingOrder', 'DateTime'>;
    readonly pdfSize: FieldRef<'LoadingOrder', 'Int'>;
    readonly metadata: FieldRef<'LoadingOrder', 'Json'>;
    readonly createdAt: FieldRef<'LoadingOrder', 'DateTime'>;
    readonly updatedAt: FieldRef<'LoadingOrder', 'DateTime'>;
    readonly deletedAt: FieldRef<'LoadingOrder', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * LoadingOrder findUnique
   */
  export type LoadingOrderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which LoadingOrder to fetch.
     */
    where: LoadingOrderWhereUniqueInput;
  };

  /**
   * LoadingOrder findUniqueOrThrow
   */
  export type LoadingOrderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which LoadingOrder to fetch.
     */
    where: LoadingOrderWhereUniqueInput;
  };

  /**
   * LoadingOrder findFirst
   */
  export type LoadingOrderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which LoadingOrder to fetch.
     */
    where?: LoadingOrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LoadingOrders to fetch.
     */
    orderBy?: LoadingOrderOrderByWithRelationInput | LoadingOrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LoadingOrders.
     */
    cursor?: LoadingOrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LoadingOrders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LoadingOrders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LoadingOrders.
     */
    distinct?: LoadingOrderScalarFieldEnum | LoadingOrderScalarFieldEnum[];
  };

  /**
   * LoadingOrder findFirstOrThrow
   */
  export type LoadingOrderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which LoadingOrder to fetch.
     */
    where?: LoadingOrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LoadingOrders to fetch.
     */
    orderBy?: LoadingOrderOrderByWithRelationInput | LoadingOrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LoadingOrders.
     */
    cursor?: LoadingOrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LoadingOrders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LoadingOrders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LoadingOrders.
     */
    distinct?: LoadingOrderScalarFieldEnum | LoadingOrderScalarFieldEnum[];
  };

  /**
   * LoadingOrder findMany
   */
  export type LoadingOrderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which LoadingOrders to fetch.
     */
    where?: LoadingOrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LoadingOrders to fetch.
     */
    orderBy?: LoadingOrderOrderByWithRelationInput | LoadingOrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LoadingOrders.
     */
    cursor?: LoadingOrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LoadingOrders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LoadingOrders.
     */
    skip?: number;
    distinct?: LoadingOrderScalarFieldEnum | LoadingOrderScalarFieldEnum[];
  };

  /**
   * LoadingOrder create
   */
  export type LoadingOrderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * The data needed to create a LoadingOrder.
     */
    data: XOR<LoadingOrderCreateInput, LoadingOrderUncheckedCreateInput>;
  };

  /**
   * LoadingOrder createMany
   */
  export type LoadingOrderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many LoadingOrders.
     */
    data: LoadingOrderCreateManyInput | LoadingOrderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LoadingOrder createManyAndReturn
   */
  export type LoadingOrderCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * The data used to create many LoadingOrders.
     */
    data: LoadingOrderCreateManyInput | LoadingOrderCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LoadingOrder update
   */
  export type LoadingOrderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * The data needed to update a LoadingOrder.
     */
    data: XOR<LoadingOrderUpdateInput, LoadingOrderUncheckedUpdateInput>;
    /**
     * Choose, which LoadingOrder to update.
     */
    where: LoadingOrderWhereUniqueInput;
  };

  /**
   * LoadingOrder updateMany
   */
  export type LoadingOrderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update LoadingOrders.
     */
    data: XOR<LoadingOrderUpdateManyMutationInput, LoadingOrderUncheckedUpdateManyInput>;
    /**
     * Filter which LoadingOrders to update
     */
    where?: LoadingOrderWhereInput;
    /**
     * Limit how many LoadingOrders to update.
     */
    limit?: number;
  };

  /**
   * LoadingOrder updateManyAndReturn
   */
  export type LoadingOrderUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * The data used to update LoadingOrders.
     */
    data: XOR<LoadingOrderUpdateManyMutationInput, LoadingOrderUncheckedUpdateManyInput>;
    /**
     * Filter which LoadingOrders to update
     */
    where?: LoadingOrderWhereInput;
    /**
     * Limit how many LoadingOrders to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LoadingOrder upsert
   */
  export type LoadingOrderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * The filter to search for the LoadingOrder to update in case it exists.
     */
    where: LoadingOrderWhereUniqueInput;
    /**
     * In case the LoadingOrder found by the `where` argument doesn't exist, create a new LoadingOrder with this data.
     */
    create: XOR<LoadingOrderCreateInput, LoadingOrderUncheckedCreateInput>;
    /**
     * In case the LoadingOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoadingOrderUpdateInput, LoadingOrderUncheckedUpdateInput>;
  };

  /**
   * LoadingOrder delete
   */
  export type LoadingOrderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter which LoadingOrder to delete.
     */
    where: LoadingOrderWhereUniqueInput;
  };

  /**
   * LoadingOrder deleteMany
   */
  export type LoadingOrderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LoadingOrders to delete
     */
    where?: LoadingOrderWhereInput;
    /**
     * Limit how many LoadingOrders to delete.
     */
    limit?: number;
  };

  /**
   * LoadingOrder.services
   */
  export type LoadingOrder$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    where?: ServiceLoadingOrderWhereInput;
    orderBy?:
      | ServiceLoadingOrderOrderByWithRelationInput
      | ServiceLoadingOrderOrderByWithRelationInput[];
    cursor?: ServiceLoadingOrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceLoadingOrderScalarFieldEnum | ServiceLoadingOrderScalarFieldEnum[];
  };

  /**
   * LoadingOrder without action
   */
  export type LoadingOrderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LoadingOrder
     */
    select?: LoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LoadingOrder
     */
    omit?: LoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadingOrderInclude<ExtArgs> | null;
  };

  /**
   * Model ServiceLoadingOrder
   */

  export type AggregateServiceLoadingOrder = {
    _count: ServiceLoadingOrderCountAggregateOutputType | null;
    _avg: ServiceLoadingOrderAvgAggregateOutputType | null;
    _sum: ServiceLoadingOrderSumAggregateOutputType | null;
    _min: ServiceLoadingOrderMinAggregateOutputType | null;
    _max: ServiceLoadingOrderMaxAggregateOutputType | null;
  };

  export type ServiceLoadingOrderAvgAggregateOutputType = {
    position: number | null;
  };

  export type ServiceLoadingOrderSumAggregateOutputType = {
    position: number | null;
  };

  export type ServiceLoadingOrderMinAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    loadingOrderId: string | null;
    position: number | null;
  };

  export type ServiceLoadingOrderMaxAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    loadingOrderId: string | null;
    position: number | null;
  };

  export type ServiceLoadingOrderCountAggregateOutputType = {
    id: number;
    serviceId: number;
    loadingOrderId: number;
    position: number;
    _all: number;
  };

  export type ServiceLoadingOrderAvgAggregateInputType = {
    position?: true;
  };

  export type ServiceLoadingOrderSumAggregateInputType = {
    position?: true;
  };

  export type ServiceLoadingOrderMinAggregateInputType = {
    id?: true;
    serviceId?: true;
    loadingOrderId?: true;
    position?: true;
  };

  export type ServiceLoadingOrderMaxAggregateInputType = {
    id?: true;
    serviceId?: true;
    loadingOrderId?: true;
    position?: true;
  };

  export type ServiceLoadingOrderCountAggregateInputType = {
    id?: true;
    serviceId?: true;
    loadingOrderId?: true;
    position?: true;
    _all?: true;
  };

  export type ServiceLoadingOrderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceLoadingOrder to aggregate.
     */
    where?: ServiceLoadingOrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceLoadingOrders to fetch.
     */
    orderBy?:
      | ServiceLoadingOrderOrderByWithRelationInput
      | ServiceLoadingOrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceLoadingOrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceLoadingOrders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceLoadingOrders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ServiceLoadingOrders
     **/
    _count?: true | ServiceLoadingOrderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceLoadingOrderAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceLoadingOrderSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceLoadingOrderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceLoadingOrderMaxAggregateInputType;
  };

  export type GetServiceLoadingOrderAggregateType<T extends ServiceLoadingOrderAggregateArgs> = {
    [P in keyof T & keyof AggregateServiceLoadingOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceLoadingOrder[P]>
      : GetScalarType<T[P], AggregateServiceLoadingOrder[P]>;
  };

  export type ServiceLoadingOrderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceLoadingOrderWhereInput;
    orderBy?:
      | ServiceLoadingOrderOrderByWithAggregationInput
      | ServiceLoadingOrderOrderByWithAggregationInput[];
    by: ServiceLoadingOrderScalarFieldEnum[] | ServiceLoadingOrderScalarFieldEnum;
    having?: ServiceLoadingOrderScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceLoadingOrderCountAggregateInputType | true;
    _avg?: ServiceLoadingOrderAvgAggregateInputType;
    _sum?: ServiceLoadingOrderSumAggregateInputType;
    _min?: ServiceLoadingOrderMinAggregateInputType;
    _max?: ServiceLoadingOrderMaxAggregateInputType;
  };

  export type ServiceLoadingOrderGroupByOutputType = {
    id: string;
    serviceId: string;
    loadingOrderId: string;
    position: number;
    _count: ServiceLoadingOrderCountAggregateOutputType | null;
    _avg: ServiceLoadingOrderAvgAggregateOutputType | null;
    _sum: ServiceLoadingOrderSumAggregateOutputType | null;
    _min: ServiceLoadingOrderMinAggregateOutputType | null;
    _max: ServiceLoadingOrderMaxAggregateOutputType | null;
  };

  type GetServiceLoadingOrderGroupByPayload<T extends ServiceLoadingOrderGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ServiceLoadingOrderGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ServiceLoadingOrderGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceLoadingOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceLoadingOrderGroupByOutputType[P]>;
        }
      >
    >;

  export type ServiceLoadingOrderSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      loadingOrderId?: boolean;
      position?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      loadingOrder?: boolean | LoadingOrderDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceLoadingOrder']
  >;

  export type ServiceLoadingOrderSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      loadingOrderId?: boolean;
      position?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      loadingOrder?: boolean | LoadingOrderDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceLoadingOrder']
  >;

  export type ServiceLoadingOrderSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      loadingOrderId?: boolean;
      position?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      loadingOrder?: boolean | LoadingOrderDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceLoadingOrder']
  >;

  export type ServiceLoadingOrderSelectScalar = {
    id?: boolean;
    serviceId?: boolean;
    loadingOrderId?: boolean;
    position?: boolean;
  };

  export type ServiceLoadingOrderOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'serviceId' | 'loadingOrderId' | 'position',
    ExtArgs['result']['serviceLoadingOrder']
  >;
  export type ServiceLoadingOrderInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    loadingOrder?: boolean | LoadingOrderDefaultArgs<ExtArgs>;
  };
  export type ServiceLoadingOrderIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    loadingOrder?: boolean | LoadingOrderDefaultArgs<ExtArgs>;
  };
  export type ServiceLoadingOrderIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    loadingOrder?: boolean | LoadingOrderDefaultArgs<ExtArgs>;
  };

  export type $ServiceLoadingOrderPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ServiceLoadingOrder';
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>;
      loadingOrder: Prisma.$LoadingOrderPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        serviceId: string;
        loadingOrderId: string;
        position: number;
      },
      ExtArgs['result']['serviceLoadingOrder']
    >;
    composites: {};
  };

  type ServiceLoadingOrderGetPayload<
    S extends boolean | null | undefined | ServiceLoadingOrderDefaultArgs,
  > = $Result.GetResult<Prisma.$ServiceLoadingOrderPayload, S>;

  type ServiceLoadingOrderCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ServiceLoadingOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ServiceLoadingOrderCountAggregateInputType | true;
  };

  export interface ServiceLoadingOrderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ServiceLoadingOrder'];
      meta: { name: 'ServiceLoadingOrder' };
    };
    /**
     * Find zero or one ServiceLoadingOrder that matches the filter.
     * @param {ServiceLoadingOrderFindUniqueArgs} args - Arguments to find a ServiceLoadingOrder
     * @example
     * // Get one ServiceLoadingOrder
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceLoadingOrderFindUniqueArgs>(
      args: SelectSubset<T, ServiceLoadingOrderFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceLoadingOrderClient<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ServiceLoadingOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceLoadingOrderFindUniqueOrThrowArgs} args - Arguments to find a ServiceLoadingOrder
     * @example
     * // Get one ServiceLoadingOrder
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceLoadingOrderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceLoadingOrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceLoadingOrderClient<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ServiceLoadingOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceLoadingOrderFindFirstArgs} args - Arguments to find a ServiceLoadingOrder
     * @example
     * // Get one ServiceLoadingOrder
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceLoadingOrderFindFirstArgs>(
      args?: SelectSubset<T, ServiceLoadingOrderFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceLoadingOrderClient<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ServiceLoadingOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceLoadingOrderFindFirstOrThrowArgs} args - Arguments to find a ServiceLoadingOrder
     * @example
     * // Get one ServiceLoadingOrder
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceLoadingOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceLoadingOrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceLoadingOrderClient<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ServiceLoadingOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceLoadingOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceLoadingOrders
     * const serviceLoadingOrders = await prisma.serviceLoadingOrder.findMany()
     *
     * // Get first 10 ServiceLoadingOrders
     * const serviceLoadingOrders = await prisma.serviceLoadingOrder.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceLoadingOrderWithIdOnly = await prisma.serviceLoadingOrder.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceLoadingOrderFindManyArgs>(
      args?: SelectSubset<T, ServiceLoadingOrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ServiceLoadingOrder.
     * @param {ServiceLoadingOrderCreateArgs} args - Arguments to create a ServiceLoadingOrder.
     * @example
     * // Create one ServiceLoadingOrder
     * const ServiceLoadingOrder = await prisma.serviceLoadingOrder.create({
     *   data: {
     *     // ... data to create a ServiceLoadingOrder
     *   }
     * })
     *
     */
    create<T extends ServiceLoadingOrderCreateArgs>(
      args: SelectSubset<T, ServiceLoadingOrderCreateArgs<ExtArgs>>
    ): Prisma__ServiceLoadingOrderClient<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ServiceLoadingOrders.
     * @param {ServiceLoadingOrderCreateManyArgs} args - Arguments to create many ServiceLoadingOrders.
     * @example
     * // Create many ServiceLoadingOrders
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceLoadingOrderCreateManyArgs>(
      args?: SelectSubset<T, ServiceLoadingOrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ServiceLoadingOrders and returns the data saved in the database.
     * @param {ServiceLoadingOrderCreateManyAndReturnArgs} args - Arguments to create many ServiceLoadingOrders.
     * @example
     * // Create many ServiceLoadingOrders
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ServiceLoadingOrders and only return the `id`
     * const serviceLoadingOrderWithIdOnly = await prisma.serviceLoadingOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceLoadingOrderCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceLoadingOrderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ServiceLoadingOrder.
     * @param {ServiceLoadingOrderDeleteArgs} args - Arguments to delete one ServiceLoadingOrder.
     * @example
     * // Delete one ServiceLoadingOrder
     * const ServiceLoadingOrder = await prisma.serviceLoadingOrder.delete({
     *   where: {
     *     // ... filter to delete one ServiceLoadingOrder
     *   }
     * })
     *
     */
    delete<T extends ServiceLoadingOrderDeleteArgs>(
      args: SelectSubset<T, ServiceLoadingOrderDeleteArgs<ExtArgs>>
    ): Prisma__ServiceLoadingOrderClient<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ServiceLoadingOrder.
     * @param {ServiceLoadingOrderUpdateArgs} args - Arguments to update one ServiceLoadingOrder.
     * @example
     * // Update one ServiceLoadingOrder
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceLoadingOrderUpdateArgs>(
      args: SelectSubset<T, ServiceLoadingOrderUpdateArgs<ExtArgs>>
    ): Prisma__ServiceLoadingOrderClient<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ServiceLoadingOrders.
     * @param {ServiceLoadingOrderDeleteManyArgs} args - Arguments to filter ServiceLoadingOrders to delete.
     * @example
     * // Delete a few ServiceLoadingOrders
     * const { count } = await prisma.serviceLoadingOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceLoadingOrderDeleteManyArgs>(
      args?: SelectSubset<T, ServiceLoadingOrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ServiceLoadingOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceLoadingOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceLoadingOrders
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceLoadingOrderUpdateManyArgs>(
      args: SelectSubset<T, ServiceLoadingOrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ServiceLoadingOrders and returns the data updated in the database.
     * @param {ServiceLoadingOrderUpdateManyAndReturnArgs} args - Arguments to update many ServiceLoadingOrders.
     * @example
     * // Update many ServiceLoadingOrders
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ServiceLoadingOrders and only return the `id`
     * const serviceLoadingOrderWithIdOnly = await prisma.serviceLoadingOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ServiceLoadingOrderUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ServiceLoadingOrderUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ServiceLoadingOrder.
     * @param {ServiceLoadingOrderUpsertArgs} args - Arguments to update or create a ServiceLoadingOrder.
     * @example
     * // Update or create a ServiceLoadingOrder
     * const serviceLoadingOrder = await prisma.serviceLoadingOrder.upsert({
     *   create: {
     *     // ... data to create a ServiceLoadingOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceLoadingOrder we want to update
     *   }
     * })
     */
    upsert<T extends ServiceLoadingOrderUpsertArgs>(
      args: SelectSubset<T, ServiceLoadingOrderUpsertArgs<ExtArgs>>
    ): Prisma__ServiceLoadingOrderClient<
      $Result.GetResult<
        Prisma.$ServiceLoadingOrderPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ServiceLoadingOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceLoadingOrderCountArgs} args - Arguments to filter ServiceLoadingOrders to count.
     * @example
     * // Count the number of ServiceLoadingOrders
     * const count = await prisma.serviceLoadingOrder.count({
     *   where: {
     *     // ... the filter for the ServiceLoadingOrders we want to count
     *   }
     * })
     **/
    count<T extends ServiceLoadingOrderCountArgs>(
      args?: Subset<T, ServiceLoadingOrderCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceLoadingOrderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ServiceLoadingOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceLoadingOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceLoadingOrderAggregateArgs>(
      args: Subset<T, ServiceLoadingOrderAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceLoadingOrderAggregateType<T>>;

    /**
     * Group by ServiceLoadingOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceLoadingOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceLoadingOrderGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceLoadingOrderGroupByArgs['orderBy'] }
        : { orderBy?: ServiceLoadingOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceLoadingOrderGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetServiceLoadingOrderGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ServiceLoadingOrder model
     */
    readonly fields: ServiceLoadingOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceLoadingOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceLoadingOrderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    loadingOrder<T extends LoadingOrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LoadingOrderDefaultArgs<ExtArgs>>
    ): Prisma__LoadingOrderClient<
      | $Result.GetResult<
          Prisma.$LoadingOrderPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ServiceLoadingOrder model
   */
  interface ServiceLoadingOrderFieldRefs {
    readonly id: FieldRef<'ServiceLoadingOrder', 'String'>;
    readonly serviceId: FieldRef<'ServiceLoadingOrder', 'String'>;
    readonly loadingOrderId: FieldRef<'ServiceLoadingOrder', 'String'>;
    readonly position: FieldRef<'ServiceLoadingOrder', 'Int'>;
  }

  // Custom InputTypes
  /**
   * ServiceLoadingOrder findUnique
   */
  export type ServiceLoadingOrderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceLoadingOrder to fetch.
     */
    where: ServiceLoadingOrderWhereUniqueInput;
  };

  /**
   * ServiceLoadingOrder findUniqueOrThrow
   */
  export type ServiceLoadingOrderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceLoadingOrder to fetch.
     */
    where: ServiceLoadingOrderWhereUniqueInput;
  };

  /**
   * ServiceLoadingOrder findFirst
   */
  export type ServiceLoadingOrderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceLoadingOrder to fetch.
     */
    where?: ServiceLoadingOrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceLoadingOrders to fetch.
     */
    orderBy?:
      | ServiceLoadingOrderOrderByWithRelationInput
      | ServiceLoadingOrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceLoadingOrders.
     */
    cursor?: ServiceLoadingOrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceLoadingOrders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceLoadingOrders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceLoadingOrders.
     */
    distinct?: ServiceLoadingOrderScalarFieldEnum | ServiceLoadingOrderScalarFieldEnum[];
  };

  /**
   * ServiceLoadingOrder findFirstOrThrow
   */
  export type ServiceLoadingOrderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceLoadingOrder to fetch.
     */
    where?: ServiceLoadingOrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceLoadingOrders to fetch.
     */
    orderBy?:
      | ServiceLoadingOrderOrderByWithRelationInput
      | ServiceLoadingOrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceLoadingOrders.
     */
    cursor?: ServiceLoadingOrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceLoadingOrders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceLoadingOrders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceLoadingOrders.
     */
    distinct?: ServiceLoadingOrderScalarFieldEnum | ServiceLoadingOrderScalarFieldEnum[];
  };

  /**
   * ServiceLoadingOrder findMany
   */
  export type ServiceLoadingOrderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceLoadingOrders to fetch.
     */
    where?: ServiceLoadingOrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceLoadingOrders to fetch.
     */
    orderBy?:
      | ServiceLoadingOrderOrderByWithRelationInput
      | ServiceLoadingOrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ServiceLoadingOrders.
     */
    cursor?: ServiceLoadingOrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceLoadingOrders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceLoadingOrders.
     */
    skip?: number;
    distinct?: ServiceLoadingOrderScalarFieldEnum | ServiceLoadingOrderScalarFieldEnum[];
  };

  /**
   * ServiceLoadingOrder create
   */
  export type ServiceLoadingOrderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * The data needed to create a ServiceLoadingOrder.
     */
    data: XOR<ServiceLoadingOrderCreateInput, ServiceLoadingOrderUncheckedCreateInput>;
  };

  /**
   * ServiceLoadingOrder createMany
   */
  export type ServiceLoadingOrderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ServiceLoadingOrders.
     */
    data: ServiceLoadingOrderCreateManyInput | ServiceLoadingOrderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ServiceLoadingOrder createManyAndReturn
   */
  export type ServiceLoadingOrderCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * The data used to create many ServiceLoadingOrders.
     */
    data: ServiceLoadingOrderCreateManyInput | ServiceLoadingOrderCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ServiceLoadingOrder update
   */
  export type ServiceLoadingOrderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * The data needed to update a ServiceLoadingOrder.
     */
    data: XOR<ServiceLoadingOrderUpdateInput, ServiceLoadingOrderUncheckedUpdateInput>;
    /**
     * Choose, which ServiceLoadingOrder to update.
     */
    where: ServiceLoadingOrderWhereUniqueInput;
  };

  /**
   * ServiceLoadingOrder updateMany
   */
  export type ServiceLoadingOrderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ServiceLoadingOrders.
     */
    data: XOR<
      ServiceLoadingOrderUpdateManyMutationInput,
      ServiceLoadingOrderUncheckedUpdateManyInput
    >;
    /**
     * Filter which ServiceLoadingOrders to update
     */
    where?: ServiceLoadingOrderWhereInput;
    /**
     * Limit how many ServiceLoadingOrders to update.
     */
    limit?: number;
  };

  /**
   * ServiceLoadingOrder updateManyAndReturn
   */
  export type ServiceLoadingOrderUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * The data used to update ServiceLoadingOrders.
     */
    data: XOR<
      ServiceLoadingOrderUpdateManyMutationInput,
      ServiceLoadingOrderUncheckedUpdateManyInput
    >;
    /**
     * Filter which ServiceLoadingOrders to update
     */
    where?: ServiceLoadingOrderWhereInput;
    /**
     * Limit how many ServiceLoadingOrders to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ServiceLoadingOrder upsert
   */
  export type ServiceLoadingOrderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * The filter to search for the ServiceLoadingOrder to update in case it exists.
     */
    where: ServiceLoadingOrderWhereUniqueInput;
    /**
     * In case the ServiceLoadingOrder found by the `where` argument doesn't exist, create a new ServiceLoadingOrder with this data.
     */
    create: XOR<ServiceLoadingOrderCreateInput, ServiceLoadingOrderUncheckedCreateInput>;
    /**
     * In case the ServiceLoadingOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceLoadingOrderUpdateInput, ServiceLoadingOrderUncheckedUpdateInput>;
  };

  /**
   * ServiceLoadingOrder delete
   */
  export type ServiceLoadingOrderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
    /**
     * Filter which ServiceLoadingOrder to delete.
     */
    where: ServiceLoadingOrderWhereUniqueInput;
  };

  /**
   * ServiceLoadingOrder deleteMany
   */
  export type ServiceLoadingOrderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceLoadingOrders to delete
     */
    where?: ServiceLoadingOrderWhereInput;
    /**
     * Limit how many ServiceLoadingOrders to delete.
     */
    limit?: number;
  };

  /**
   * ServiceLoadingOrder without action
   */
  export type ServiceLoadingOrderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceLoadingOrder
     */
    select?: ServiceLoadingOrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceLoadingOrder
     */
    omit?: ServiceLoadingOrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceLoadingOrderInclude<ExtArgs> | null;
  };

  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null;
    _avg: InvoiceAvgAggregateOutputType | null;
    _sum: InvoiceSumAggregateOutputType | null;
    _min: InvoiceMinAggregateOutputType | null;
    _max: InvoiceMaxAggregateOutputType | null;
  };

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null;
    taxAmount: Decimal | null;
    totalAmount: Decimal | null;
    paidAmount: Decimal | null;
    irpfRate: Decimal | null;
    irpfAmount: Decimal | null;
  };

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null;
    taxAmount: Decimal | null;
    totalAmount: Decimal | null;
    paidAmount: Decimal | null;
    irpfRate: Decimal | null;
    irpfAmount: Decimal | null;
  };

  export type InvoiceMinAggregateOutputType = {
    id: string | null;
    invoiceNumber: string | null;
    invoiceDate: Date | null;
    dueDate: Date | null;
    supplierId: string | null;
    createdById: string | null;
    subtotal: Decimal | null;
    taxAmount: Decimal | null;
    totalAmount: Decimal | null;
    currency: string | null;
    status: $Enums.InvoiceStatus | null;
    paymentStatus: $Enums.PaymentStatus | null;
    paidAmount: Decimal | null;
    paidAt: Date | null;
    paymentMethod: string | null;
    paymentReference: string | null;
    irpfRate: Decimal | null;
    irpfAmount: Decimal | null;
    description: string | null;
    notes: string | null;
    termsConditions: string | null;
    pdfPath: string | null;
    pdfGeneratedAt: Date | null;
    sentAt: Date | null;
    sentTo: string | null;
    viewedAt: Date | null;
    reminderSentAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type InvoiceMaxAggregateOutputType = {
    id: string | null;
    invoiceNumber: string | null;
    invoiceDate: Date | null;
    dueDate: Date | null;
    supplierId: string | null;
    createdById: string | null;
    subtotal: Decimal | null;
    taxAmount: Decimal | null;
    totalAmount: Decimal | null;
    currency: string | null;
    status: $Enums.InvoiceStatus | null;
    paymentStatus: $Enums.PaymentStatus | null;
    paidAmount: Decimal | null;
    paidAt: Date | null;
    paymentMethod: string | null;
    paymentReference: string | null;
    irpfRate: Decimal | null;
    irpfAmount: Decimal | null;
    description: string | null;
    notes: string | null;
    termsConditions: string | null;
    pdfPath: string | null;
    pdfGeneratedAt: Date | null;
    sentAt: Date | null;
    sentTo: string | null;
    viewedAt: Date | null;
    reminderSentAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type InvoiceCountAggregateOutputType = {
    id: number;
    invoiceNumber: number;
    invoiceDate: number;
    dueDate: number;
    supplierId: number;
    createdById: number;
    subtotal: number;
    taxAmount: number;
    totalAmount: number;
    currency: number;
    status: number;
    paymentStatus: number;
    paidAmount: number;
    paidAt: number;
    paymentMethod: number;
    paymentReference: number;
    irpfRate: number;
    irpfAmount: number;
    description: number;
    notes: number;
    termsConditions: number;
    pdfPath: number;
    pdfGeneratedAt: number;
    sentAt: number;
    sentTo: number;
    viewedAt: number;
    reminderSentAt: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type InvoiceAvgAggregateInputType = {
    subtotal?: true;
    taxAmount?: true;
    totalAmount?: true;
    paidAmount?: true;
    irpfRate?: true;
    irpfAmount?: true;
  };

  export type InvoiceSumAggregateInputType = {
    subtotal?: true;
    taxAmount?: true;
    totalAmount?: true;
    paidAmount?: true;
    irpfRate?: true;
    irpfAmount?: true;
  };

  export type InvoiceMinAggregateInputType = {
    id?: true;
    invoiceNumber?: true;
    invoiceDate?: true;
    dueDate?: true;
    supplierId?: true;
    createdById?: true;
    subtotal?: true;
    taxAmount?: true;
    totalAmount?: true;
    currency?: true;
    status?: true;
    paymentStatus?: true;
    paidAmount?: true;
    paidAt?: true;
    paymentMethod?: true;
    paymentReference?: true;
    irpfRate?: true;
    irpfAmount?: true;
    description?: true;
    notes?: true;
    termsConditions?: true;
    pdfPath?: true;
    pdfGeneratedAt?: true;
    sentAt?: true;
    sentTo?: true;
    viewedAt?: true;
    reminderSentAt?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type InvoiceMaxAggregateInputType = {
    id?: true;
    invoiceNumber?: true;
    invoiceDate?: true;
    dueDate?: true;
    supplierId?: true;
    createdById?: true;
    subtotal?: true;
    taxAmount?: true;
    totalAmount?: true;
    currency?: true;
    status?: true;
    paymentStatus?: true;
    paidAmount?: true;
    paidAt?: true;
    paymentMethod?: true;
    paymentReference?: true;
    irpfRate?: true;
    irpfAmount?: true;
    description?: true;
    notes?: true;
    termsConditions?: true;
    pdfPath?: true;
    pdfGeneratedAt?: true;
    sentAt?: true;
    sentTo?: true;
    viewedAt?: true;
    reminderSentAt?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type InvoiceCountAggregateInputType = {
    id?: true;
    invoiceNumber?: true;
    invoiceDate?: true;
    dueDate?: true;
    supplierId?: true;
    createdById?: true;
    subtotal?: true;
    taxAmount?: true;
    totalAmount?: true;
    currency?: true;
    status?: true;
    paymentStatus?: true;
    paidAmount?: true;
    paidAt?: true;
    paymentMethod?: true;
    paymentReference?: true;
    irpfRate?: true;
    irpfAmount?: true;
    description?: true;
    notes?: true;
    termsConditions?: true;
    pdfPath?: true;
    pdfGeneratedAt?: true;
    sentAt?: true;
    sentTo?: true;
    viewedAt?: true;
    reminderSentAt?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type InvoiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Invoices
     **/
    _count?: true | InvoiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: InvoiceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: InvoiceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InvoiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InvoiceMaxAggregateInputType;
  };

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
    [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>;
  };

  export type InvoiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[];
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum;
    having?: InvoiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InvoiceCountAggregateInputType | true;
    _avg?: InvoiceAvgAggregateInputType;
    _sum?: InvoiceSumAggregateInputType;
    _min?: InvoiceMinAggregateInputType;
    _max?: InvoiceMaxAggregateInputType;
  };

  export type InvoiceGroupByOutputType = {
    id: string;
    invoiceNumber: string;
    invoiceDate: Date;
    dueDate: Date;
    supplierId: string;
    createdById: string;
    subtotal: Decimal;
    taxAmount: Decimal;
    totalAmount: Decimal;
    currency: string;
    status: $Enums.InvoiceStatus;
    paymentStatus: $Enums.PaymentStatus;
    paidAmount: Decimal;
    paidAt: Date | null;
    paymentMethod: string | null;
    paymentReference: string | null;
    irpfRate: Decimal | null;
    irpfAmount: Decimal | null;
    description: string | null;
    notes: string | null;
    termsConditions: string | null;
    pdfPath: string | null;
    pdfGeneratedAt: Date | null;
    sentAt: Date | null;
    sentTo: string | null;
    viewedAt: Date | null;
    reminderSentAt: Date | null;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: InvoiceCountAggregateOutputType | null;
    _avg: InvoiceAvgAggregateOutputType | null;
    _sum: InvoiceSumAggregateOutputType | null;
    _min: InvoiceMinAggregateOutputType | null;
    _max: InvoiceMaxAggregateOutputType | null;
  };

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> & {
        [P in keyof T & keyof InvoiceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
          : GetScalarType<T[P], InvoiceGroupByOutputType[P]>;
      }
    >
  >;

  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        invoiceNumber?: boolean;
        invoiceDate?: boolean;
        dueDate?: boolean;
        supplierId?: boolean;
        createdById?: boolean;
        subtotal?: boolean;
        taxAmount?: boolean;
        totalAmount?: boolean;
        currency?: boolean;
        status?: boolean;
        paymentStatus?: boolean;
        paidAmount?: boolean;
        paidAt?: boolean;
        paymentMethod?: boolean;
        paymentReference?: boolean;
        irpfRate?: boolean;
        irpfAmount?: boolean;
        description?: boolean;
        notes?: boolean;
        termsConditions?: boolean;
        pdfPath?: boolean;
        pdfGeneratedAt?: boolean;
        sentAt?: boolean;
        sentTo?: boolean;
        viewedAt?: boolean;
        reminderSentAt?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
        items?: boolean | Invoice$itemsArgs<ExtArgs>;
        payments?: boolean | Invoice$paymentsArgs<ExtArgs>;
        _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['invoice']
    >;

  export type InvoiceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      invoiceNumber?: boolean;
      invoiceDate?: boolean;
      dueDate?: boolean;
      supplierId?: boolean;
      createdById?: boolean;
      subtotal?: boolean;
      taxAmount?: boolean;
      totalAmount?: boolean;
      currency?: boolean;
      status?: boolean;
      paymentStatus?: boolean;
      paidAmount?: boolean;
      paidAt?: boolean;
      paymentMethod?: boolean;
      paymentReference?: boolean;
      irpfRate?: boolean;
      irpfAmount?: boolean;
      description?: boolean;
      notes?: boolean;
      termsConditions?: boolean;
      pdfPath?: boolean;
      pdfGeneratedAt?: boolean;
      sentAt?: boolean;
      sentTo?: boolean;
      viewedAt?: boolean;
      reminderSentAt?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['invoice']
  >;

  export type InvoiceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      invoiceNumber?: boolean;
      invoiceDate?: boolean;
      dueDate?: boolean;
      supplierId?: boolean;
      createdById?: boolean;
      subtotal?: boolean;
      taxAmount?: boolean;
      totalAmount?: boolean;
      currency?: boolean;
      status?: boolean;
      paymentStatus?: boolean;
      paidAmount?: boolean;
      paidAt?: boolean;
      paymentMethod?: boolean;
      paymentReference?: boolean;
      irpfRate?: boolean;
      irpfAmount?: boolean;
      description?: boolean;
      notes?: boolean;
      termsConditions?: boolean;
      pdfPath?: boolean;
      pdfGeneratedAt?: boolean;
      sentAt?: boolean;
      sentTo?: boolean;
      viewedAt?: boolean;
      reminderSentAt?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['invoice']
  >;

  export type InvoiceSelectScalar = {
    id?: boolean;
    invoiceNumber?: boolean;
    invoiceDate?: boolean;
    dueDate?: boolean;
    supplierId?: boolean;
    createdById?: boolean;
    subtotal?: boolean;
    taxAmount?: boolean;
    totalAmount?: boolean;
    currency?: boolean;
    status?: boolean;
    paymentStatus?: boolean;
    paidAmount?: boolean;
    paidAt?: boolean;
    paymentMethod?: boolean;
    paymentReference?: boolean;
    irpfRate?: boolean;
    irpfAmount?: boolean;
    description?: boolean;
    notes?: boolean;
    termsConditions?: boolean;
    pdfPath?: boolean;
    pdfGeneratedAt?: boolean;
    sentAt?: boolean;
    sentTo?: boolean;
    viewedAt?: boolean;
    reminderSentAt?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'invoiceNumber'
      | 'invoiceDate'
      | 'dueDate'
      | 'supplierId'
      | 'createdById'
      | 'subtotal'
      | 'taxAmount'
      | 'totalAmount'
      | 'currency'
      | 'status'
      | 'paymentStatus'
      | 'paidAmount'
      | 'paidAt'
      | 'paymentMethod'
      | 'paymentReference'
      | 'irpfRate'
      | 'irpfAmount'
      | 'description'
      | 'notes'
      | 'termsConditions'
      | 'pdfPath'
      | 'pdfGeneratedAt'
      | 'sentAt'
      | 'sentTo'
      | 'viewedAt'
      | 'reminderSentAt'
      | 'metadata'
      | 'createdAt'
      | 'updatedAt'
      | 'deletedAt',
      ExtArgs['result']['invoice']
    >;
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    items?: boolean | Invoice$itemsArgs<ExtArgs>;
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>;
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type InvoiceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type InvoiceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Invoice';
      objects: {
        supplier: Prisma.$SupplierPayload<ExtArgs>;
        createdBy: Prisma.$UserPayload<ExtArgs>;
        items: Prisma.$InvoiceItemPayload<ExtArgs>[];
        payments: Prisma.$PaymentPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          invoiceNumber: string;
          invoiceDate: Date;
          dueDate: Date;
          supplierId: string;
          createdById: string;
          subtotal: Prisma.Decimal;
          taxAmount: Prisma.Decimal;
          totalAmount: Prisma.Decimal;
          currency: string;
          status: $Enums.InvoiceStatus;
          paymentStatus: $Enums.PaymentStatus;
          paidAmount: Prisma.Decimal;
          paidAt: Date | null;
          paymentMethod: string | null;
          paymentReference: string | null;
          irpfRate: Prisma.Decimal | null;
          irpfAmount: Prisma.Decimal | null;
          description: string | null;
          notes: string | null;
          termsConditions: string | null;
          pdfPath: string | null;
          pdfGeneratedAt: Date | null;
          sentAt: Date | null;
          sentTo: string | null;
          viewedAt: Date | null;
          reminderSentAt: Date | null;
          metadata: Prisma.JsonValue | null;
          createdAt: Date;
          updatedAt: Date;
          deletedAt: Date | null;
        },
        ExtArgs['result']['invoice']
      >;
      composites: {};
    };

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> =
    $Result.GetResult<Prisma.$InvoicePayload, S>;

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    InvoiceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: InvoiceCountAggregateInputType | true;
  };

  export interface InvoiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice']; meta: { name: 'Invoice' } };
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(
      args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(
      args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     *
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     *
     */
    findMany<T extends InvoiceFindManyArgs>(
      args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     *
     */
    create<T extends InvoiceCreateArgs>(
      args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends InvoiceCreateManyArgs>(
      args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InvoicePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     *
     */
    delete<T extends InvoiceDeleteArgs>(
      args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends InvoiceUpdateArgs>(
      args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends InvoiceUpdateManyArgs>(
      args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InvoicePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(
      args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
     **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InvoiceAggregateArgs>(
      args: Subset<T, InvoiceAggregateArgs>
    ): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>;

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Invoice model
     */
    readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SupplierDefaultArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      | $Result.GetResult<
          Prisma.$SupplierPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Invoice$itemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<'Invoice', 'String'>;
    readonly invoiceNumber: FieldRef<'Invoice', 'String'>;
    readonly invoiceDate: FieldRef<'Invoice', 'DateTime'>;
    readonly dueDate: FieldRef<'Invoice', 'DateTime'>;
    readonly supplierId: FieldRef<'Invoice', 'String'>;
    readonly createdById: FieldRef<'Invoice', 'String'>;
    readonly subtotal: FieldRef<'Invoice', 'Decimal'>;
    readonly taxAmount: FieldRef<'Invoice', 'Decimal'>;
    readonly totalAmount: FieldRef<'Invoice', 'Decimal'>;
    readonly currency: FieldRef<'Invoice', 'String'>;
    readonly status: FieldRef<'Invoice', 'InvoiceStatus'>;
    readonly paymentStatus: FieldRef<'Invoice', 'PaymentStatus'>;
    readonly paidAmount: FieldRef<'Invoice', 'Decimal'>;
    readonly paidAt: FieldRef<'Invoice', 'DateTime'>;
    readonly paymentMethod: FieldRef<'Invoice', 'String'>;
    readonly paymentReference: FieldRef<'Invoice', 'String'>;
    readonly irpfRate: FieldRef<'Invoice', 'Decimal'>;
    readonly irpfAmount: FieldRef<'Invoice', 'Decimal'>;
    readonly description: FieldRef<'Invoice', 'String'>;
    readonly notes: FieldRef<'Invoice', 'String'>;
    readonly termsConditions: FieldRef<'Invoice', 'String'>;
    readonly pdfPath: FieldRef<'Invoice', 'String'>;
    readonly pdfGeneratedAt: FieldRef<'Invoice', 'DateTime'>;
    readonly sentAt: FieldRef<'Invoice', 'DateTime'>;
    readonly sentTo: FieldRef<'Invoice', 'String'>;
    readonly viewedAt: FieldRef<'Invoice', 'DateTime'>;
    readonly reminderSentAt: FieldRef<'Invoice', 'DateTime'>;
    readonly metadata: FieldRef<'Invoice', 'Json'>;
    readonly createdAt: FieldRef<'Invoice', 'DateTime'>;
    readonly updatedAt: FieldRef<'Invoice', 'DateTime'>;
    readonly deletedAt: FieldRef<'Invoice', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput;
  };

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput;
  };

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>;
  };

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>;
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput;
  };

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>;
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput;
    /**
     * Limit how many Invoices to update.
     */
    limit?: number;
  };

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>;
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput;
    /**
     * Limit how many Invoices to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput;
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>;
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>;
  };

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput;
  };

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput;
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number;
  };

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    where?: InvoiceItemWhereInput;
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[];
    cursor?: InvoiceItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[];
  };

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    cursor?: PaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
  };

  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null;
    _avg: InvoiceItemAvgAggregateOutputType | null;
    _sum: InvoiceItemSumAggregateOutputType | null;
    _min: InvoiceItemMinAggregateOutputType | null;
    _max: InvoiceItemMaxAggregateOutputType | null;
  };

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: Decimal | null;
    unitPrice: Decimal | null;
    amount: Decimal | null;
    taxRate: Decimal | null;
    taxAmount: Decimal | null;
  };

  export type InvoiceItemSumAggregateOutputType = {
    quantity: Decimal | null;
    unitPrice: Decimal | null;
    amount: Decimal | null;
    taxRate: Decimal | null;
    taxAmount: Decimal | null;
  };

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null;
    invoiceId: string | null;
    serviceId: string | null;
    description: string | null;
    quantity: Decimal | null;
    unitPrice: Decimal | null;
    amount: Decimal | null;
    taxRate: Decimal | null;
    taxAmount: Decimal | null;
  };

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null;
    invoiceId: string | null;
    serviceId: string | null;
    description: string | null;
    quantity: Decimal | null;
    unitPrice: Decimal | null;
    amount: Decimal | null;
    taxRate: Decimal | null;
    taxAmount: Decimal | null;
  };

  export type InvoiceItemCountAggregateOutputType = {
    id: number;
    invoiceId: number;
    serviceId: number;
    description: number;
    quantity: number;
    unitPrice: number;
    amount: number;
    taxRate: number;
    taxAmount: number;
    _all: number;
  };

  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true;
    unitPrice?: true;
    amount?: true;
    taxRate?: true;
    taxAmount?: true;
  };

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true;
    unitPrice?: true;
    amount?: true;
    taxRate?: true;
    taxAmount?: true;
  };

  export type InvoiceItemMinAggregateInputType = {
    id?: true;
    invoiceId?: true;
    serviceId?: true;
    description?: true;
    quantity?: true;
    unitPrice?: true;
    amount?: true;
    taxRate?: true;
    taxAmount?: true;
  };

  export type InvoiceItemMaxAggregateInputType = {
    id?: true;
    invoiceId?: true;
    serviceId?: true;
    description?: true;
    quantity?: true;
    unitPrice?: true;
    amount?: true;
    taxRate?: true;
    taxAmount?: true;
  };

  export type InvoiceItemCountAggregateInputType = {
    id?: true;
    invoiceId?: true;
    serviceId?: true;
    description?: true;
    quantity?: true;
    unitPrice?: true;
    amount?: true;
    taxRate?: true;
    taxAmount?: true;
    _all?: true;
  };

  export type InvoiceItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InvoiceItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned InvoiceItems
     **/
    _count?: true | InvoiceItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: InvoiceItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: InvoiceItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InvoiceItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InvoiceItemMaxAggregateInputType;
  };

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
    [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>;
  };

  export type InvoiceItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvoiceItemWhereInput;
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[];
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum;
    having?: InvoiceItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InvoiceItemCountAggregateInputType | true;
    _avg?: InvoiceItemAvgAggregateInputType;
    _sum?: InvoiceItemSumAggregateInputType;
    _min?: InvoiceItemMinAggregateInputType;
    _max?: InvoiceItemMaxAggregateInputType;
  };

  export type InvoiceItemGroupByOutputType = {
    id: string;
    invoiceId: string;
    serviceId: string | null;
    description: string;
    quantity: Decimal;
    unitPrice: Decimal;
    amount: Decimal;
    taxRate: Decimal;
    taxAmount: Decimal;
    _count: InvoiceItemCountAggregateOutputType | null;
    _avg: InvoiceItemAvgAggregateOutputType | null;
    _sum: InvoiceItemSumAggregateOutputType | null;
    _min: InvoiceItemMinAggregateOutputType | null;
    _max: InvoiceItemMaxAggregateOutputType | null;
  };

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> & {
        [P in keyof T & keyof InvoiceItemGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
          : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>;
      }
    >
  >;

  export type InvoiceItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      invoiceId?: boolean;
      serviceId?: boolean;
      description?: boolean;
      quantity?: boolean;
      unitPrice?: boolean;
      amount?: boolean;
      taxRate?: boolean;
      taxAmount?: boolean;
      invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
      service?: boolean | InvoiceItem$serviceArgs<ExtArgs>;
    },
    ExtArgs['result']['invoiceItem']
  >;

  export type InvoiceItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      invoiceId?: boolean;
      serviceId?: boolean;
      description?: boolean;
      quantity?: boolean;
      unitPrice?: boolean;
      amount?: boolean;
      taxRate?: boolean;
      taxAmount?: boolean;
      invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
      service?: boolean | InvoiceItem$serviceArgs<ExtArgs>;
    },
    ExtArgs['result']['invoiceItem']
  >;

  export type InvoiceItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      invoiceId?: boolean;
      serviceId?: boolean;
      description?: boolean;
      quantity?: boolean;
      unitPrice?: boolean;
      amount?: boolean;
      taxRate?: boolean;
      taxAmount?: boolean;
      invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
      service?: boolean | InvoiceItem$serviceArgs<ExtArgs>;
    },
    ExtArgs['result']['invoiceItem']
  >;

  export type InvoiceItemSelectScalar = {
    id?: boolean;
    invoiceId?: boolean;
    serviceId?: boolean;
    description?: boolean;
    quantity?: boolean;
    unitPrice?: boolean;
    amount?: boolean;
    taxRate?: boolean;
    taxAmount?: boolean;
  };

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'invoiceId'
      | 'serviceId'
      | 'description'
      | 'quantity'
      | 'unitPrice'
      | 'amount'
      | 'taxRate'
      | 'taxAmount',
      ExtArgs['result']['invoiceItem']
    >;
  export type InvoiceItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>;
  };
  export type InvoiceItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>;
  };
  export type InvoiceItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>;
  };

  export type $InvoiceItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'InvoiceItem';
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>;
      service: Prisma.$ServicePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        invoiceId: string;
        serviceId: string | null;
        description: string;
        quantity: Prisma.Decimal;
        unitPrice: Prisma.Decimal;
        amount: Prisma.Decimal;
        taxRate: Prisma.Decimal;
        taxAmount: Prisma.Decimal;
      },
      ExtArgs['result']['invoiceItem']
    >;
    composites: {};
  };

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> =
    $Result.GetResult<Prisma.$InvoiceItemPayload, S>;

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true;
    };

  export interface InvoiceItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'];
      meta: { name: 'InvoiceItem' };
    };
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(
      args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<
      $Result.GetResult<
        Prisma.$InvoiceItemPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<
      $Result.GetResult<
        Prisma.$InvoiceItemPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(
      args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<
      $Result.GetResult<
        Prisma.$InvoiceItemPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<
      $Result.GetResult<
        Prisma.$InvoiceItemPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     *
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends InvoiceItemFindManyArgs>(
      args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     *
     */
    create<T extends InvoiceItemCreateArgs>(
      args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<
      $Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends InvoiceItemCreateManyArgs>(
      args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InvoiceItemPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     *
     */
    delete<T extends InvoiceItemDeleteArgs>(
      args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<
      $Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends InvoiceItemUpdateArgs>(
      args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<
      $Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(
      args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(
      args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InvoiceItemPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(
      args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceItemClient<
      $Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
     **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InvoiceItemAggregateArgs>(
      args: Subset<T, InvoiceItemAggregateArgs>
    ): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>;

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the InvoiceItem model
     */
    readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      | $Result.GetResult<
          Prisma.$InvoicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends InvoiceItem$serviceArgs<ExtArgs> = {}>(
      args?: Subset<T, InvoiceItem$serviceArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<'InvoiceItem', 'String'>;
    readonly invoiceId: FieldRef<'InvoiceItem', 'String'>;
    readonly serviceId: FieldRef<'InvoiceItem', 'String'>;
    readonly description: FieldRef<'InvoiceItem', 'String'>;
    readonly quantity: FieldRef<'InvoiceItem', 'Decimal'>;
    readonly unitPrice: FieldRef<'InvoiceItem', 'Decimal'>;
    readonly amount: FieldRef<'InvoiceItem', 'Decimal'>;
    readonly taxRate: FieldRef<'InvoiceItem', 'Decimal'>;
    readonly taxAmount: FieldRef<'InvoiceItem', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput;
  };

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput;
  };

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InvoiceItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[];
  };

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InvoiceItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[];
  };

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InvoiceItems.
     */
    skip?: number;
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[];
  };

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>;
  };

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>;
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput;
  };

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>;
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput;
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number;
  };

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>;
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput;
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput;
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>;
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>;
  };

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput;
  };

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput;
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number;
  };

  /**
   * InvoiceItem.service
   */
  export type InvoiceItem$serviceArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
  };

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null;
  };

  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null;
  };

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null;
  };

  export type PaymentMinAggregateOutputType = {
    id: string | null;
    paymentNumber: string | null;
    invoiceId: string | null;
    amount: Decimal | null;
    currency: string | null;
    paymentDate: Date | null;
    paymentMethod: string | null;
    reference: string | null;
    status: $Enums.PaymentStatus | null;
    notes: string | null;
    receiptPath: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PaymentMaxAggregateOutputType = {
    id: string | null;
    paymentNumber: string | null;
    invoiceId: string | null;
    amount: Decimal | null;
    currency: string | null;
    paymentDate: Date | null;
    paymentMethod: string | null;
    reference: string | null;
    status: $Enums.PaymentStatus | null;
    notes: string | null;
    receiptPath: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PaymentCountAggregateOutputType = {
    id: number;
    paymentNumber: number;
    invoiceId: number;
    amount: number;
    currency: number;
    paymentDate: number;
    paymentMethod: number;
    reference: number;
    status: number;
    notes: number;
    receiptPath: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PaymentAvgAggregateInputType = {
    amount?: true;
  };

  export type PaymentSumAggregateInputType = {
    amount?: true;
  };

  export type PaymentMinAggregateInputType = {
    id?: true;
    paymentNumber?: true;
    invoiceId?: true;
    amount?: true;
    currency?: true;
    paymentDate?: true;
    paymentMethod?: true;
    reference?: true;
    status?: true;
    notes?: true;
    receiptPath?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PaymentMaxAggregateInputType = {
    id?: true;
    paymentNumber?: true;
    invoiceId?: true;
    amount?: true;
    currency?: true;
    paymentDate?: true;
    paymentMethod?: true;
    reference?: true;
    status?: true;
    notes?: true;
    receiptPath?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PaymentCountAggregateInputType = {
    id?: true;
    paymentNumber?: true;
    invoiceId?: true;
    amount?: true;
    currency?: true;
    paymentDate?: true;
    paymentMethod?: true;
    reference?: true;
    status?: true;
    notes?: true;
    receiptPath?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PaymentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Payments
     **/
    _count?: true | PaymentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaymentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaymentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaymentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaymentMaxAggregateInputType;
  };

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>;
  };

  export type PaymentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[];
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum;
    having?: PaymentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaymentCountAggregateInputType | true;
    _avg?: PaymentAvgAggregateInputType;
    _sum?: PaymentSumAggregateInputType;
    _min?: PaymentMinAggregateInputType;
    _max?: PaymentMaxAggregateInputType;
  };

  export type PaymentGroupByOutputType = {
    id: string;
    paymentNumber: string;
    invoiceId: string;
    amount: Decimal;
    currency: string;
    paymentDate: Date;
    paymentMethod: string;
    reference: string | null;
    status: $Enums.PaymentStatus;
    notes: string | null;
    receiptPath: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PaymentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
          : GetScalarType<T[P], PaymentGroupByOutputType[P]>;
      }
    >
  >;

  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        paymentNumber?: boolean;
        invoiceId?: boolean;
        amount?: boolean;
        currency?: boolean;
        paymentDate?: boolean;
        paymentMethod?: boolean;
        reference?: boolean;
        status?: boolean;
        notes?: boolean;
        receiptPath?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['payment']
    >;

  export type PaymentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paymentNumber?: boolean;
      invoiceId?: boolean;
      amount?: boolean;
      currency?: boolean;
      paymentDate?: boolean;
      paymentMethod?: boolean;
      reference?: boolean;
      status?: boolean;
      notes?: boolean;
      receiptPath?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['payment']
  >;

  export type PaymentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paymentNumber?: boolean;
      invoiceId?: boolean;
      amount?: boolean;
      currency?: boolean;
      paymentDate?: boolean;
      paymentMethod?: boolean;
      reference?: boolean;
      status?: boolean;
      notes?: boolean;
      receiptPath?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['payment']
  >;

  export type PaymentSelectScalar = {
    id?: boolean;
    paymentNumber?: boolean;
    invoiceId?: boolean;
    amount?: boolean;
    currency?: boolean;
    paymentDate?: boolean;
    paymentMethod?: boolean;
    reference?: boolean;
    status?: boolean;
    notes?: boolean;
    receiptPath?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'paymentNumber'
      | 'invoiceId'
      | 'amount'
      | 'currency'
      | 'paymentDate'
      | 'paymentMethod'
      | 'reference'
      | 'status'
      | 'notes'
      | 'receiptPath'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['payment']
    >;
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
  };
  export type PaymentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
  };
  export type PaymentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>;
  };

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Payment';
      objects: {
        invoice: Prisma.$InvoicePayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          paymentNumber: string;
          invoiceId: string;
          amount: Prisma.Decimal;
          currency: string;
          paymentDate: Date;
          paymentMethod: string;
          reference: string | null;
          status: $Enums.PaymentStatus;
          notes: string | null;
          receiptPath: string | null;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['payment']
      >;
      composites: {};
    };

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> =
    $Result.GetResult<Prisma.$PaymentPayload, S>;

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    PaymentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PaymentCountAggregateInputType | true;
  };

  export interface PaymentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment']; meta: { name: 'Payment' } };
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     *
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     *
     */
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     *
     */
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
     **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaymentAggregateArgs>(
      args: Subset<T, PaymentAggregateArgs>
    ): Prisma.PrismaPromise<GetPaymentAggregateType<T>>;

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Payment model
     */
    readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      | $Result.GetResult<
          Prisma.$InvoicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<'Payment', 'String'>;
    readonly paymentNumber: FieldRef<'Payment', 'String'>;
    readonly invoiceId: FieldRef<'Payment', 'String'>;
    readonly amount: FieldRef<'Payment', 'Decimal'>;
    readonly currency: FieldRef<'Payment', 'String'>;
    readonly paymentDate: FieldRef<'Payment', 'DateTime'>;
    readonly paymentMethod: FieldRef<'Payment', 'String'>;
    readonly reference: FieldRef<'Payment', 'String'>;
    readonly status: FieldRef<'Payment', 'PaymentStatus'>;
    readonly notes: FieldRef<'Payment', 'String'>;
    readonly receiptPath: FieldRef<'Payment', 'String'>;
    readonly createdAt: FieldRef<'Payment', 'DateTime'>;
    readonly updatedAt: FieldRef<'Payment', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment create
   */
  export type PaymentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
  };

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to update.
     */
    limit?: number;
  };

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput;
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
  };

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to delete.
     */
    limit?: number;
  };

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
  };

  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null;
    _avg: DocumentAvgAggregateOutputType | null;
    _sum: DocumentSumAggregateOutputType | null;
    _min: DocumentMinAggregateOutputType | null;
    _max: DocumentMaxAggregateOutputType | null;
  };

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null;
  };

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null;
  };

  export type DocumentMinAggregateOutputType = {
    id: string | null;
    documentType: $Enums.DocumentType | null;
    documentNumber: string | null;
    clientId: string | null;
    supplierId: string | null;
    serviceId: string | null;
    fileName: string | null;
    filePath: string | null;
    fileSize: number | null;
    mimeType: string | null;
    description: string | null;
    uploadedBy: string | null;
    uploadedAt: Date | null;
    deletedAt: Date | null;
  };

  export type DocumentMaxAggregateOutputType = {
    id: string | null;
    documentType: $Enums.DocumentType | null;
    documentNumber: string | null;
    clientId: string | null;
    supplierId: string | null;
    serviceId: string | null;
    fileName: string | null;
    filePath: string | null;
    fileSize: number | null;
    mimeType: string | null;
    description: string | null;
    uploadedBy: string | null;
    uploadedAt: Date | null;
    deletedAt: Date | null;
  };

  export type DocumentCountAggregateOutputType = {
    id: number;
    documentType: number;
    documentNumber: number;
    clientId: number;
    supplierId: number;
    serviceId: number;
    fileName: number;
    filePath: number;
    fileSize: number;
    mimeType: number;
    description: number;
    tags: number;
    metadata: number;
    uploadedBy: number;
    uploadedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type DocumentAvgAggregateInputType = {
    fileSize?: true;
  };

  export type DocumentSumAggregateInputType = {
    fileSize?: true;
  };

  export type DocumentMinAggregateInputType = {
    id?: true;
    documentType?: true;
    documentNumber?: true;
    clientId?: true;
    supplierId?: true;
    serviceId?: true;
    fileName?: true;
    filePath?: true;
    fileSize?: true;
    mimeType?: true;
    description?: true;
    uploadedBy?: true;
    uploadedAt?: true;
    deletedAt?: true;
  };

  export type DocumentMaxAggregateInputType = {
    id?: true;
    documentType?: true;
    documentNumber?: true;
    clientId?: true;
    supplierId?: true;
    serviceId?: true;
    fileName?: true;
    filePath?: true;
    fileSize?: true;
    mimeType?: true;
    description?: true;
    uploadedBy?: true;
    uploadedAt?: true;
    deletedAt?: true;
  };

  export type DocumentCountAggregateInputType = {
    id?: true;
    documentType?: true;
    documentNumber?: true;
    clientId?: true;
    supplierId?: true;
    serviceId?: true;
    fileName?: true;
    filePath?: true;
    fileSize?: true;
    mimeType?: true;
    description?: true;
    tags?: true;
    metadata?: true;
    uploadedBy?: true;
    uploadedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type DocumentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Documents
     **/
    _count?: true | DocumentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DocumentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DocumentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DocumentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DocumentMaxAggregateInputType;
  };

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
    [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>;
  };

  export type DocumentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[];
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum;
    having?: DocumentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DocumentCountAggregateInputType | true;
    _avg?: DocumentAvgAggregateInputType;
    _sum?: DocumentSumAggregateInputType;
    _min?: DocumentMinAggregateInputType;
    _max?: DocumentMaxAggregateInputType;
  };

  export type DocumentGroupByOutputType = {
    id: string;
    documentType: $Enums.DocumentType;
    documentNumber: string | null;
    clientId: string | null;
    supplierId: string | null;
    serviceId: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description: string | null;
    tags: string[];
    metadata: JsonValue | null;
    uploadedBy: string;
    uploadedAt: Date;
    deletedAt: Date | null;
    _count: DocumentCountAggregateOutputType | null;
    _avg: DocumentAvgAggregateOutputType | null;
    _sum: DocumentSumAggregateOutputType | null;
    _min: DocumentMinAggregateOutputType | null;
    _max: DocumentMaxAggregateOutputType | null;
  };

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof DocumentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
          : GetScalarType<T[P], DocumentGroupByOutputType[P]>;
      }
    >
  >;

  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        documentType?: boolean;
        documentNumber?: boolean;
        clientId?: boolean;
        supplierId?: boolean;
        serviceId?: boolean;
        fileName?: boolean;
        filePath?: boolean;
        fileSize?: boolean;
        mimeType?: boolean;
        description?: boolean;
        tags?: boolean;
        metadata?: boolean;
        uploadedBy?: boolean;
        uploadedAt?: boolean;
        deletedAt?: boolean;
        client?: boolean | Document$clientArgs<ExtArgs>;
        supplier?: boolean | Document$supplierArgs<ExtArgs>;
        service?: boolean | Document$serviceArgs<ExtArgs>;
      },
      ExtArgs['result']['document']
    >;

  export type DocumentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      documentType?: boolean;
      documentNumber?: boolean;
      clientId?: boolean;
      supplierId?: boolean;
      serviceId?: boolean;
      fileName?: boolean;
      filePath?: boolean;
      fileSize?: boolean;
      mimeType?: boolean;
      description?: boolean;
      tags?: boolean;
      metadata?: boolean;
      uploadedBy?: boolean;
      uploadedAt?: boolean;
      deletedAt?: boolean;
      client?: boolean | Document$clientArgs<ExtArgs>;
      supplier?: boolean | Document$supplierArgs<ExtArgs>;
      service?: boolean | Document$serviceArgs<ExtArgs>;
    },
    ExtArgs['result']['document']
  >;

  export type DocumentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      documentType?: boolean;
      documentNumber?: boolean;
      clientId?: boolean;
      supplierId?: boolean;
      serviceId?: boolean;
      fileName?: boolean;
      filePath?: boolean;
      fileSize?: boolean;
      mimeType?: boolean;
      description?: boolean;
      tags?: boolean;
      metadata?: boolean;
      uploadedBy?: boolean;
      uploadedAt?: boolean;
      deletedAt?: boolean;
      client?: boolean | Document$clientArgs<ExtArgs>;
      supplier?: boolean | Document$supplierArgs<ExtArgs>;
      service?: boolean | Document$serviceArgs<ExtArgs>;
    },
    ExtArgs['result']['document']
  >;

  export type DocumentSelectScalar = {
    id?: boolean;
    documentType?: boolean;
    documentNumber?: boolean;
    clientId?: boolean;
    supplierId?: boolean;
    serviceId?: boolean;
    fileName?: boolean;
    filePath?: boolean;
    fileSize?: boolean;
    mimeType?: boolean;
    description?: boolean;
    tags?: boolean;
    metadata?: boolean;
    uploadedBy?: boolean;
    uploadedAt?: boolean;
    deletedAt?: boolean;
  };

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'documentType'
      | 'documentNumber'
      | 'clientId'
      | 'supplierId'
      | 'serviceId'
      | 'fileName'
      | 'filePath'
      | 'fileSize'
      | 'mimeType'
      | 'description'
      | 'tags'
      | 'metadata'
      | 'uploadedBy'
      | 'uploadedAt'
      | 'deletedAt',
      ExtArgs['result']['document']
    >;
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      client?: boolean | Document$clientArgs<ExtArgs>;
      supplier?: boolean | Document$supplierArgs<ExtArgs>;
      service?: boolean | Document$serviceArgs<ExtArgs>;
    };
  export type DocumentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    client?: boolean | Document$clientArgs<ExtArgs>;
    supplier?: boolean | Document$supplierArgs<ExtArgs>;
    service?: boolean | Document$serviceArgs<ExtArgs>;
  };
  export type DocumentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    client?: boolean | Document$clientArgs<ExtArgs>;
    supplier?: boolean | Document$supplierArgs<ExtArgs>;
    service?: boolean | Document$serviceArgs<ExtArgs>;
  };

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Document';
      objects: {
        client: Prisma.$ClientPayload<ExtArgs> | null;
        supplier: Prisma.$SupplierPayload<ExtArgs> | null;
        service: Prisma.$ServicePayload<ExtArgs> | null;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          documentType: $Enums.DocumentType;
          documentNumber: string | null;
          clientId: string | null;
          supplierId: string | null;
          serviceId: string | null;
          fileName: string;
          filePath: string;
          fileSize: number;
          mimeType: string;
          description: string | null;
          tags: string[];
          metadata: Prisma.JsonValue | null;
          uploadedBy: string;
          uploadedAt: Date;
          deletedAt: Date | null;
        },
        ExtArgs['result']['document']
      >;
      composites: {};
    };

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> =
    $Result.GetResult<Prisma.$DocumentPayload, S>;

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    DocumentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: DocumentCountAggregateInputType | true;
  };

  export interface DocumentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Document'];
      meta: { name: 'Document' };
    };
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     *
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DocumentFindManyArgs>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     *
     */
    create<T extends DocumentCreateArgs>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DocumentCreateManyArgs>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     *
     */
    delete<T extends DocumentDeleteArgs>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DocumentUpdateArgs>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DocumentDeleteManyArgs>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DocumentUpdateManyArgs>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
     **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DocumentAggregateArgs>(
      args: Subset<T, DocumentAggregateArgs>
    ): Prisma.PrismaPromise<GetDocumentAggregateType<T>>;

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Document model
     */
    readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    client<T extends Document$clientArgs<ExtArgs> = {}>(
      args?: Subset<T, Document$clientArgs<ExtArgs>>
    ): Prisma__ClientClient<
      $Result.GetResult<
        Prisma.$ClientPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    supplier<T extends Document$supplierArgs<ExtArgs> = {}>(
      args?: Subset<T, Document$supplierArgs<ExtArgs>>
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends Document$serviceArgs<ExtArgs> = {}>(
      args?: Subset<T, Document$serviceArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<'Document', 'String'>;
    readonly documentType: FieldRef<'Document', 'DocumentType'>;
    readonly documentNumber: FieldRef<'Document', 'String'>;
    readonly clientId: FieldRef<'Document', 'String'>;
    readonly supplierId: FieldRef<'Document', 'String'>;
    readonly serviceId: FieldRef<'Document', 'String'>;
    readonly fileName: FieldRef<'Document', 'String'>;
    readonly filePath: FieldRef<'Document', 'String'>;
    readonly fileSize: FieldRef<'Document', 'Int'>;
    readonly mimeType: FieldRef<'Document', 'String'>;
    readonly description: FieldRef<'Document', 'String'>;
    readonly tags: FieldRef<'Document', 'String[]'>;
    readonly metadata: FieldRef<'Document', 'Json'>;
    readonly uploadedBy: FieldRef<'Document', 'String'>;
    readonly uploadedAt: FieldRef<'Document', 'DateTime'>;
    readonly deletedAt: FieldRef<'Document', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document create
   */
  export type DocumentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>;
  };

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Document update
   */
  export type DocumentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>;
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>;
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput;
    /**
     * Limit how many Documents to update.
     */
    limit?: number;
  };

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>;
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput;
    /**
     * Limit how many Documents to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput;
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>;
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>;
  };

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput;
    /**
     * Limit how many Documents to delete.
     */
    limit?: number;
  };

  /**
   * Document.client
   */
  export type Document$clientArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null;
    where?: ClientWhereInput;
  };

  /**
   * Document.supplier
   */
  export type Document$supplierArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    where?: SupplierWhereInput;
  };

  /**
   * Document.service
   */
  export type Document$serviceArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
  };

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    action: $Enums.AuditAction | null;
    tableName: string | null;
    recordId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    requestId: string | null;
    createdAt: Date | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    action: $Enums.AuditAction | null;
    tableName: string | null;
    recordId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    requestId: string | null;
    createdAt: Date | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    userId: number;
    action: number;
    tableName: number;
    recordId: number;
    oldValues: number;
    newValues: number;
    ipAddress: number;
    userAgent: number;
    requestId: number;
    metadata: number;
    createdAt: number;
    _all: number;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    tableName?: true;
    recordId?: true;
    ipAddress?: true;
    userAgent?: true;
    requestId?: true;
    createdAt?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    tableName?: true;
    recordId?: true;
    ipAddress?: true;
    userAgent?: true;
    requestId?: true;
    createdAt?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    tableName?: true;
    recordId?: true;
    oldValues?: true;
    newValues?: true;
    ipAddress?: true;
    userAgent?: true;
    requestId?: true;
    metadata?: true;
    createdAt?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: string;
    userId: string | null;
    action: $Enums.AuditAction;
    tableName: string;
    recordId: string;
    oldValues: JsonValue | null;
    newValues: JsonValue | null;
    ipAddress: string | null;
    userAgent: string | null;
    requestId: string | null;
    metadata: JsonValue | null;
    createdAt: Date;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AuditLogGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
          : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
      }
    >
  >;

  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        action?: boolean;
        tableName?: boolean;
        recordId?: boolean;
        oldValues?: boolean;
        newValues?: boolean;
        ipAddress?: boolean;
        userAgent?: boolean;
        requestId?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        user?: boolean | AuditLog$userArgs<ExtArgs>;
      },
      ExtArgs['result']['auditLog']
    >;

  export type AuditLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      action?: boolean;
      tableName?: boolean;
      recordId?: boolean;
      oldValues?: boolean;
      newValues?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      requestId?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      user?: boolean | AuditLog$userArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      action?: boolean;
      tableName?: boolean;
      recordId?: boolean;
      oldValues?: boolean;
      newValues?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      requestId?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      user?: boolean | AuditLog$userArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    userId?: boolean;
    action?: boolean;
    tableName?: boolean;
    recordId?: boolean;
    oldValues?: boolean;
    newValues?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    requestId?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
  };

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'userId'
      | 'action'
      | 'tableName'
      | 'recordId'
      | 'oldValues'
      | 'newValues'
      | 'ipAddress'
      | 'userAgent'
      | 'requestId'
      | 'metadata'
      | 'createdAt',
      ExtArgs['result']['auditLog']
    >;
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      user?: boolean | AuditLog$userArgs<ExtArgs>;
    };
  export type AuditLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | AuditLog$userArgs<ExtArgs>;
  };
  export type AuditLogIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | AuditLog$userArgs<ExtArgs>;
  };

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'AuditLog';
      objects: {
        user: Prisma.$UserPayload<ExtArgs> | null;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          userId: string | null;
          action: $Enums.AuditAction;
          tableName: string;
          recordId: string;
          oldValues: Prisma.JsonValue | null;
          newValues: Prisma.JsonValue | null;
          ipAddress: string | null;
          userAgent: string | null;
          requestId: string | null;
          metadata: Prisma.JsonValue | null;
          createdAt: Date;
        },
        ExtArgs['result']['auditLog']
      >;
      composites: {};
    };

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> =
    $Result.GetResult<Prisma.$AuditLogPayload, S>;

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AuditLogFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'];
      meta: { name: 'AuditLog' };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(
      args?: Subset<T, AuditLog$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<'AuditLog', 'String'>;
    readonly userId: FieldRef<'AuditLog', 'String'>;
    readonly action: FieldRef<'AuditLog', 'AuditAction'>;
    readonly tableName: FieldRef<'AuditLog', 'String'>;
    readonly recordId: FieldRef<'AuditLog', 'String'>;
    readonly oldValues: FieldRef<'AuditLog', 'Json'>;
    readonly newValues: FieldRef<'AuditLog', 'Json'>;
    readonly ipAddress: FieldRef<'AuditLog', 'String'>;
    readonly userAgent: FieldRef<'AuditLog', 'String'>;
    readonly requestId: FieldRef<'AuditLog', 'String'>;
    readonly metadata: FieldRef<'AuditLog', 'Json'>;
    readonly createdAt: FieldRef<'AuditLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
  };

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number;
  };

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    title: string | null;
    message: string | null;
    type: string | null;
    category: string | null;
    actionUrl: string | null;
    actionLabel: string | null;
    isRead: boolean | null;
    readAt: Date | null;
    createdAt: Date | null;
  };

  export type NotificationMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    title: string | null;
    message: string | null;
    type: string | null;
    category: string | null;
    actionUrl: string | null;
    actionLabel: string | null;
    isRead: boolean | null;
    readAt: Date | null;
    createdAt: Date | null;
  };

  export type NotificationCountAggregateOutputType = {
    id: number;
    userId: number;
    title: number;
    message: number;
    type: number;
    category: number;
    actionUrl: number;
    actionLabel: number;
    isRead: number;
    readAt: number;
    createdAt: number;
    _all: number;
  };

  export type NotificationMinAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    type?: true;
    category?: true;
    actionUrl?: true;
    actionLabel?: true;
    isRead?: true;
    readAt?: true;
    createdAt?: true;
  };

  export type NotificationMaxAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    type?: true;
    category?: true;
    actionUrl?: true;
    actionLabel?: true;
    isRead?: true;
    readAt?: true;
    createdAt?: true;
  };

  export type NotificationCountAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    type?: true;
    category?: true;
    actionUrl?: true;
    actionLabel?: true;
    isRead?: true;
    readAt?: true;
    createdAt?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    id: string;
    userId: string;
    title: string;
    message: string;
    type: string;
    category: string;
    actionUrl: string | null;
    actionLabel: string | null;
    isRead: boolean;
    readAt: Date | null;
    createdAt: Date;
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof NotificationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
          : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
      }
    >
  >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      title?: boolean;
      message?: boolean;
      type?: boolean;
      category?: boolean;
      actionUrl?: boolean;
      actionLabel?: boolean;
      isRead?: boolean;
      readAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      title?: boolean;
      message?: boolean;
      type?: boolean;
      category?: boolean;
      actionUrl?: boolean;
      actionLabel?: boolean;
      isRead?: boolean;
      readAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      title?: boolean;
      message?: boolean;
      type?: boolean;
      category?: boolean;
      actionUrl?: boolean;
      actionLabel?: boolean;
      isRead?: boolean;
      readAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    id?: boolean;
    userId?: boolean;
    title?: boolean;
    message?: boolean;
    type?: boolean;
    category?: boolean;
    actionUrl?: boolean;
    actionLabel?: boolean;
    isRead?: boolean;
    readAt?: boolean;
    createdAt?: boolean;
  };

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'userId'
      | 'title'
      | 'message'
      | 'type'
      | 'category'
      | 'actionUrl'
      | 'actionLabel'
      | 'isRead'
      | 'readAt'
      | 'createdAt',
      ExtArgs['result']['notification']
    >;
  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notification';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        title: string;
        message: string;
        type: string;
        category: string;
        actionUrl: string | null;
        actionLabel: string | null;
        isRead: boolean;
        readAt: Date | null;
        createdAt: Date;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> =
    $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true;
    };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<'Notification', 'String'>;
    readonly userId: FieldRef<'Notification', 'String'>;
    readonly title: FieldRef<'Notification', 'String'>;
    readonly message: FieldRef<'Notification', 'String'>;
    readonly type: FieldRef<'Notification', 'String'>;
    readonly category: FieldRef<'Notification', 'String'>;
    readonly actionUrl: FieldRef<'Notification', 'String'>;
    readonly actionLabel: FieldRef<'Notification', 'String'>;
    readonly isRead: FieldRef<'Notification', 'Boolean'>;
    readonly readAt: FieldRef<'Notification', 'DateTime'>;
    readonly createdAt: FieldRef<'Notification', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null;
    _min: SystemSettingMinAggregateOutputType | null;
    _max: SystemSettingMaxAggregateOutputType | null;
  };

  export type SystemSettingMinAggregateOutputType = {
    id: string | null;
    key: string | null;
    description: string | null;
    isPublic: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null;
    key: string | null;
    description: string | null;
    isPublic: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SystemSettingCountAggregateOutputType = {
    id: number;
    key: number;
    value: number;
    description: number;
    isPublic: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SystemSettingMinAggregateInputType = {
    id?: true;
    key?: true;
    description?: true;
    isPublic?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SystemSettingMaxAggregateInputType = {
    id?: true;
    key?: true;
    description?: true;
    isPublic?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SystemSettingCountAggregateInputType = {
    id?: true;
    key?: true;
    value?: true;
    description?: true;
    isPublic?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SystemSettingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SystemSettings
     **/
    _count?: true | SystemSettingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SystemSettingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SystemSettingMaxAggregateInputType;
  };

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
    [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>;
  };

  export type SystemSettingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SystemSettingWhereInput;
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[];
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum;
    having?: SystemSettingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SystemSettingCountAggregateInputType | true;
    _min?: SystemSettingMinAggregateInputType;
    _max?: SystemSettingMaxAggregateInputType;
  };

  export type SystemSettingGroupByOutputType = {
    id: string;
    key: string;
    value: JsonValue;
    description: string | null;
    isPublic: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: SystemSettingCountAggregateOutputType | null;
    _min: SystemSettingMinAggregateOutputType | null;
    _max: SystemSettingMaxAggregateOutputType | null;
  };

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SystemSettingGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
          : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>;
      }
    >
  >;

  export type SystemSettingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      key?: boolean;
      value?: boolean;
      description?: boolean;
      isPublic?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['systemSetting']
  >;

  export type SystemSettingSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      key?: boolean;
      value?: boolean;
      description?: boolean;
      isPublic?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['systemSetting']
  >;

  export type SystemSettingSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      key?: boolean;
      value?: boolean;
      description?: boolean;
      isPublic?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['systemSetting']
  >;

  export type SystemSettingSelectScalar = {
    id?: boolean;
    key?: boolean;
    value?: boolean;
    description?: boolean;
    isPublic?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type SystemSettingOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'key' | 'value' | 'description' | 'isPublic' | 'createdAt' | 'updatedAt',
    ExtArgs['result']['systemSetting']
  >;

  export type $SystemSettingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'SystemSetting';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        key: string;
        value: Prisma.JsonValue;
        description: string | null;
        isPublic: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['systemSetting']
    >;
    composites: {};
  };

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> =
    $Result.GetResult<Prisma.$SystemSettingPayload, S>;

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true;
    };

  export interface SystemSettingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'];
      meta: { name: 'SystemSetting' };
    };
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(
      args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<
      $Result.GetResult<
        Prisma.$SystemSettingPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<
      $Result.GetResult<
        Prisma.$SystemSettingPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(
      args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<
      $Result.GetResult<
        Prisma.$SystemSettingPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<
      $Result.GetResult<
        Prisma.$SystemSettingPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     *
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SystemSettingFindManyArgs>(
      args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     *
     */
    create<T extends SystemSettingCreateArgs>(
      args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<
      $Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SystemSettingCreateManyArgs>(
      args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SystemSettingPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     *
     */
    delete<T extends SystemSettingDeleteArgs>(
      args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<
      $Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SystemSettingUpdateArgs>(
      args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<
      $Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(
      args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(
      args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SystemSettingPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(
      args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<
      $Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
     **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SystemSettingAggregateArgs>(
      args: Subset<T, SystemSettingAggregateArgs>
    ): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>;

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSystemSettingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SystemSetting model
     */
    readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<'SystemSetting', 'String'>;
    readonly key: FieldRef<'SystemSetting', 'String'>;
    readonly value: FieldRef<'SystemSetting', 'Json'>;
    readonly description: FieldRef<'SystemSetting', 'String'>;
    readonly isPublic: FieldRef<'SystemSetting', 'Boolean'>;
    readonly createdAt: FieldRef<'SystemSetting', 'DateTime'>;
    readonly updatedAt: FieldRef<'SystemSetting', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput;
  };

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput;
  };

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[];
  };

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[];
  };

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemSettings.
     */
    skip?: number;
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[];
  };

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>;
  };

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>;
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput;
  };

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>;
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput;
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number;
  };

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>;
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput;
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number;
  };

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput;
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>;
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>;
  };

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput;
  };

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput;
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number;
  };

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const AccountScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    provider: 'provider';
    providerAccountId: 'providerAccountId';
    refresh_token: 'refresh_token';
    access_token: 'access_token';
    expires_at: 'expires_at';
    token_type: 'token_type';
    scope: 'scope';
    id_token: 'id_token';
    session_state: 'session_state';
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: 'id';
    sessionToken: 'sessionToken';
    userId: 'userId';
    expires: 'expires';
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier';
    token: 'token';
    expires: 'expires';
  };

  export type VerificationTokenScalarFieldEnum =
    (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum];

  export const UserScalarFieldEnum: {
    id: 'id';
    email: 'email';
    emailVerified: 'emailVerified';
    password: 'password';
    name: 'name';
    role: 'role';
    avatar: 'avatar';
    phone: 'phone';
    department: 'department';
    isActive: 'isActive';
    twoFactorEnabled: 'twoFactorEnabled';
    twoFactorSecret: 'twoFactorSecret';
    lastLoginAt: 'lastLoginAt';
    lastLoginIp: 'lastLoginIp';
    passwordChangedAt: 'passwordChangedAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const CompanyScalarFieldEnum: {
    id: 'id';
    code: 'code';
    legalName: 'legalName';
    tradeName: 'tradeName';
    vatNumber: 'vatNumber';
    registrationNo: 'registrationNo';
    addressLine1: 'addressLine1';
    addressLine2: 'addressLine2';
    city: 'city';
    state: 'state';
    postalCode: 'postalCode';
    country: 'country';
    phone: 'phone';
    fax: 'fax';
    email: 'email';
    website: 'website';
    bankName: 'bankName';
    bankAccount: 'bankAccount';
    swiftCode: 'swiftCode';
    iban: 'iban';
    currency: 'currency';
    timezone: 'timezone';
    fiscalYearEnd: 'fiscalYearEnd';
    invoicePrefix: 'invoicePrefix';
    logoUrl: 'logoUrl';
    metadata: 'metadata';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type CompanyScalarFieldEnum =
    (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum];

  export const ClientScalarFieldEnum: {
    id: 'id';
    clientCode: 'clientCode';
    companyId: 'companyId';
    name: 'name';
    tradeName: 'tradeName';
    vatNumber: 'vatNumber';
    billingAddress: 'billingAddress';
    shippingAddress: 'shippingAddress';
    billingEmail: 'billingEmail';
    trafficEmail: 'trafficEmail';
    contactPerson: 'contactPerson';
    contactPhone: 'contactPhone';
    contactMobile: 'contactMobile';
    creditLimit: 'creditLimit';
    paymentTerms: 'paymentTerms';
    discount: 'discount';
    currency: 'currency';
    language: 'language';
    sendReminders: 'sendReminders';
    autoInvoice: 'autoInvoice';
    notes: 'notes';
    tags: 'tags';
    metadata: 'metadata';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type ClientScalarFieldEnum =
    (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum];

  export const ClientContactScalarFieldEnum: {
    id: 'id';
    clientId: 'clientId';
    name: 'name';
    position: 'position';
    email: 'email';
    phone: 'phone';
    mobile: 'mobile';
    isPrimary: 'isPrimary';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ClientContactScalarFieldEnum =
    (typeof ClientContactScalarFieldEnum)[keyof typeof ClientContactScalarFieldEnum];

  export const SupplierScalarFieldEnum: {
    id: 'id';
    supplierCode: 'supplierCode';
    companyId: 'companyId';
    name: 'name';
    tradeName: 'tradeName';
    vatNumber: 'vatNumber';
    addressLine1: 'addressLine1';
    addressLine2: 'addressLine2';
    city: 'city';
    state: 'state';
    postalCode: 'postalCode';
    country: 'country';
    email: 'email';
    phone: 'phone';
    fax: 'fax';
    contactPerson: 'contactPerson';
    contactMobile: 'contactMobile';
    irpfRate: 'irpfRate';
    vatRate: 'vatRate';
    paymentTerms: 'paymentTerms';
    paymentMethod: 'paymentMethod';
    bankName: 'bankName';
    bankAccount: 'bankAccount';
    swiftCode: 'swiftCode';
    iban: 'iban';
    currency: 'currency';
    autoApprove: 'autoApprove';
    requirePO: 'requirePO';
    notes: 'notes';
    tags: 'tags';
    metadata: 'metadata';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type SupplierScalarFieldEnum =
    (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum];

  export const ServiceScalarFieldEnum: {
    id: 'id';
    serviceNumber: 'serviceNumber';
    date: 'date';
    clientId: 'clientId';
    supplierId: 'supplierId';
    createdById: 'createdById';
    assignedToId: 'assignedToId';
    description: 'description';
    reference: 'reference';
    origin: 'origin';
    destination: 'destination';
    distance: 'distance';
    vehicleType: 'vehicleType';
    vehiclePlate: 'vehiclePlate';
    driverName: 'driverName';
    costAmount: 'costAmount';
    costCurrency: 'costCurrency';
    saleAmount: 'saleAmount';
    saleCurrency: 'saleCurrency';
    margin: 'margin';
    marginPercentage: 'marginPercentage';
    costVatRate: 'costVatRate';
    costVatAmount: 'costVatAmount';
    saleVatRate: 'saleVatRate';
    saleVatAmount: 'saleVatAmount';
    status: 'status';
    completedAt: 'completedAt';
    cancelledAt: 'cancelledAt';
    cancellationReason: 'cancellationReason';
    archivedAt: 'archivedAt';
    notes: 'notes';
    internalNotes: 'internalNotes';
    attachments: 'attachments';
    customFields: 'customFields';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type ServiceScalarFieldEnum =
    (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum];

  export const ServiceStatusHistoryScalarFieldEnum: {
    id: 'id';
    serviceId: 'serviceId';
    fromStatus: 'fromStatus';
    toStatus: 'toStatus';
    reason: 'reason';
    changedBy: 'changedBy';
    changedAt: 'changedAt';
  };

  export type ServiceStatusHistoryScalarFieldEnum =
    (typeof ServiceStatusHistoryScalarFieldEnum)[keyof typeof ServiceStatusHistoryScalarFieldEnum];

  export const LoadingOrderScalarFieldEnum: {
    id: 'id';
    orderNumber: 'orderNumber';
    generatedAt: 'generatedAt';
    generatedById: 'generatedById';
    clientId: 'clientId';
    notes: 'notes';
    pdfPath: 'pdfPath';
    pdfGeneratedAt: 'pdfGeneratedAt';
    pdfSize: 'pdfSize';
    metadata: 'metadata';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type LoadingOrderScalarFieldEnum =
    (typeof LoadingOrderScalarFieldEnum)[keyof typeof LoadingOrderScalarFieldEnum];

  export const ServiceLoadingOrderScalarFieldEnum: {
    id: 'id';
    serviceId: 'serviceId';
    loadingOrderId: 'loadingOrderId';
    position: 'position';
  };

  export type ServiceLoadingOrderScalarFieldEnum =
    (typeof ServiceLoadingOrderScalarFieldEnum)[keyof typeof ServiceLoadingOrderScalarFieldEnum];

  export const InvoiceScalarFieldEnum: {
    id: 'id';
    invoiceNumber: 'invoiceNumber';
    invoiceDate: 'invoiceDate';
    dueDate: 'dueDate';
    supplierId: 'supplierId';
    createdById: 'createdById';
    subtotal: 'subtotal';
    taxAmount: 'taxAmount';
    totalAmount: 'totalAmount';
    currency: 'currency';
    status: 'status';
    paymentStatus: 'paymentStatus';
    paidAmount: 'paidAmount';
    paidAt: 'paidAt';
    paymentMethod: 'paymentMethod';
    paymentReference: 'paymentReference';
    irpfRate: 'irpfRate';
    irpfAmount: 'irpfAmount';
    description: 'description';
    notes: 'notes';
    termsConditions: 'termsConditions';
    pdfPath: 'pdfPath';
    pdfGeneratedAt: 'pdfGeneratedAt';
    sentAt: 'sentAt';
    sentTo: 'sentTo';
    viewedAt: 'viewedAt';
    reminderSentAt: 'reminderSentAt';
    metadata: 'metadata';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type InvoiceScalarFieldEnum =
    (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum];

  export const InvoiceItemScalarFieldEnum: {
    id: 'id';
    invoiceId: 'invoiceId';
    serviceId: 'serviceId';
    description: 'description';
    quantity: 'quantity';
    unitPrice: 'unitPrice';
    amount: 'amount';
    taxRate: 'taxRate';
    taxAmount: 'taxAmount';
  };

  export type InvoiceItemScalarFieldEnum =
    (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum];

  export const PaymentScalarFieldEnum: {
    id: 'id';
    paymentNumber: 'paymentNumber';
    invoiceId: 'invoiceId';
    amount: 'amount';
    currency: 'currency';
    paymentDate: 'paymentDate';
    paymentMethod: 'paymentMethod';
    reference: 'reference';
    status: 'status';
    notes: 'notes';
    receiptPath: 'receiptPath';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type PaymentScalarFieldEnum =
    (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum];

  export const DocumentScalarFieldEnum: {
    id: 'id';
    documentType: 'documentType';
    documentNumber: 'documentNumber';
    clientId: 'clientId';
    supplierId: 'supplierId';
    serviceId: 'serviceId';
    fileName: 'fileName';
    filePath: 'filePath';
    fileSize: 'fileSize';
    mimeType: 'mimeType';
    description: 'description';
    tags: 'tags';
    metadata: 'metadata';
    uploadedBy: 'uploadedBy';
    uploadedAt: 'uploadedAt';
    deletedAt: 'deletedAt';
  };

  export type DocumentScalarFieldEnum =
    (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    action: 'action';
    tableName: 'tableName';
    recordId: 'recordId';
    oldValues: 'oldValues';
    newValues: 'newValues';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    requestId: 'requestId';
    metadata: 'metadata';
    createdAt: 'createdAt';
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    title: 'title';
    message: 'message';
    type: 'type';
    category: 'category';
    actionUrl: 'actionUrl';
    actionLabel: 'actionLabel';
    isRead: 'isRead';
    readAt: 'readAt';
    createdAt: 'createdAt';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const SystemSettingScalarFieldEnum: {
    id: 'id';
    key: 'key';
    value: 'value';
    description: 'description';
    isPublic: 'isPublic';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type SystemSettingScalarFieldEnum =
    (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    provider: 'provider';
    providerAccountId: 'providerAccountId';
    refresh_token: 'refresh_token';
    access_token: 'access_token';
    token_type: 'token_type';
    scope: 'scope';
    id_token: 'id_token';
    session_state: 'session_state';
  };

  export type AccountOrderByRelevanceFieldEnum =
    (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum];

  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id';
    sessionToken: 'sessionToken';
    userId: 'userId';
  };

  export type SessionOrderByRelevanceFieldEnum =
    (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum];

  export const VerificationTokenOrderByRelevanceFieldEnum: {
    identifier: 'identifier';
    token: 'token';
  };

  export type VerificationTokenOrderByRelevanceFieldEnum =
    (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum];

  export const UserOrderByRelevanceFieldEnum: {
    id: 'id';
    email: 'email';
    password: 'password';
    name: 'name';
    avatar: 'avatar';
    phone: 'phone';
    department: 'department';
    twoFactorSecret: 'twoFactorSecret';
    lastLoginIp: 'lastLoginIp';
  };

  export type UserOrderByRelevanceFieldEnum =
    (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  export const CompanyOrderByRelevanceFieldEnum: {
    id: 'id';
    code: 'code';
    legalName: 'legalName';
    tradeName: 'tradeName';
    vatNumber: 'vatNumber';
    registrationNo: 'registrationNo';
    addressLine1: 'addressLine1';
    addressLine2: 'addressLine2';
    city: 'city';
    state: 'state';
    postalCode: 'postalCode';
    country: 'country';
    phone: 'phone';
    fax: 'fax';
    email: 'email';
    website: 'website';
    bankName: 'bankName';
    bankAccount: 'bankAccount';
    swiftCode: 'swiftCode';
    iban: 'iban';
    currency: 'currency';
    timezone: 'timezone';
    fiscalYearEnd: 'fiscalYearEnd';
    invoicePrefix: 'invoicePrefix';
    logoUrl: 'logoUrl';
  };

  export type CompanyOrderByRelevanceFieldEnum =
    (typeof CompanyOrderByRelevanceFieldEnum)[keyof typeof CompanyOrderByRelevanceFieldEnum];

  export const ClientOrderByRelevanceFieldEnum: {
    id: 'id';
    clientCode: 'clientCode';
    companyId: 'companyId';
    name: 'name';
    tradeName: 'tradeName';
    vatNumber: 'vatNumber';
    billingEmail: 'billingEmail';
    trafficEmail: 'trafficEmail';
    contactPerson: 'contactPerson';
    contactPhone: 'contactPhone';
    contactMobile: 'contactMobile';
    currency: 'currency';
    language: 'language';
    notes: 'notes';
    tags: 'tags';
  };

  export type ClientOrderByRelevanceFieldEnum =
    (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum];

  export const ClientContactOrderByRelevanceFieldEnum: {
    id: 'id';
    clientId: 'clientId';
    name: 'name';
    position: 'position';
    email: 'email';
    phone: 'phone';
    mobile: 'mobile';
  };

  export type ClientContactOrderByRelevanceFieldEnum =
    (typeof ClientContactOrderByRelevanceFieldEnum)[keyof typeof ClientContactOrderByRelevanceFieldEnum];

  export const SupplierOrderByRelevanceFieldEnum: {
    id: 'id';
    supplierCode: 'supplierCode';
    companyId: 'companyId';
    name: 'name';
    tradeName: 'tradeName';
    vatNumber: 'vatNumber';
    addressLine1: 'addressLine1';
    addressLine2: 'addressLine2';
    city: 'city';
    state: 'state';
    postalCode: 'postalCode';
    country: 'country';
    email: 'email';
    phone: 'phone';
    fax: 'fax';
    contactPerson: 'contactPerson';
    contactMobile: 'contactMobile';
    paymentMethod: 'paymentMethod';
    bankName: 'bankName';
    bankAccount: 'bankAccount';
    swiftCode: 'swiftCode';
    iban: 'iban';
    currency: 'currency';
    notes: 'notes';
    tags: 'tags';
  };

  export type SupplierOrderByRelevanceFieldEnum =
    (typeof SupplierOrderByRelevanceFieldEnum)[keyof typeof SupplierOrderByRelevanceFieldEnum];

  export const ServiceOrderByRelevanceFieldEnum: {
    id: 'id';
    serviceNumber: 'serviceNumber';
    clientId: 'clientId';
    supplierId: 'supplierId';
    createdById: 'createdById';
    assignedToId: 'assignedToId';
    description: 'description';
    reference: 'reference';
    origin: 'origin';
    destination: 'destination';
    vehicleType: 'vehicleType';
    vehiclePlate: 'vehiclePlate';
    driverName: 'driverName';
    costCurrency: 'costCurrency';
    saleCurrency: 'saleCurrency';
    cancellationReason: 'cancellationReason';
    notes: 'notes';
    internalNotes: 'internalNotes';
    attachments: 'attachments';
  };

  export type ServiceOrderByRelevanceFieldEnum =
    (typeof ServiceOrderByRelevanceFieldEnum)[keyof typeof ServiceOrderByRelevanceFieldEnum];

  export const ServiceStatusHistoryOrderByRelevanceFieldEnum: {
    id: 'id';
    serviceId: 'serviceId';
    reason: 'reason';
    changedBy: 'changedBy';
  };

  export type ServiceStatusHistoryOrderByRelevanceFieldEnum =
    (typeof ServiceStatusHistoryOrderByRelevanceFieldEnum)[keyof typeof ServiceStatusHistoryOrderByRelevanceFieldEnum];

  export const LoadingOrderOrderByRelevanceFieldEnum: {
    id: 'id';
    orderNumber: 'orderNumber';
    generatedById: 'generatedById';
    clientId: 'clientId';
    notes: 'notes';
    pdfPath: 'pdfPath';
  };

  export type LoadingOrderOrderByRelevanceFieldEnum =
    (typeof LoadingOrderOrderByRelevanceFieldEnum)[keyof typeof LoadingOrderOrderByRelevanceFieldEnum];

  export const ServiceLoadingOrderOrderByRelevanceFieldEnum: {
    id: 'id';
    serviceId: 'serviceId';
    loadingOrderId: 'loadingOrderId';
  };

  export type ServiceLoadingOrderOrderByRelevanceFieldEnum =
    (typeof ServiceLoadingOrderOrderByRelevanceFieldEnum)[keyof typeof ServiceLoadingOrderOrderByRelevanceFieldEnum];

  export const InvoiceOrderByRelevanceFieldEnum: {
    id: 'id';
    invoiceNumber: 'invoiceNumber';
    supplierId: 'supplierId';
    createdById: 'createdById';
    currency: 'currency';
    paymentMethod: 'paymentMethod';
    paymentReference: 'paymentReference';
    description: 'description';
    notes: 'notes';
    termsConditions: 'termsConditions';
    pdfPath: 'pdfPath';
    sentTo: 'sentTo';
  };

  export type InvoiceOrderByRelevanceFieldEnum =
    (typeof InvoiceOrderByRelevanceFieldEnum)[keyof typeof InvoiceOrderByRelevanceFieldEnum];

  export const InvoiceItemOrderByRelevanceFieldEnum: {
    id: 'id';
    invoiceId: 'invoiceId';
    serviceId: 'serviceId';
    description: 'description';
  };

  export type InvoiceItemOrderByRelevanceFieldEnum =
    (typeof InvoiceItemOrderByRelevanceFieldEnum)[keyof typeof InvoiceItemOrderByRelevanceFieldEnum];

  export const PaymentOrderByRelevanceFieldEnum: {
    id: 'id';
    paymentNumber: 'paymentNumber';
    invoiceId: 'invoiceId';
    currency: 'currency';
    paymentMethod: 'paymentMethod';
    reference: 'reference';
    notes: 'notes';
    receiptPath: 'receiptPath';
  };

  export type PaymentOrderByRelevanceFieldEnum =
    (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum];

  export const DocumentOrderByRelevanceFieldEnum: {
    id: 'id';
    documentNumber: 'documentNumber';
    clientId: 'clientId';
    supplierId: 'supplierId';
    serviceId: 'serviceId';
    fileName: 'fileName';
    filePath: 'filePath';
    mimeType: 'mimeType';
    description: 'description';
    tags: 'tags';
    uploadedBy: 'uploadedBy';
  };

  export type DocumentOrderByRelevanceFieldEnum =
    (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum];

  export const AuditLogOrderByRelevanceFieldEnum: {
    id: 'id';
    userId: 'userId';
    tableName: 'tableName';
    recordId: 'recordId';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    requestId: 'requestId';
  };

  export type AuditLogOrderByRelevanceFieldEnum =
    (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum];

  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id';
    userId: 'userId';
    title: 'title';
    message: 'message';
    type: 'type';
    category: 'category';
    actionUrl: 'actionUrl';
    actionLabel: 'actionLabel';
  };

  export type NotificationOrderByRelevanceFieldEnum =
    (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum];

  export const SystemSettingOrderByRelevanceFieldEnum: {
    id: 'id';
    key: 'key';
    description: 'description';
  };

  export type SystemSettingOrderByRelevanceFieldEnum =
    (typeof SystemSettingOrderByRelevanceFieldEnum)[keyof typeof SystemSettingOrderByRelevanceFieldEnum];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>;

  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserRole[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>;

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>;

  /**
   * Reference to a field of type 'ServiceStatus'
   */
  export type EnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ServiceStatus'
  >;

  /**
   * Reference to a field of type 'ServiceStatus[]'
   */
  export type ListEnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ServiceStatus[]'
  >;

  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'InvoiceStatus'
  >;

  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'InvoiceStatus[]'
  >;

  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'PaymentStatus'
  >;

  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'PaymentStatus[]'
  >;

  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DocumentType'
  >;

  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DocumentType[]'
  >;

  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AuditAction'
  >;

  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AuditAction[]'
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;

  /**
   * Deep Input Types
   */

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    id?: StringFilter<'Account'> | string;
    userId?: StringFilter<'Account'> | string;
    type?: StringFilter<'Account'> | string;
    provider?: StringFilter<'Account'> | string;
    providerAccountId?: StringFilter<'Account'> | string;
    refresh_token?: StringNullableFilter<'Account'> | string | null;
    access_token?: StringNullableFilter<'Account'> | string | null;
    expires_at?: IntNullableFilter<'Account'> | number | null;
    token_type?: StringNullableFilter<'Account'> | string | null;
    scope?: StringNullableFilter<'Account'> | string | null;
    id_token?: StringNullableFilter<'Account'> | string | null;
    session_state?: StringNullableFilter<'Account'> | string | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
    _relevance?: AccountOrderByRelevanceInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      userId?: StringFilter<'Account'> | string;
      type?: StringFilter<'Account'> | string;
      provider?: StringFilter<'Account'> | string;
      providerAccountId?: StringFilter<'Account'> | string;
      refresh_token?: StringNullableFilter<'Account'> | string | null;
      access_token?: StringNullableFilter<'Account'> | string | null;
      expires_at?: IntNullableFilter<'Account'> | number | null;
      token_type?: StringNullableFilter<'Account'> | string | null;
      scope?: StringNullableFilter<'Account'> | string | null;
      id_token?: StringNullableFilter<'Account'> | string | null;
      session_state?: StringNullableFilter<'Account'> | string | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'provider_providerAccountId'
  >;

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _avg?: AccountAvgOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
    _sum?: AccountSumOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Account'> | string;
    userId?: StringWithAggregatesFilter<'Account'> | string;
    type?: StringWithAggregatesFilter<'Account'> | string;
    provider?: StringWithAggregatesFilter<'Account'> | string;
    providerAccountId?: StringWithAggregatesFilter<'Account'> | string;
    refresh_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    access_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    expires_at?: IntNullableWithAggregatesFilter<'Account'> | number | null;
    token_type?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    scope?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    id_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    session_state?: StringNullableWithAggregatesFilter<'Account'> | string | null;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<'Session'> | string;
    sessionToken?: StringFilter<'Session'> | string;
    userId?: StringFilter<'Session'> | string;
    expires?: DateTimeFilter<'Session'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    user?: UserOrderByWithRelationInput;
    _relevance?: SessionOrderByRelevanceInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      sessionToken?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<'Session'> | string;
      expires?: DateTimeFilter<'Session'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'sessionToken'
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Session'> | string;
    sessionToken?: StringWithAggregatesFilter<'Session'> | string;
    userId?: StringWithAggregatesFilter<'Session'> | string;
    expires?: DateTimeWithAggregatesFilter<'Session'> | Date | string;
  };

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    OR?: VerificationTokenWhereInput[];
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    identifier?: StringFilter<'VerificationToken'> | string;
    token?: StringFilter<'VerificationToken'> | string;
    expires?: DateTimeFilter<'VerificationToken'> | Date | string;
  };

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _relevance?: VerificationTokenOrderByRelevanceInput;
  };

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      token?: string;
      identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput;
      AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      OR?: VerificationTokenWhereInput[];
      NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      identifier?: StringFilter<'VerificationToken'> | string;
      expires?: DateTimeFilter<'VerificationToken'> | Date | string;
    },
    'token' | 'identifier_token'
  >;

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _count?: VerificationTokenCountOrderByAggregateInput;
    _max?: VerificationTokenMaxOrderByAggregateInput;
    _min?: VerificationTokenMinOrderByAggregateInput;
  };

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    OR?: VerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    identifier?: StringWithAggregatesFilter<'VerificationToken'> | string;
    token?: StringWithAggregatesFilter<'VerificationToken'> | string;
    expires?: DateTimeWithAggregatesFilter<'VerificationToken'> | Date | string;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
    password?: StringNullableFilter<'User'> | string | null;
    name?: StringFilter<'User'> | string;
    role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
    avatar?: StringNullableFilter<'User'> | string | null;
    phone?: StringNullableFilter<'User'> | string | null;
    department?: StringNullableFilter<'User'> | string | null;
    isActive?: BoolFilter<'User'> | boolean;
    twoFactorEnabled?: BoolFilter<'User'> | boolean;
    twoFactorSecret?: StringNullableFilter<'User'> | string | null;
    lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    lastLoginIp?: StringNullableFilter<'User'> | string | null;
    passwordChangedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    accounts?: AccountListRelationFilter;
    sessions?: SessionListRelationFilter;
    services?: ServiceListRelationFilter;
    assignedServices?: ServiceListRelationFilter;
    loadingOrders?: LoadingOrderListRelationFilter;
    invoices?: InvoiceListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    notifications?: NotificationListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    avatar?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    department?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrderInput | SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    lastLoginIp?: SortOrderInput | SortOrder;
    passwordChangedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    accounts?: AccountOrderByRelationAggregateInput;
    sessions?: SessionOrderByRelationAggregateInput;
    services?: ServiceOrderByRelationAggregateInput;
    assignedServices?: ServiceOrderByRelationAggregateInput;
    loadingOrders?: LoadingOrderOrderByRelationAggregateInput;
    invoices?: InvoiceOrderByRelationAggregateInput;
    auditLogs?: AuditLogOrderByRelationAggregateInput;
    notifications?: NotificationOrderByRelationAggregateInput;
    _relevance?: UserOrderByRelevanceInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
      password?: StringNullableFilter<'User'> | string | null;
      name?: StringFilter<'User'> | string;
      role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
      avatar?: StringNullableFilter<'User'> | string | null;
      phone?: StringNullableFilter<'User'> | string | null;
      department?: StringNullableFilter<'User'> | string | null;
      isActive?: BoolFilter<'User'> | boolean;
      twoFactorEnabled?: BoolFilter<'User'> | boolean;
      twoFactorSecret?: StringNullableFilter<'User'> | string | null;
      lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      lastLoginIp?: StringNullableFilter<'User'> | string | null;
      passwordChangedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      accounts?: AccountListRelationFilter;
      sessions?: SessionListRelationFilter;
      services?: ServiceListRelationFilter;
      assignedServices?: ServiceListRelationFilter;
      loadingOrders?: LoadingOrderListRelationFilter;
      invoices?: InvoiceListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      notifications?: NotificationListRelationFilter;
    },
    'id' | 'email'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    avatar?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    department?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrderInput | SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    lastLoginIp?: SortOrderInput | SortOrder;
    passwordChangedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    emailVerified?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    password?: StringNullableWithAggregatesFilter<'User'> | string | null;
    name?: StringWithAggregatesFilter<'User'> | string;
    role?: EnumUserRoleWithAggregatesFilter<'User'> | $Enums.UserRole;
    avatar?: StringNullableWithAggregatesFilter<'User'> | string | null;
    phone?: StringNullableWithAggregatesFilter<'User'> | string | null;
    department?: StringNullableWithAggregatesFilter<'User'> | string | null;
    isActive?: BoolWithAggregatesFilter<'User'> | boolean;
    twoFactorEnabled?: BoolWithAggregatesFilter<'User'> | boolean;
    twoFactorSecret?: StringNullableWithAggregatesFilter<'User'> | string | null;
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    lastLoginIp?: StringNullableWithAggregatesFilter<'User'> | string | null;
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
  };

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[];
    OR?: CompanyWhereInput[];
    NOT?: CompanyWhereInput | CompanyWhereInput[];
    id?: StringFilter<'Company'> | string;
    code?: StringFilter<'Company'> | string;
    legalName?: StringFilter<'Company'> | string;
    tradeName?: StringNullableFilter<'Company'> | string | null;
    vatNumber?: StringFilter<'Company'> | string;
    registrationNo?: StringNullableFilter<'Company'> | string | null;
    addressLine1?: StringFilter<'Company'> | string;
    addressLine2?: StringNullableFilter<'Company'> | string | null;
    city?: StringFilter<'Company'> | string;
    state?: StringNullableFilter<'Company'> | string | null;
    postalCode?: StringFilter<'Company'> | string;
    country?: StringFilter<'Company'> | string;
    phone?: StringFilter<'Company'> | string;
    fax?: StringNullableFilter<'Company'> | string | null;
    email?: StringFilter<'Company'> | string;
    website?: StringNullableFilter<'Company'> | string | null;
    bankName?: StringNullableFilter<'Company'> | string | null;
    bankAccount?: StringNullableFilter<'Company'> | string | null;
    swiftCode?: StringNullableFilter<'Company'> | string | null;
    iban?: StringNullableFilter<'Company'> | string | null;
    currency?: StringFilter<'Company'> | string;
    timezone?: StringFilter<'Company'> | string;
    fiscalYearEnd?: StringNullableFilter<'Company'> | string | null;
    invoicePrefix?: StringNullableFilter<'Company'> | string | null;
    logoUrl?: StringNullableFilter<'Company'> | string | null;
    metadata?: JsonNullableFilter<'Company'>;
    isActive?: BoolFilter<'Company'> | boolean;
    createdAt?: DateTimeFilter<'Company'> | Date | string;
    updatedAt?: DateTimeFilter<'Company'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Company'> | Date | string | null;
    asClient?: ClientListRelationFilter;
    asSupplier?: SupplierListRelationFilter;
  };

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder;
    code?: SortOrder;
    legalName?: SortOrder;
    tradeName?: SortOrderInput | SortOrder;
    vatNumber?: SortOrder;
    registrationNo?: SortOrderInput | SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrderInput | SortOrder;
    city?: SortOrder;
    state?: SortOrderInput | SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    fax?: SortOrderInput | SortOrder;
    email?: SortOrder;
    website?: SortOrderInput | SortOrder;
    bankName?: SortOrderInput | SortOrder;
    bankAccount?: SortOrderInput | SortOrder;
    swiftCode?: SortOrderInput | SortOrder;
    iban?: SortOrderInput | SortOrder;
    currency?: SortOrder;
    timezone?: SortOrder;
    fiscalYearEnd?: SortOrderInput | SortOrder;
    invoicePrefix?: SortOrderInput | SortOrder;
    logoUrl?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    asClient?: ClientOrderByRelationAggregateInput;
    asSupplier?: SupplierOrderByRelationAggregateInput;
    _relevance?: CompanyOrderByRelevanceInput;
  };

  export type CompanyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      code?: string;
      vatNumber?: string;
      AND?: CompanyWhereInput | CompanyWhereInput[];
      OR?: CompanyWhereInput[];
      NOT?: CompanyWhereInput | CompanyWhereInput[];
      legalName?: StringFilter<'Company'> | string;
      tradeName?: StringNullableFilter<'Company'> | string | null;
      registrationNo?: StringNullableFilter<'Company'> | string | null;
      addressLine1?: StringFilter<'Company'> | string;
      addressLine2?: StringNullableFilter<'Company'> | string | null;
      city?: StringFilter<'Company'> | string;
      state?: StringNullableFilter<'Company'> | string | null;
      postalCode?: StringFilter<'Company'> | string;
      country?: StringFilter<'Company'> | string;
      phone?: StringFilter<'Company'> | string;
      fax?: StringNullableFilter<'Company'> | string | null;
      email?: StringFilter<'Company'> | string;
      website?: StringNullableFilter<'Company'> | string | null;
      bankName?: StringNullableFilter<'Company'> | string | null;
      bankAccount?: StringNullableFilter<'Company'> | string | null;
      swiftCode?: StringNullableFilter<'Company'> | string | null;
      iban?: StringNullableFilter<'Company'> | string | null;
      currency?: StringFilter<'Company'> | string;
      timezone?: StringFilter<'Company'> | string;
      fiscalYearEnd?: StringNullableFilter<'Company'> | string | null;
      invoicePrefix?: StringNullableFilter<'Company'> | string | null;
      logoUrl?: StringNullableFilter<'Company'> | string | null;
      metadata?: JsonNullableFilter<'Company'>;
      isActive?: BoolFilter<'Company'> | boolean;
      createdAt?: DateTimeFilter<'Company'> | Date | string;
      updatedAt?: DateTimeFilter<'Company'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Company'> | Date | string | null;
      asClient?: ClientListRelationFilter;
      asSupplier?: SupplierListRelationFilter;
    },
    'id' | 'code' | 'vatNumber'
  >;

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder;
    code?: SortOrder;
    legalName?: SortOrder;
    tradeName?: SortOrderInput | SortOrder;
    vatNumber?: SortOrder;
    registrationNo?: SortOrderInput | SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrderInput | SortOrder;
    city?: SortOrder;
    state?: SortOrderInput | SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    fax?: SortOrderInput | SortOrder;
    email?: SortOrder;
    website?: SortOrderInput | SortOrder;
    bankName?: SortOrderInput | SortOrder;
    bankAccount?: SortOrderInput | SortOrder;
    swiftCode?: SortOrderInput | SortOrder;
    iban?: SortOrderInput | SortOrder;
    currency?: SortOrder;
    timezone?: SortOrder;
    fiscalYearEnd?: SortOrderInput | SortOrder;
    invoicePrefix?: SortOrderInput | SortOrder;
    logoUrl?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: CompanyCountOrderByAggregateInput;
    _max?: CompanyMaxOrderByAggregateInput;
    _min?: CompanyMinOrderByAggregateInput;
  };

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[];
    OR?: CompanyScalarWhereWithAggregatesInput[];
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Company'> | string;
    code?: StringWithAggregatesFilter<'Company'> | string;
    legalName?: StringWithAggregatesFilter<'Company'> | string;
    tradeName?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    vatNumber?: StringWithAggregatesFilter<'Company'> | string;
    registrationNo?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    addressLine1?: StringWithAggregatesFilter<'Company'> | string;
    addressLine2?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    city?: StringWithAggregatesFilter<'Company'> | string;
    state?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    postalCode?: StringWithAggregatesFilter<'Company'> | string;
    country?: StringWithAggregatesFilter<'Company'> | string;
    phone?: StringWithAggregatesFilter<'Company'> | string;
    fax?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    email?: StringWithAggregatesFilter<'Company'> | string;
    website?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    bankName?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    bankAccount?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    swiftCode?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    iban?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    currency?: StringWithAggregatesFilter<'Company'> | string;
    timezone?: StringWithAggregatesFilter<'Company'> | string;
    fiscalYearEnd?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    invoicePrefix?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    logoUrl?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'Company'>;
    isActive?: BoolWithAggregatesFilter<'Company'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Company'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Company'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'Company'> | Date | string | null;
  };

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[];
    OR?: ClientWhereInput[];
    NOT?: ClientWhereInput | ClientWhereInput[];
    id?: StringFilter<'Client'> | string;
    clientCode?: StringFilter<'Client'> | string;
    companyId?: StringNullableFilter<'Client'> | string | null;
    name?: StringFilter<'Client'> | string;
    tradeName?: StringNullableFilter<'Client'> | string | null;
    vatNumber?: StringNullableFilter<'Client'> | string | null;
    billingAddress?: JsonFilter<'Client'>;
    shippingAddress?: JsonNullableFilter<'Client'>;
    billingEmail?: StringFilter<'Client'> | string;
    trafficEmail?: StringNullableFilter<'Client'> | string | null;
    contactPerson?: StringNullableFilter<'Client'> | string | null;
    contactPhone?: StringNullableFilter<'Client'> | string | null;
    contactMobile?: StringNullableFilter<'Client'> | string | null;
    creditLimit?:
      | DecimalNullableFilter<'Client'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFilter<'Client'> | number;
    discount?: DecimalNullableFilter<'Client'> | Decimal | DecimalJsLike | number | string | null;
    currency?: StringFilter<'Client'> | string;
    language?: StringFilter<'Client'> | string;
    sendReminders?: BoolFilter<'Client'> | boolean;
    autoInvoice?: BoolFilter<'Client'> | boolean;
    notes?: StringNullableFilter<'Client'> | string | null;
    tags?: StringNullableListFilter<'Client'>;
    metadata?: JsonNullableFilter<'Client'>;
    isActive?: BoolFilter<'Client'> | boolean;
    createdAt?: DateTimeFilter<'Client'> | Date | string;
    updatedAt?: DateTimeFilter<'Client'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Client'> | Date | string | null;
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null;
    services?: ServiceListRelationFilter;
    contacts?: ClientContactListRelationFilter;
    documents?: DocumentListRelationFilter;
  };

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder;
    clientCode?: SortOrder;
    companyId?: SortOrderInput | SortOrder;
    name?: SortOrder;
    tradeName?: SortOrderInput | SortOrder;
    vatNumber?: SortOrderInput | SortOrder;
    billingAddress?: SortOrder;
    shippingAddress?: SortOrderInput | SortOrder;
    billingEmail?: SortOrder;
    trafficEmail?: SortOrderInput | SortOrder;
    contactPerson?: SortOrderInput | SortOrder;
    contactPhone?: SortOrderInput | SortOrder;
    contactMobile?: SortOrderInput | SortOrder;
    creditLimit?: SortOrderInput | SortOrder;
    paymentTerms?: SortOrder;
    discount?: SortOrderInput | SortOrder;
    currency?: SortOrder;
    language?: SortOrder;
    sendReminders?: SortOrder;
    autoInvoice?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    tags?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    company?: CompanyOrderByWithRelationInput;
    services?: ServiceOrderByRelationAggregateInput;
    contacts?: ClientContactOrderByRelationAggregateInput;
    documents?: DocumentOrderByRelationAggregateInput;
    _relevance?: ClientOrderByRelevanceInput;
  };

  export type ClientWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      clientCode?: string;
      AND?: ClientWhereInput | ClientWhereInput[];
      OR?: ClientWhereInput[];
      NOT?: ClientWhereInput | ClientWhereInput[];
      companyId?: StringNullableFilter<'Client'> | string | null;
      name?: StringFilter<'Client'> | string;
      tradeName?: StringNullableFilter<'Client'> | string | null;
      vatNumber?: StringNullableFilter<'Client'> | string | null;
      billingAddress?: JsonFilter<'Client'>;
      shippingAddress?: JsonNullableFilter<'Client'>;
      billingEmail?: StringFilter<'Client'> | string;
      trafficEmail?: StringNullableFilter<'Client'> | string | null;
      contactPerson?: StringNullableFilter<'Client'> | string | null;
      contactPhone?: StringNullableFilter<'Client'> | string | null;
      contactMobile?: StringNullableFilter<'Client'> | string | null;
      creditLimit?:
        | DecimalNullableFilter<'Client'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      paymentTerms?: IntFilter<'Client'> | number;
      discount?: DecimalNullableFilter<'Client'> | Decimal | DecimalJsLike | number | string | null;
      currency?: StringFilter<'Client'> | string;
      language?: StringFilter<'Client'> | string;
      sendReminders?: BoolFilter<'Client'> | boolean;
      autoInvoice?: BoolFilter<'Client'> | boolean;
      notes?: StringNullableFilter<'Client'> | string | null;
      tags?: StringNullableListFilter<'Client'>;
      metadata?: JsonNullableFilter<'Client'>;
      isActive?: BoolFilter<'Client'> | boolean;
      createdAt?: DateTimeFilter<'Client'> | Date | string;
      updatedAt?: DateTimeFilter<'Client'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Client'> | Date | string | null;
      company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null;
      services?: ServiceListRelationFilter;
      contacts?: ClientContactListRelationFilter;
      documents?: DocumentListRelationFilter;
    },
    'id' | 'clientCode'
  >;

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder;
    clientCode?: SortOrder;
    companyId?: SortOrderInput | SortOrder;
    name?: SortOrder;
    tradeName?: SortOrderInput | SortOrder;
    vatNumber?: SortOrderInput | SortOrder;
    billingAddress?: SortOrder;
    shippingAddress?: SortOrderInput | SortOrder;
    billingEmail?: SortOrder;
    trafficEmail?: SortOrderInput | SortOrder;
    contactPerson?: SortOrderInput | SortOrder;
    contactPhone?: SortOrderInput | SortOrder;
    contactMobile?: SortOrderInput | SortOrder;
    creditLimit?: SortOrderInput | SortOrder;
    paymentTerms?: SortOrder;
    discount?: SortOrderInput | SortOrder;
    currency?: SortOrder;
    language?: SortOrder;
    sendReminders?: SortOrder;
    autoInvoice?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    tags?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: ClientCountOrderByAggregateInput;
    _avg?: ClientAvgOrderByAggregateInput;
    _max?: ClientMaxOrderByAggregateInput;
    _min?: ClientMinOrderByAggregateInput;
    _sum?: ClientSumOrderByAggregateInput;
  };

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[];
    OR?: ClientScalarWhereWithAggregatesInput[];
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Client'> | string;
    clientCode?: StringWithAggregatesFilter<'Client'> | string;
    companyId?: StringNullableWithAggregatesFilter<'Client'> | string | null;
    name?: StringWithAggregatesFilter<'Client'> | string;
    tradeName?: StringNullableWithAggregatesFilter<'Client'> | string | null;
    vatNumber?: StringNullableWithAggregatesFilter<'Client'> | string | null;
    billingAddress?: JsonWithAggregatesFilter<'Client'>;
    shippingAddress?: JsonNullableWithAggregatesFilter<'Client'>;
    billingEmail?: StringWithAggregatesFilter<'Client'> | string;
    trafficEmail?: StringNullableWithAggregatesFilter<'Client'> | string | null;
    contactPerson?: StringNullableWithAggregatesFilter<'Client'> | string | null;
    contactPhone?: StringNullableWithAggregatesFilter<'Client'> | string | null;
    contactMobile?: StringNullableWithAggregatesFilter<'Client'> | string | null;
    creditLimit?:
      | DecimalNullableWithAggregatesFilter<'Client'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntWithAggregatesFilter<'Client'> | number;
    discount?:
      | DecimalNullableWithAggregatesFilter<'Client'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringWithAggregatesFilter<'Client'> | string;
    language?: StringWithAggregatesFilter<'Client'> | string;
    sendReminders?: BoolWithAggregatesFilter<'Client'> | boolean;
    autoInvoice?: BoolWithAggregatesFilter<'Client'> | boolean;
    notes?: StringNullableWithAggregatesFilter<'Client'> | string | null;
    tags?: StringNullableListFilter<'Client'>;
    metadata?: JsonNullableWithAggregatesFilter<'Client'>;
    isActive?: BoolWithAggregatesFilter<'Client'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Client'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Client'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'Client'> | Date | string | null;
  };

  export type ClientContactWhereInput = {
    AND?: ClientContactWhereInput | ClientContactWhereInput[];
    OR?: ClientContactWhereInput[];
    NOT?: ClientContactWhereInput | ClientContactWhereInput[];
    id?: StringFilter<'ClientContact'> | string;
    clientId?: StringFilter<'ClientContact'> | string;
    name?: StringFilter<'ClientContact'> | string;
    position?: StringNullableFilter<'ClientContact'> | string | null;
    email?: StringFilter<'ClientContact'> | string;
    phone?: StringNullableFilter<'ClientContact'> | string | null;
    mobile?: StringNullableFilter<'ClientContact'> | string | null;
    isPrimary?: BoolFilter<'ClientContact'> | boolean;
    createdAt?: DateTimeFilter<'ClientContact'> | Date | string;
    updatedAt?: DateTimeFilter<'ClientContact'> | Date | string;
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>;
  };

  export type ClientContactOrderByWithRelationInput = {
    id?: SortOrder;
    clientId?: SortOrder;
    name?: SortOrder;
    position?: SortOrderInput | SortOrder;
    email?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    mobile?: SortOrderInput | SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    client?: ClientOrderByWithRelationInput;
    _relevance?: ClientContactOrderByRelevanceInput;
  };

  export type ClientContactWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ClientContactWhereInput | ClientContactWhereInput[];
      OR?: ClientContactWhereInput[];
      NOT?: ClientContactWhereInput | ClientContactWhereInput[];
      clientId?: StringFilter<'ClientContact'> | string;
      name?: StringFilter<'ClientContact'> | string;
      position?: StringNullableFilter<'ClientContact'> | string | null;
      email?: StringFilter<'ClientContact'> | string;
      phone?: StringNullableFilter<'ClientContact'> | string | null;
      mobile?: StringNullableFilter<'ClientContact'> | string | null;
      isPrimary?: BoolFilter<'ClientContact'> | boolean;
      createdAt?: DateTimeFilter<'ClientContact'> | Date | string;
      updatedAt?: DateTimeFilter<'ClientContact'> | Date | string;
      client?: XOR<ClientScalarRelationFilter, ClientWhereInput>;
    },
    'id'
  >;

  export type ClientContactOrderByWithAggregationInput = {
    id?: SortOrder;
    clientId?: SortOrder;
    name?: SortOrder;
    position?: SortOrderInput | SortOrder;
    email?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    mobile?: SortOrderInput | SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ClientContactCountOrderByAggregateInput;
    _max?: ClientContactMaxOrderByAggregateInput;
    _min?: ClientContactMinOrderByAggregateInput;
  };

  export type ClientContactScalarWhereWithAggregatesInput = {
    AND?:
      | ClientContactScalarWhereWithAggregatesInput
      | ClientContactScalarWhereWithAggregatesInput[];
    OR?: ClientContactScalarWhereWithAggregatesInput[];
    NOT?:
      | ClientContactScalarWhereWithAggregatesInput
      | ClientContactScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ClientContact'> | string;
    clientId?: StringWithAggregatesFilter<'ClientContact'> | string;
    name?: StringWithAggregatesFilter<'ClientContact'> | string;
    position?: StringNullableWithAggregatesFilter<'ClientContact'> | string | null;
    email?: StringWithAggregatesFilter<'ClientContact'> | string;
    phone?: StringNullableWithAggregatesFilter<'ClientContact'> | string | null;
    mobile?: StringNullableWithAggregatesFilter<'ClientContact'> | string | null;
    isPrimary?: BoolWithAggregatesFilter<'ClientContact'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'ClientContact'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ClientContact'> | Date | string;
  };

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[];
    OR?: SupplierWhereInput[];
    NOT?: SupplierWhereInput | SupplierWhereInput[];
    id?: StringFilter<'Supplier'> | string;
    supplierCode?: StringFilter<'Supplier'> | string;
    companyId?: StringNullableFilter<'Supplier'> | string | null;
    name?: StringFilter<'Supplier'> | string;
    tradeName?: StringNullableFilter<'Supplier'> | string | null;
    vatNumber?: StringNullableFilter<'Supplier'> | string | null;
    addressLine1?: StringFilter<'Supplier'> | string;
    addressLine2?: StringNullableFilter<'Supplier'> | string | null;
    city?: StringFilter<'Supplier'> | string;
    state?: StringNullableFilter<'Supplier'> | string | null;
    postalCode?: StringFilter<'Supplier'> | string;
    country?: StringFilter<'Supplier'> | string;
    email?: StringFilter<'Supplier'> | string;
    phone?: StringNullableFilter<'Supplier'> | string | null;
    fax?: StringNullableFilter<'Supplier'> | string | null;
    contactPerson?: StringNullableFilter<'Supplier'> | string | null;
    contactMobile?: StringNullableFilter<'Supplier'> | string | null;
    irpfRate?: DecimalNullableFilter<'Supplier'> | Decimal | DecimalJsLike | number | string | null;
    vatRate?: DecimalFilter<'Supplier'> | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFilter<'Supplier'> | number;
    paymentMethod?: StringNullableFilter<'Supplier'> | string | null;
    bankName?: StringNullableFilter<'Supplier'> | string | null;
    bankAccount?: StringNullableFilter<'Supplier'> | string | null;
    swiftCode?: StringNullableFilter<'Supplier'> | string | null;
    iban?: StringNullableFilter<'Supplier'> | string | null;
    currency?: StringFilter<'Supplier'> | string;
    autoApprove?: BoolFilter<'Supplier'> | boolean;
    requirePO?: BoolFilter<'Supplier'> | boolean;
    notes?: StringNullableFilter<'Supplier'> | string | null;
    tags?: StringNullableListFilter<'Supplier'>;
    metadata?: JsonNullableFilter<'Supplier'>;
    isActive?: BoolFilter<'Supplier'> | boolean;
    createdAt?: DateTimeFilter<'Supplier'> | Date | string;
    updatedAt?: DateTimeFilter<'Supplier'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Supplier'> | Date | string | null;
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null;
    services?: ServiceListRelationFilter;
    invoices?: InvoiceListRelationFilter;
    documents?: DocumentListRelationFilter;
  };

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder;
    supplierCode?: SortOrder;
    companyId?: SortOrderInput | SortOrder;
    name?: SortOrder;
    tradeName?: SortOrderInput | SortOrder;
    vatNumber?: SortOrderInput | SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrderInput | SortOrder;
    city?: SortOrder;
    state?: SortOrderInput | SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    email?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    fax?: SortOrderInput | SortOrder;
    contactPerson?: SortOrderInput | SortOrder;
    contactMobile?: SortOrderInput | SortOrder;
    irpfRate?: SortOrderInput | SortOrder;
    vatRate?: SortOrder;
    paymentTerms?: SortOrder;
    paymentMethod?: SortOrderInput | SortOrder;
    bankName?: SortOrderInput | SortOrder;
    bankAccount?: SortOrderInput | SortOrder;
    swiftCode?: SortOrderInput | SortOrder;
    iban?: SortOrderInput | SortOrder;
    currency?: SortOrder;
    autoApprove?: SortOrder;
    requirePO?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    tags?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    company?: CompanyOrderByWithRelationInput;
    services?: ServiceOrderByRelationAggregateInput;
    invoices?: InvoiceOrderByRelationAggregateInput;
    documents?: DocumentOrderByRelationAggregateInput;
    _relevance?: SupplierOrderByRelevanceInput;
  };

  export type SupplierWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      supplierCode?: string;
      AND?: SupplierWhereInput | SupplierWhereInput[];
      OR?: SupplierWhereInput[];
      NOT?: SupplierWhereInput | SupplierWhereInput[];
      companyId?: StringNullableFilter<'Supplier'> | string | null;
      name?: StringFilter<'Supplier'> | string;
      tradeName?: StringNullableFilter<'Supplier'> | string | null;
      vatNumber?: StringNullableFilter<'Supplier'> | string | null;
      addressLine1?: StringFilter<'Supplier'> | string;
      addressLine2?: StringNullableFilter<'Supplier'> | string | null;
      city?: StringFilter<'Supplier'> | string;
      state?: StringNullableFilter<'Supplier'> | string | null;
      postalCode?: StringFilter<'Supplier'> | string;
      country?: StringFilter<'Supplier'> | string;
      email?: StringFilter<'Supplier'> | string;
      phone?: StringNullableFilter<'Supplier'> | string | null;
      fax?: StringNullableFilter<'Supplier'> | string | null;
      contactPerson?: StringNullableFilter<'Supplier'> | string | null;
      contactMobile?: StringNullableFilter<'Supplier'> | string | null;
      irpfRate?:
        | DecimalNullableFilter<'Supplier'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      vatRate?: DecimalFilter<'Supplier'> | Decimal | DecimalJsLike | number | string;
      paymentTerms?: IntFilter<'Supplier'> | number;
      paymentMethod?: StringNullableFilter<'Supplier'> | string | null;
      bankName?: StringNullableFilter<'Supplier'> | string | null;
      bankAccount?: StringNullableFilter<'Supplier'> | string | null;
      swiftCode?: StringNullableFilter<'Supplier'> | string | null;
      iban?: StringNullableFilter<'Supplier'> | string | null;
      currency?: StringFilter<'Supplier'> | string;
      autoApprove?: BoolFilter<'Supplier'> | boolean;
      requirePO?: BoolFilter<'Supplier'> | boolean;
      notes?: StringNullableFilter<'Supplier'> | string | null;
      tags?: StringNullableListFilter<'Supplier'>;
      metadata?: JsonNullableFilter<'Supplier'>;
      isActive?: BoolFilter<'Supplier'> | boolean;
      createdAt?: DateTimeFilter<'Supplier'> | Date | string;
      updatedAt?: DateTimeFilter<'Supplier'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Supplier'> | Date | string | null;
      company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null;
      services?: ServiceListRelationFilter;
      invoices?: InvoiceListRelationFilter;
      documents?: DocumentListRelationFilter;
    },
    'id' | 'supplierCode'
  >;

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder;
    supplierCode?: SortOrder;
    companyId?: SortOrderInput | SortOrder;
    name?: SortOrder;
    tradeName?: SortOrderInput | SortOrder;
    vatNumber?: SortOrderInput | SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrderInput | SortOrder;
    city?: SortOrder;
    state?: SortOrderInput | SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    email?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    fax?: SortOrderInput | SortOrder;
    contactPerson?: SortOrderInput | SortOrder;
    contactMobile?: SortOrderInput | SortOrder;
    irpfRate?: SortOrderInput | SortOrder;
    vatRate?: SortOrder;
    paymentTerms?: SortOrder;
    paymentMethod?: SortOrderInput | SortOrder;
    bankName?: SortOrderInput | SortOrder;
    bankAccount?: SortOrderInput | SortOrder;
    swiftCode?: SortOrderInput | SortOrder;
    iban?: SortOrderInput | SortOrder;
    currency?: SortOrder;
    autoApprove?: SortOrder;
    requirePO?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    tags?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: SupplierCountOrderByAggregateInput;
    _avg?: SupplierAvgOrderByAggregateInput;
    _max?: SupplierMaxOrderByAggregateInput;
    _min?: SupplierMinOrderByAggregateInput;
    _sum?: SupplierSumOrderByAggregateInput;
  };

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[];
    OR?: SupplierScalarWhereWithAggregatesInput[];
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Supplier'> | string;
    supplierCode?: StringWithAggregatesFilter<'Supplier'> | string;
    companyId?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    name?: StringWithAggregatesFilter<'Supplier'> | string;
    tradeName?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    vatNumber?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    addressLine1?: StringWithAggregatesFilter<'Supplier'> | string;
    addressLine2?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    city?: StringWithAggregatesFilter<'Supplier'> | string;
    state?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    postalCode?: StringWithAggregatesFilter<'Supplier'> | string;
    country?: StringWithAggregatesFilter<'Supplier'> | string;
    email?: StringWithAggregatesFilter<'Supplier'> | string;
    phone?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    fax?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    contactPerson?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    contactMobile?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    irpfRate?:
      | DecimalNullableWithAggregatesFilter<'Supplier'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalWithAggregatesFilter<'Supplier'> | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntWithAggregatesFilter<'Supplier'> | number;
    paymentMethod?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    bankName?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    bankAccount?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    swiftCode?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    iban?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    currency?: StringWithAggregatesFilter<'Supplier'> | string;
    autoApprove?: BoolWithAggregatesFilter<'Supplier'> | boolean;
    requirePO?: BoolWithAggregatesFilter<'Supplier'> | boolean;
    notes?: StringNullableWithAggregatesFilter<'Supplier'> | string | null;
    tags?: StringNullableListFilter<'Supplier'>;
    metadata?: JsonNullableWithAggregatesFilter<'Supplier'>;
    isActive?: BoolWithAggregatesFilter<'Supplier'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Supplier'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Supplier'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'Supplier'> | Date | string | null;
  };

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[];
    OR?: ServiceWhereInput[];
    NOT?: ServiceWhereInput | ServiceWhereInput[];
    id?: StringFilter<'Service'> | string;
    serviceNumber?: StringFilter<'Service'> | string;
    date?: DateTimeFilter<'Service'> | Date | string;
    clientId?: StringFilter<'Service'> | string;
    supplierId?: StringFilter<'Service'> | string;
    createdById?: StringFilter<'Service'> | string;
    assignedToId?: StringNullableFilter<'Service'> | string | null;
    description?: StringFilter<'Service'> | string;
    reference?: StringNullableFilter<'Service'> | string | null;
    origin?: StringFilter<'Service'> | string;
    destination?: StringFilter<'Service'> | string;
    distance?: IntNullableFilter<'Service'> | number | null;
    vehicleType?: StringNullableFilter<'Service'> | string | null;
    vehiclePlate?: StringNullableFilter<'Service'> | string | null;
    driverName?: StringNullableFilter<'Service'> | string | null;
    costAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFilter<'Service'> | string;
    saleAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFilter<'Service'> | string;
    margin?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    marginPercentage?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    costVatRate?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFilter<'Service'> | $Enums.ServiceStatus;
    completedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
    cancelledAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
    cancellationReason?: StringNullableFilter<'Service'> | string | null;
    archivedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
    notes?: StringNullableFilter<'Service'> | string | null;
    internalNotes?: StringNullableFilter<'Service'> | string | null;
    attachments?: StringNullableListFilter<'Service'>;
    customFields?: JsonNullableFilter<'Service'>;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>;
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    loadingOrders?: ServiceLoadingOrderListRelationFilter;
    invoiceItems?: InvoiceItemListRelationFilter;
    documents?: DocumentListRelationFilter;
    statusHistory?: ServiceStatusHistoryListRelationFilter;
  };

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder;
    serviceNumber?: SortOrder;
    date?: SortOrder;
    clientId?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    assignedToId?: SortOrderInput | SortOrder;
    description?: SortOrder;
    reference?: SortOrderInput | SortOrder;
    origin?: SortOrder;
    destination?: SortOrder;
    distance?: SortOrderInput | SortOrder;
    vehicleType?: SortOrderInput | SortOrder;
    vehiclePlate?: SortOrderInput | SortOrder;
    driverName?: SortOrderInput | SortOrder;
    costAmount?: SortOrder;
    costCurrency?: SortOrder;
    saleAmount?: SortOrder;
    saleCurrency?: SortOrder;
    margin?: SortOrder;
    marginPercentage?: SortOrder;
    costVatRate?: SortOrder;
    costVatAmount?: SortOrder;
    saleVatRate?: SortOrder;
    saleVatAmount?: SortOrder;
    status?: SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    cancelledAt?: SortOrderInput | SortOrder;
    cancellationReason?: SortOrderInput | SortOrder;
    archivedAt?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    internalNotes?: SortOrderInput | SortOrder;
    attachments?: SortOrder;
    customFields?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    client?: ClientOrderByWithRelationInput;
    supplier?: SupplierOrderByWithRelationInput;
    createdBy?: UserOrderByWithRelationInput;
    assignedTo?: UserOrderByWithRelationInput;
    loadingOrders?: ServiceLoadingOrderOrderByRelationAggregateInput;
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput;
    documents?: DocumentOrderByRelationAggregateInput;
    statusHistory?: ServiceStatusHistoryOrderByRelationAggregateInput;
    _relevance?: ServiceOrderByRelevanceInput;
  };

  export type ServiceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      serviceNumber?: string;
      AND?: ServiceWhereInput | ServiceWhereInput[];
      OR?: ServiceWhereInput[];
      NOT?: ServiceWhereInput | ServiceWhereInput[];
      date?: DateTimeFilter<'Service'> | Date | string;
      clientId?: StringFilter<'Service'> | string;
      supplierId?: StringFilter<'Service'> | string;
      createdById?: StringFilter<'Service'> | string;
      assignedToId?: StringNullableFilter<'Service'> | string | null;
      description?: StringFilter<'Service'> | string;
      reference?: StringNullableFilter<'Service'> | string | null;
      origin?: StringFilter<'Service'> | string;
      destination?: StringFilter<'Service'> | string;
      distance?: IntNullableFilter<'Service'> | number | null;
      vehicleType?: StringNullableFilter<'Service'> | string | null;
      vehiclePlate?: StringNullableFilter<'Service'> | string | null;
      driverName?: StringNullableFilter<'Service'> | string | null;
      costAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
      costCurrency?: StringFilter<'Service'> | string;
      saleAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
      saleCurrency?: StringFilter<'Service'> | string;
      margin?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
      marginPercentage?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
      costVatRate?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
      costVatAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
      saleVatRate?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
      saleVatAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
      status?: EnumServiceStatusFilter<'Service'> | $Enums.ServiceStatus;
      completedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
      cancelledAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
      cancellationReason?: StringNullableFilter<'Service'> | string | null;
      archivedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
      notes?: StringNullableFilter<'Service'> | string | null;
      internalNotes?: StringNullableFilter<'Service'> | string | null;
      attachments?: StringNullableListFilter<'Service'>;
      customFields?: JsonNullableFilter<'Service'>;
      createdAt?: DateTimeFilter<'Service'> | Date | string;
      updatedAt?: DateTimeFilter<'Service'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
      client?: XOR<ClientScalarRelationFilter, ClientWhereInput>;
      supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      loadingOrders?: ServiceLoadingOrderListRelationFilter;
      invoiceItems?: InvoiceItemListRelationFilter;
      documents?: DocumentListRelationFilter;
      statusHistory?: ServiceStatusHistoryListRelationFilter;
    },
    'id' | 'serviceNumber'
  >;

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder;
    serviceNumber?: SortOrder;
    date?: SortOrder;
    clientId?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    assignedToId?: SortOrderInput | SortOrder;
    description?: SortOrder;
    reference?: SortOrderInput | SortOrder;
    origin?: SortOrder;
    destination?: SortOrder;
    distance?: SortOrderInput | SortOrder;
    vehicleType?: SortOrderInput | SortOrder;
    vehiclePlate?: SortOrderInput | SortOrder;
    driverName?: SortOrderInput | SortOrder;
    costAmount?: SortOrder;
    costCurrency?: SortOrder;
    saleAmount?: SortOrder;
    saleCurrency?: SortOrder;
    margin?: SortOrder;
    marginPercentage?: SortOrder;
    costVatRate?: SortOrder;
    costVatAmount?: SortOrder;
    saleVatRate?: SortOrder;
    saleVatAmount?: SortOrder;
    status?: SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    cancelledAt?: SortOrderInput | SortOrder;
    cancellationReason?: SortOrderInput | SortOrder;
    archivedAt?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    internalNotes?: SortOrderInput | SortOrder;
    attachments?: SortOrder;
    customFields?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: ServiceCountOrderByAggregateInput;
    _avg?: ServiceAvgOrderByAggregateInput;
    _max?: ServiceMaxOrderByAggregateInput;
    _min?: ServiceMinOrderByAggregateInput;
    _sum?: ServiceSumOrderByAggregateInput;
  };

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[];
    OR?: ServiceScalarWhereWithAggregatesInput[];
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Service'> | string;
    serviceNumber?: StringWithAggregatesFilter<'Service'> | string;
    date?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    clientId?: StringWithAggregatesFilter<'Service'> | string;
    supplierId?: StringWithAggregatesFilter<'Service'> | string;
    createdById?: StringWithAggregatesFilter<'Service'> | string;
    assignedToId?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    description?: StringWithAggregatesFilter<'Service'> | string;
    reference?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    origin?: StringWithAggregatesFilter<'Service'> | string;
    destination?: StringWithAggregatesFilter<'Service'> | string;
    distance?: IntNullableWithAggregatesFilter<'Service'> | number | null;
    vehicleType?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    vehiclePlate?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    driverName?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    costAmount?: DecimalWithAggregatesFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringWithAggregatesFilter<'Service'> | string;
    saleAmount?: DecimalWithAggregatesFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringWithAggregatesFilter<'Service'> | string;
    margin?: DecimalWithAggregatesFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalWithAggregatesFilter<'Service'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?:
      | DecimalWithAggregatesFilter<'Service'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatAmount?:
      | DecimalWithAggregatesFilter<'Service'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    saleVatRate?:
      | DecimalWithAggregatesFilter<'Service'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    saleVatAmount?:
      | DecimalWithAggregatesFilter<'Service'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumServiceStatusWithAggregatesFilter<'Service'> | $Enums.ServiceStatus;
    completedAt?: DateTimeNullableWithAggregatesFilter<'Service'> | Date | string | null;
    cancelledAt?: DateTimeNullableWithAggregatesFilter<'Service'> | Date | string | null;
    cancellationReason?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    archivedAt?: DateTimeNullableWithAggregatesFilter<'Service'> | Date | string | null;
    notes?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    internalNotes?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    attachments?: StringNullableListFilter<'Service'>;
    customFields?: JsonNullableWithAggregatesFilter<'Service'>;
    createdAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'Service'> | Date | string | null;
  };

  export type ServiceStatusHistoryWhereInput = {
    AND?: ServiceStatusHistoryWhereInput | ServiceStatusHistoryWhereInput[];
    OR?: ServiceStatusHistoryWhereInput[];
    NOT?: ServiceStatusHistoryWhereInput | ServiceStatusHistoryWhereInput[];
    id?: StringFilter<'ServiceStatusHistory'> | string;
    serviceId?: StringFilter<'ServiceStatusHistory'> | string;
    fromStatus?:
      | EnumServiceStatusNullableFilter<'ServiceStatusHistory'>
      | $Enums.ServiceStatus
      | null;
    toStatus?: EnumServiceStatusFilter<'ServiceStatusHistory'> | $Enums.ServiceStatus;
    reason?: StringNullableFilter<'ServiceStatusHistory'> | string | null;
    changedBy?: StringFilter<'ServiceStatusHistory'> | string;
    changedAt?: DateTimeFilter<'ServiceStatusHistory'> | Date | string;
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
  };

  export type ServiceStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    fromStatus?: SortOrderInput | SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrderInput | SortOrder;
    changedBy?: SortOrder;
    changedAt?: SortOrder;
    service?: ServiceOrderByWithRelationInput;
    _relevance?: ServiceStatusHistoryOrderByRelevanceInput;
  };

  export type ServiceStatusHistoryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ServiceStatusHistoryWhereInput | ServiceStatusHistoryWhereInput[];
      OR?: ServiceStatusHistoryWhereInput[];
      NOT?: ServiceStatusHistoryWhereInput | ServiceStatusHistoryWhereInput[];
      serviceId?: StringFilter<'ServiceStatusHistory'> | string;
      fromStatus?:
        | EnumServiceStatusNullableFilter<'ServiceStatusHistory'>
        | $Enums.ServiceStatus
        | null;
      toStatus?: EnumServiceStatusFilter<'ServiceStatusHistory'> | $Enums.ServiceStatus;
      reason?: StringNullableFilter<'ServiceStatusHistory'> | string | null;
      changedBy?: StringFilter<'ServiceStatusHistory'> | string;
      changedAt?: DateTimeFilter<'ServiceStatusHistory'> | Date | string;
      service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
    },
    'id'
  >;

  export type ServiceStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    fromStatus?: SortOrderInput | SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrderInput | SortOrder;
    changedBy?: SortOrder;
    changedAt?: SortOrder;
    _count?: ServiceStatusHistoryCountOrderByAggregateInput;
    _max?: ServiceStatusHistoryMaxOrderByAggregateInput;
    _min?: ServiceStatusHistoryMinOrderByAggregateInput;
  };

  export type ServiceStatusHistoryScalarWhereWithAggregatesInput = {
    AND?:
      | ServiceStatusHistoryScalarWhereWithAggregatesInput
      | ServiceStatusHistoryScalarWhereWithAggregatesInput[];
    OR?: ServiceStatusHistoryScalarWhereWithAggregatesInput[];
    NOT?:
      | ServiceStatusHistoryScalarWhereWithAggregatesInput
      | ServiceStatusHistoryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ServiceStatusHistory'> | string;
    serviceId?: StringWithAggregatesFilter<'ServiceStatusHistory'> | string;
    fromStatus?:
      | EnumServiceStatusNullableWithAggregatesFilter<'ServiceStatusHistory'>
      | $Enums.ServiceStatus
      | null;
    toStatus?: EnumServiceStatusWithAggregatesFilter<'ServiceStatusHistory'> | $Enums.ServiceStatus;
    reason?: StringNullableWithAggregatesFilter<'ServiceStatusHistory'> | string | null;
    changedBy?: StringWithAggregatesFilter<'ServiceStatusHistory'> | string;
    changedAt?: DateTimeWithAggregatesFilter<'ServiceStatusHistory'> | Date | string;
  };

  export type LoadingOrderWhereInput = {
    AND?: LoadingOrderWhereInput | LoadingOrderWhereInput[];
    OR?: LoadingOrderWhereInput[];
    NOT?: LoadingOrderWhereInput | LoadingOrderWhereInput[];
    id?: StringFilter<'LoadingOrder'> | string;
    orderNumber?: StringFilter<'LoadingOrder'> | string;
    generatedAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
    generatedById?: StringFilter<'LoadingOrder'> | string;
    clientId?: StringNullableFilter<'LoadingOrder'> | string | null;
    notes?: StringNullableFilter<'LoadingOrder'> | string | null;
    pdfPath?: StringNullableFilter<'LoadingOrder'> | string | null;
    pdfGeneratedAt?: DateTimeNullableFilter<'LoadingOrder'> | Date | string | null;
    pdfSize?: IntNullableFilter<'LoadingOrder'> | number | null;
    metadata?: JsonNullableFilter<'LoadingOrder'>;
    createdAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
    updatedAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'LoadingOrder'> | Date | string | null;
    generatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    services?: ServiceLoadingOrderListRelationFilter;
  };

  export type LoadingOrderOrderByWithRelationInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    generatedAt?: SortOrder;
    generatedById?: SortOrder;
    clientId?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    pdfPath?: SortOrderInput | SortOrder;
    pdfGeneratedAt?: SortOrderInput | SortOrder;
    pdfSize?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    generatedBy?: UserOrderByWithRelationInput;
    services?: ServiceLoadingOrderOrderByRelationAggregateInput;
    _relevance?: LoadingOrderOrderByRelevanceInput;
  };

  export type LoadingOrderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      orderNumber?: string;
      AND?: LoadingOrderWhereInput | LoadingOrderWhereInput[];
      OR?: LoadingOrderWhereInput[];
      NOT?: LoadingOrderWhereInput | LoadingOrderWhereInput[];
      generatedAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
      generatedById?: StringFilter<'LoadingOrder'> | string;
      clientId?: StringNullableFilter<'LoadingOrder'> | string | null;
      notes?: StringNullableFilter<'LoadingOrder'> | string | null;
      pdfPath?: StringNullableFilter<'LoadingOrder'> | string | null;
      pdfGeneratedAt?: DateTimeNullableFilter<'LoadingOrder'> | Date | string | null;
      pdfSize?: IntNullableFilter<'LoadingOrder'> | number | null;
      metadata?: JsonNullableFilter<'LoadingOrder'>;
      createdAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
      updatedAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'LoadingOrder'> | Date | string | null;
      generatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      services?: ServiceLoadingOrderListRelationFilter;
    },
    'id' | 'orderNumber'
  >;

  export type LoadingOrderOrderByWithAggregationInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    generatedAt?: SortOrder;
    generatedById?: SortOrder;
    clientId?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    pdfPath?: SortOrderInput | SortOrder;
    pdfGeneratedAt?: SortOrderInput | SortOrder;
    pdfSize?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: LoadingOrderCountOrderByAggregateInput;
    _avg?: LoadingOrderAvgOrderByAggregateInput;
    _max?: LoadingOrderMaxOrderByAggregateInput;
    _min?: LoadingOrderMinOrderByAggregateInput;
    _sum?: LoadingOrderSumOrderByAggregateInput;
  };

  export type LoadingOrderScalarWhereWithAggregatesInput = {
    AND?: LoadingOrderScalarWhereWithAggregatesInput | LoadingOrderScalarWhereWithAggregatesInput[];
    OR?: LoadingOrderScalarWhereWithAggregatesInput[];
    NOT?: LoadingOrderScalarWhereWithAggregatesInput | LoadingOrderScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'LoadingOrder'> | string;
    orderNumber?: StringWithAggregatesFilter<'LoadingOrder'> | string;
    generatedAt?: DateTimeWithAggregatesFilter<'LoadingOrder'> | Date | string;
    generatedById?: StringWithAggregatesFilter<'LoadingOrder'> | string;
    clientId?: StringNullableWithAggregatesFilter<'LoadingOrder'> | string | null;
    notes?: StringNullableWithAggregatesFilter<'LoadingOrder'> | string | null;
    pdfPath?: StringNullableWithAggregatesFilter<'LoadingOrder'> | string | null;
    pdfGeneratedAt?: DateTimeNullableWithAggregatesFilter<'LoadingOrder'> | Date | string | null;
    pdfSize?: IntNullableWithAggregatesFilter<'LoadingOrder'> | number | null;
    metadata?: JsonNullableWithAggregatesFilter<'LoadingOrder'>;
    createdAt?: DateTimeWithAggregatesFilter<'LoadingOrder'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'LoadingOrder'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'LoadingOrder'> | Date | string | null;
  };

  export type ServiceLoadingOrderWhereInput = {
    AND?: ServiceLoadingOrderWhereInput | ServiceLoadingOrderWhereInput[];
    OR?: ServiceLoadingOrderWhereInput[];
    NOT?: ServiceLoadingOrderWhereInput | ServiceLoadingOrderWhereInput[];
    id?: StringFilter<'ServiceLoadingOrder'> | string;
    serviceId?: StringFilter<'ServiceLoadingOrder'> | string;
    loadingOrderId?: StringFilter<'ServiceLoadingOrder'> | string;
    position?: IntFilter<'ServiceLoadingOrder'> | number;
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
    loadingOrder?: XOR<LoadingOrderScalarRelationFilter, LoadingOrderWhereInput>;
  };

  export type ServiceLoadingOrderOrderByWithRelationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    loadingOrderId?: SortOrder;
    position?: SortOrder;
    service?: ServiceOrderByWithRelationInput;
    loadingOrder?: LoadingOrderOrderByWithRelationInput;
    _relevance?: ServiceLoadingOrderOrderByRelevanceInput;
  };

  export type ServiceLoadingOrderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      serviceId_loadingOrderId?: ServiceLoadingOrderServiceIdLoadingOrderIdCompoundUniqueInput;
      AND?: ServiceLoadingOrderWhereInput | ServiceLoadingOrderWhereInput[];
      OR?: ServiceLoadingOrderWhereInput[];
      NOT?: ServiceLoadingOrderWhereInput | ServiceLoadingOrderWhereInput[];
      serviceId?: StringFilter<'ServiceLoadingOrder'> | string;
      loadingOrderId?: StringFilter<'ServiceLoadingOrder'> | string;
      position?: IntFilter<'ServiceLoadingOrder'> | number;
      service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
      loadingOrder?: XOR<LoadingOrderScalarRelationFilter, LoadingOrderWhereInput>;
    },
    'id' | 'serviceId_loadingOrderId'
  >;

  export type ServiceLoadingOrderOrderByWithAggregationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    loadingOrderId?: SortOrder;
    position?: SortOrder;
    _count?: ServiceLoadingOrderCountOrderByAggregateInput;
    _avg?: ServiceLoadingOrderAvgOrderByAggregateInput;
    _max?: ServiceLoadingOrderMaxOrderByAggregateInput;
    _min?: ServiceLoadingOrderMinOrderByAggregateInput;
    _sum?: ServiceLoadingOrderSumOrderByAggregateInput;
  };

  export type ServiceLoadingOrderScalarWhereWithAggregatesInput = {
    AND?:
      | ServiceLoadingOrderScalarWhereWithAggregatesInput
      | ServiceLoadingOrderScalarWhereWithAggregatesInput[];
    OR?: ServiceLoadingOrderScalarWhereWithAggregatesInput[];
    NOT?:
      | ServiceLoadingOrderScalarWhereWithAggregatesInput
      | ServiceLoadingOrderScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ServiceLoadingOrder'> | string;
    serviceId?: StringWithAggregatesFilter<'ServiceLoadingOrder'> | string;
    loadingOrderId?: StringWithAggregatesFilter<'ServiceLoadingOrder'> | string;
    position?: IntWithAggregatesFilter<'ServiceLoadingOrder'> | number;
  };

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[];
    OR?: InvoiceWhereInput[];
    NOT?: InvoiceWhereInput | InvoiceWhereInput[];
    id?: StringFilter<'Invoice'> | string;
    invoiceNumber?: StringFilter<'Invoice'> | string;
    invoiceDate?: DateTimeFilter<'Invoice'> | Date | string;
    dueDate?: DateTimeFilter<'Invoice'> | Date | string;
    supplierId?: StringFilter<'Invoice'> | string;
    createdById?: StringFilter<'Invoice'> | string;
    subtotal?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    currency?: StringFilter<'Invoice'> | string;
    status?: EnumInvoiceStatusFilter<'Invoice'> | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFilter<'Invoice'> | $Enums.PaymentStatus;
    paidAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    paidAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    paymentMethod?: StringNullableFilter<'Invoice'> | string | null;
    paymentReference?: StringNullableFilter<'Invoice'> | string | null;
    irpfRate?: DecimalNullableFilter<'Invoice'> | Decimal | DecimalJsLike | number | string | null;
    irpfAmount?:
      | DecimalNullableFilter<'Invoice'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: StringNullableFilter<'Invoice'> | string | null;
    notes?: StringNullableFilter<'Invoice'> | string | null;
    termsConditions?: StringNullableFilter<'Invoice'> | string | null;
    pdfPath?: StringNullableFilter<'Invoice'> | string | null;
    pdfGeneratedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    sentAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    sentTo?: StringNullableFilter<'Invoice'> | string | null;
    viewedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    reminderSentAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    metadata?: JsonNullableFilter<'Invoice'>;
    createdAt?: DateTimeFilter<'Invoice'> | Date | string;
    updatedAt?: DateTimeFilter<'Invoice'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    items?: InvoiceItemListRelationFilter;
    payments?: PaymentListRelationFilter;
  };

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    invoiceDate?: SortOrder;
    dueDate?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    totalAmount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrderInput | SortOrder;
    paymentMethod?: SortOrderInput | SortOrder;
    paymentReference?: SortOrderInput | SortOrder;
    irpfRate?: SortOrderInput | SortOrder;
    irpfAmount?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    termsConditions?: SortOrderInput | SortOrder;
    pdfPath?: SortOrderInput | SortOrder;
    pdfGeneratedAt?: SortOrderInput | SortOrder;
    sentAt?: SortOrderInput | SortOrder;
    sentTo?: SortOrderInput | SortOrder;
    viewedAt?: SortOrderInput | SortOrder;
    reminderSentAt?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    supplier?: SupplierOrderByWithRelationInput;
    createdBy?: UserOrderByWithRelationInput;
    items?: InvoiceItemOrderByRelationAggregateInput;
    payments?: PaymentOrderByRelationAggregateInput;
    _relevance?: InvoiceOrderByRelevanceInput;
  };

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      invoiceNumber?: string;
      AND?: InvoiceWhereInput | InvoiceWhereInput[];
      OR?: InvoiceWhereInput[];
      NOT?: InvoiceWhereInput | InvoiceWhereInput[];
      invoiceDate?: DateTimeFilter<'Invoice'> | Date | string;
      dueDate?: DateTimeFilter<'Invoice'> | Date | string;
      supplierId?: StringFilter<'Invoice'> | string;
      createdById?: StringFilter<'Invoice'> | string;
      subtotal?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
      taxAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
      totalAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
      currency?: StringFilter<'Invoice'> | string;
      status?: EnumInvoiceStatusFilter<'Invoice'> | $Enums.InvoiceStatus;
      paymentStatus?: EnumPaymentStatusFilter<'Invoice'> | $Enums.PaymentStatus;
      paidAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
      paidAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
      paymentMethod?: StringNullableFilter<'Invoice'> | string | null;
      paymentReference?: StringNullableFilter<'Invoice'> | string | null;
      irpfRate?:
        | DecimalNullableFilter<'Invoice'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      irpfAmount?:
        | DecimalNullableFilter<'Invoice'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      description?: StringNullableFilter<'Invoice'> | string | null;
      notes?: StringNullableFilter<'Invoice'> | string | null;
      termsConditions?: StringNullableFilter<'Invoice'> | string | null;
      pdfPath?: StringNullableFilter<'Invoice'> | string | null;
      pdfGeneratedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
      sentAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
      sentTo?: StringNullableFilter<'Invoice'> | string | null;
      viewedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
      reminderSentAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
      metadata?: JsonNullableFilter<'Invoice'>;
      createdAt?: DateTimeFilter<'Invoice'> | Date | string;
      updatedAt?: DateTimeFilter<'Invoice'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
      supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      items?: InvoiceItemListRelationFilter;
      payments?: PaymentListRelationFilter;
    },
    'id' | 'invoiceNumber'
  >;

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    invoiceDate?: SortOrder;
    dueDate?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    totalAmount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrderInput | SortOrder;
    paymentMethod?: SortOrderInput | SortOrder;
    paymentReference?: SortOrderInput | SortOrder;
    irpfRate?: SortOrderInput | SortOrder;
    irpfAmount?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    termsConditions?: SortOrderInput | SortOrder;
    pdfPath?: SortOrderInput | SortOrder;
    pdfGeneratedAt?: SortOrderInput | SortOrder;
    sentAt?: SortOrderInput | SortOrder;
    sentTo?: SortOrderInput | SortOrder;
    viewedAt?: SortOrderInput | SortOrder;
    reminderSentAt?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: InvoiceCountOrderByAggregateInput;
    _avg?: InvoiceAvgOrderByAggregateInput;
    _max?: InvoiceMaxOrderByAggregateInput;
    _min?: InvoiceMinOrderByAggregateInput;
    _sum?: InvoiceSumOrderByAggregateInput;
  };

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[];
    OR?: InvoiceScalarWhereWithAggregatesInput[];
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Invoice'> | string;
    invoiceNumber?: StringWithAggregatesFilter<'Invoice'> | string;
    invoiceDate?: DateTimeWithAggregatesFilter<'Invoice'> | Date | string;
    dueDate?: DateTimeWithAggregatesFilter<'Invoice'> | Date | string;
    supplierId?: StringWithAggregatesFilter<'Invoice'> | string;
    createdById?: StringWithAggregatesFilter<'Invoice'> | string;
    subtotal?: DecimalWithAggregatesFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalWithAggregatesFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    totalAmount?:
      | DecimalWithAggregatesFilter<'Invoice'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringWithAggregatesFilter<'Invoice'> | string;
    status?: EnumInvoiceStatusWithAggregatesFilter<'Invoice'> | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<'Invoice'> | $Enums.PaymentStatus;
    paidAmount?: DecimalWithAggregatesFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    paidAt?: DateTimeNullableWithAggregatesFilter<'Invoice'> | Date | string | null;
    paymentMethod?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    paymentReference?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    irpfRate?:
      | DecimalNullableWithAggregatesFilter<'Invoice'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | DecimalNullableWithAggregatesFilter<'Invoice'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    notes?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    termsConditions?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    pdfPath?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    pdfGeneratedAt?: DateTimeNullableWithAggregatesFilter<'Invoice'> | Date | string | null;
    sentAt?: DateTimeNullableWithAggregatesFilter<'Invoice'> | Date | string | null;
    sentTo?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    viewedAt?: DateTimeNullableWithAggregatesFilter<'Invoice'> | Date | string | null;
    reminderSentAt?: DateTimeNullableWithAggregatesFilter<'Invoice'> | Date | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'Invoice'>;
    createdAt?: DateTimeWithAggregatesFilter<'Invoice'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Invoice'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'Invoice'> | Date | string | null;
  };

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[];
    OR?: InvoiceItemWhereInput[];
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[];
    id?: StringFilter<'InvoiceItem'> | string;
    invoiceId?: StringFilter<'InvoiceItem'> | string;
    serviceId?: StringNullableFilter<'InvoiceItem'> | string | null;
    description?: StringFilter<'InvoiceItem'> | string;
    quantity?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>;
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null;
  };

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder;
    invoiceId?: SortOrder;
    serviceId?: SortOrderInput | SortOrder;
    description?: SortOrder;
    quantity?: SortOrder;
    unitPrice?: SortOrder;
    amount?: SortOrder;
    taxRate?: SortOrder;
    taxAmount?: SortOrder;
    invoice?: InvoiceOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
    _relevance?: InvoiceItemOrderByRelevanceInput;
  };

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[];
      OR?: InvoiceItemWhereInput[];
      NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[];
      invoiceId?: StringFilter<'InvoiceItem'> | string;
      serviceId?: StringNullableFilter<'InvoiceItem'> | string | null;
      description?: StringFilter<'InvoiceItem'> | string;
      quantity?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
      unitPrice?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
      amount?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
      taxRate?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
      taxAmount?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
      invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>;
      service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null;
    },
    'id'
  >;

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder;
    invoiceId?: SortOrder;
    serviceId?: SortOrderInput | SortOrder;
    description?: SortOrder;
    quantity?: SortOrder;
    unitPrice?: SortOrder;
    amount?: SortOrder;
    taxRate?: SortOrder;
    taxAmount?: SortOrder;
    _count?: InvoiceItemCountOrderByAggregateInput;
    _avg?: InvoiceItemAvgOrderByAggregateInput;
    _max?: InvoiceItemMaxOrderByAggregateInput;
    _min?: InvoiceItemMinOrderByAggregateInput;
    _sum?: InvoiceItemSumOrderByAggregateInput;
  };

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[];
    OR?: InvoiceItemScalarWhereWithAggregatesInput[];
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'InvoiceItem'> | string;
    invoiceId?: StringWithAggregatesFilter<'InvoiceItem'> | string;
    serviceId?: StringNullableWithAggregatesFilter<'InvoiceItem'> | string | null;
    description?: StringWithAggregatesFilter<'InvoiceItem'> | string;
    quantity?:
      | DecimalWithAggregatesFilter<'InvoiceItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    unitPrice?:
      | DecimalWithAggregatesFilter<'InvoiceItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amount?: DecimalWithAggregatesFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    taxRate?:
      | DecimalWithAggregatesFilter<'InvoiceItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    taxAmount?:
      | DecimalWithAggregatesFilter<'InvoiceItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[];
    OR?: PaymentWhereInput[];
    NOT?: PaymentWhereInput | PaymentWhereInput[];
    id?: StringFilter<'Payment'> | string;
    paymentNumber?: StringFilter<'Payment'> | string;
    invoiceId?: StringFilter<'Payment'> | string;
    amount?: DecimalFilter<'Payment'> | Decimal | DecimalJsLike | number | string;
    currency?: StringFilter<'Payment'> | string;
    paymentDate?: DateTimeFilter<'Payment'> | Date | string;
    paymentMethod?: StringFilter<'Payment'> | string;
    reference?: StringNullableFilter<'Payment'> | string | null;
    status?: EnumPaymentStatusFilter<'Payment'> | $Enums.PaymentStatus;
    notes?: StringNullableFilter<'Payment'> | string | null;
    receiptPath?: StringNullableFilter<'Payment'> | string | null;
    createdAt?: DateTimeFilter<'Payment'> | Date | string;
    updatedAt?: DateTimeFilter<'Payment'> | Date | string;
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>;
  };

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder;
    paymentNumber?: SortOrder;
    invoiceId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    paymentDate?: SortOrder;
    paymentMethod?: SortOrder;
    reference?: SortOrderInput | SortOrder;
    status?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    receiptPath?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    invoice?: InvoiceOrderByWithRelationInput;
    _relevance?: PaymentOrderByRelevanceInput;
  };

  export type PaymentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      paymentNumber?: string;
      AND?: PaymentWhereInput | PaymentWhereInput[];
      OR?: PaymentWhereInput[];
      NOT?: PaymentWhereInput | PaymentWhereInput[];
      invoiceId?: StringFilter<'Payment'> | string;
      amount?: DecimalFilter<'Payment'> | Decimal | DecimalJsLike | number | string;
      currency?: StringFilter<'Payment'> | string;
      paymentDate?: DateTimeFilter<'Payment'> | Date | string;
      paymentMethod?: StringFilter<'Payment'> | string;
      reference?: StringNullableFilter<'Payment'> | string | null;
      status?: EnumPaymentStatusFilter<'Payment'> | $Enums.PaymentStatus;
      notes?: StringNullableFilter<'Payment'> | string | null;
      receiptPath?: StringNullableFilter<'Payment'> | string | null;
      createdAt?: DateTimeFilter<'Payment'> | Date | string;
      updatedAt?: DateTimeFilter<'Payment'> | Date | string;
      invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>;
    },
    'id' | 'paymentNumber'
  >;

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder;
    paymentNumber?: SortOrder;
    invoiceId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    paymentDate?: SortOrder;
    paymentMethod?: SortOrder;
    reference?: SortOrderInput | SortOrder;
    status?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    receiptPath?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PaymentCountOrderByAggregateInput;
    _avg?: PaymentAvgOrderByAggregateInput;
    _max?: PaymentMaxOrderByAggregateInput;
    _min?: PaymentMinOrderByAggregateInput;
    _sum?: PaymentSumOrderByAggregateInput;
  };

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[];
    OR?: PaymentScalarWhereWithAggregatesInput[];
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Payment'> | string;
    paymentNumber?: StringWithAggregatesFilter<'Payment'> | string;
    invoiceId?: StringWithAggregatesFilter<'Payment'> | string;
    amount?: DecimalWithAggregatesFilter<'Payment'> | Decimal | DecimalJsLike | number | string;
    currency?: StringWithAggregatesFilter<'Payment'> | string;
    paymentDate?: DateTimeWithAggregatesFilter<'Payment'> | Date | string;
    paymentMethod?: StringWithAggregatesFilter<'Payment'> | string;
    reference?: StringNullableWithAggregatesFilter<'Payment'> | string | null;
    status?: EnumPaymentStatusWithAggregatesFilter<'Payment'> | $Enums.PaymentStatus;
    notes?: StringNullableWithAggregatesFilter<'Payment'> | string | null;
    receiptPath?: StringNullableWithAggregatesFilter<'Payment'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Payment'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Payment'> | Date | string;
  };

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[];
    OR?: DocumentWhereInput[];
    NOT?: DocumentWhereInput | DocumentWhereInput[];
    id?: StringFilter<'Document'> | string;
    documentType?: EnumDocumentTypeFilter<'Document'> | $Enums.DocumentType;
    documentNumber?: StringNullableFilter<'Document'> | string | null;
    clientId?: StringNullableFilter<'Document'> | string | null;
    supplierId?: StringNullableFilter<'Document'> | string | null;
    serviceId?: StringNullableFilter<'Document'> | string | null;
    fileName?: StringFilter<'Document'> | string;
    filePath?: StringFilter<'Document'> | string;
    fileSize?: IntFilter<'Document'> | number;
    mimeType?: StringFilter<'Document'> | string;
    description?: StringNullableFilter<'Document'> | string | null;
    tags?: StringNullableListFilter<'Document'>;
    metadata?: JsonNullableFilter<'Document'>;
    uploadedBy?: StringFilter<'Document'> | string;
    uploadedAt?: DateTimeFilter<'Document'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Document'> | Date | string | null;
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null;
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null;
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null;
  };

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder;
    documentType?: SortOrder;
    documentNumber?: SortOrderInput | SortOrder;
    clientId?: SortOrderInput | SortOrder;
    supplierId?: SortOrderInput | SortOrder;
    serviceId?: SortOrderInput | SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    mimeType?: SortOrder;
    description?: SortOrderInput | SortOrder;
    tags?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    uploadedBy?: SortOrder;
    uploadedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    client?: ClientOrderByWithRelationInput;
    supplier?: SupplierOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
    _relevance?: DocumentOrderByRelevanceInput;
  };

  export type DocumentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DocumentWhereInput | DocumentWhereInput[];
      OR?: DocumentWhereInput[];
      NOT?: DocumentWhereInput | DocumentWhereInput[];
      documentType?: EnumDocumentTypeFilter<'Document'> | $Enums.DocumentType;
      documentNumber?: StringNullableFilter<'Document'> | string | null;
      clientId?: StringNullableFilter<'Document'> | string | null;
      supplierId?: StringNullableFilter<'Document'> | string | null;
      serviceId?: StringNullableFilter<'Document'> | string | null;
      fileName?: StringFilter<'Document'> | string;
      filePath?: StringFilter<'Document'> | string;
      fileSize?: IntFilter<'Document'> | number;
      mimeType?: StringFilter<'Document'> | string;
      description?: StringNullableFilter<'Document'> | string | null;
      tags?: StringNullableListFilter<'Document'>;
      metadata?: JsonNullableFilter<'Document'>;
      uploadedBy?: StringFilter<'Document'> | string;
      uploadedAt?: DateTimeFilter<'Document'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Document'> | Date | string | null;
      client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null;
      supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null;
      service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null;
    },
    'id'
  >;

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder;
    documentType?: SortOrder;
    documentNumber?: SortOrderInput | SortOrder;
    clientId?: SortOrderInput | SortOrder;
    supplierId?: SortOrderInput | SortOrder;
    serviceId?: SortOrderInput | SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    mimeType?: SortOrder;
    description?: SortOrderInput | SortOrder;
    tags?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    uploadedBy?: SortOrder;
    uploadedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: DocumentCountOrderByAggregateInput;
    _avg?: DocumentAvgOrderByAggregateInput;
    _max?: DocumentMaxOrderByAggregateInput;
    _min?: DocumentMinOrderByAggregateInput;
    _sum?: DocumentSumOrderByAggregateInput;
  };

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[];
    OR?: DocumentScalarWhereWithAggregatesInput[];
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Document'> | string;
    documentType?: EnumDocumentTypeWithAggregatesFilter<'Document'> | $Enums.DocumentType;
    documentNumber?: StringNullableWithAggregatesFilter<'Document'> | string | null;
    clientId?: StringNullableWithAggregatesFilter<'Document'> | string | null;
    supplierId?: StringNullableWithAggregatesFilter<'Document'> | string | null;
    serviceId?: StringNullableWithAggregatesFilter<'Document'> | string | null;
    fileName?: StringWithAggregatesFilter<'Document'> | string;
    filePath?: StringWithAggregatesFilter<'Document'> | string;
    fileSize?: IntWithAggregatesFilter<'Document'> | number;
    mimeType?: StringWithAggregatesFilter<'Document'> | string;
    description?: StringNullableWithAggregatesFilter<'Document'> | string | null;
    tags?: StringNullableListFilter<'Document'>;
    metadata?: JsonNullableWithAggregatesFilter<'Document'>;
    uploadedBy?: StringWithAggregatesFilter<'Document'> | string;
    uploadedAt?: DateTimeWithAggregatesFilter<'Document'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'Document'> | Date | string | null;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    userId?: StringNullableFilter<'AuditLog'> | string | null;
    action?: EnumAuditActionFilter<'AuditLog'> | $Enums.AuditAction;
    tableName?: StringFilter<'AuditLog'> | string;
    recordId?: StringFilter<'AuditLog'> | string;
    oldValues?: JsonNullableFilter<'AuditLog'>;
    newValues?: JsonNullableFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    requestId?: StringNullableFilter<'AuditLog'> | string | null;
    metadata?: JsonNullableFilter<'AuditLog'>;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    oldValues?: SortOrderInput | SortOrder;
    newValues?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    requestId?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    _relevance?: AuditLogOrderByRelevanceInput;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      userId?: StringNullableFilter<'AuditLog'> | string | null;
      action?: EnumAuditActionFilter<'AuditLog'> | $Enums.AuditAction;
      tableName?: StringFilter<'AuditLog'> | string;
      recordId?: StringFilter<'AuditLog'> | string;
      oldValues?: JsonNullableFilter<'AuditLog'>;
      newValues?: JsonNullableFilter<'AuditLog'>;
      ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
      userAgent?: StringNullableFilter<'AuditLog'> | string | null;
      requestId?: StringNullableFilter<'AuditLog'> | string | null;
      metadata?: JsonNullableFilter<'AuditLog'>;
      createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    oldValues?: SortOrderInput | SortOrder;
    newValues?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    requestId?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AuditLog'> | string;
    userId?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    action?: EnumAuditActionWithAggregatesFilter<'AuditLog'> | $Enums.AuditAction;
    tableName?: StringWithAggregatesFilter<'AuditLog'> | string;
    recordId?: StringWithAggregatesFilter<'AuditLog'> | string;
    oldValues?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    newValues?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    ipAddress?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    requestId?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    createdAt?: DateTimeWithAggregatesFilter<'AuditLog'> | Date | string;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    type?: StringFilter<'Notification'> | string;
    category?: StringFilter<'Notification'> | string;
    actionUrl?: StringNullableFilter<'Notification'> | string | null;
    actionLabel?: StringNullableFilter<'Notification'> | string | null;
    isRead?: BoolFilter<'Notification'> | boolean;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    actionUrl?: SortOrderInput | SortOrder;
    actionLabel?: SortOrderInput | SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    _relevance?: NotificationOrderByRelevanceInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      userId?: StringFilter<'Notification'> | string;
      title?: StringFilter<'Notification'> | string;
      message?: StringFilter<'Notification'> | string;
      type?: StringFilter<'Notification'> | string;
      category?: StringFilter<'Notification'> | string;
      actionUrl?: StringNullableFilter<'Notification'> | string | null;
      actionLabel?: StringNullableFilter<'Notification'> | string | null;
      isRead?: BoolFilter<'Notification'> | boolean;
      readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      createdAt?: DateTimeFilter<'Notification'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    actionUrl?: SortOrderInput | SortOrder;
    actionLabel?: SortOrderInput | SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Notification'> | string;
    userId?: StringWithAggregatesFilter<'Notification'> | string;
    title?: StringWithAggregatesFilter<'Notification'> | string;
    message?: StringWithAggregatesFilter<'Notification'> | string;
    type?: StringWithAggregatesFilter<'Notification'> | string;
    category?: StringWithAggregatesFilter<'Notification'> | string;
    actionUrl?: StringNullableWithAggregatesFilter<'Notification'> | string | null;
    actionLabel?: StringNullableWithAggregatesFilter<'Notification'> | string | null;
    isRead?: BoolWithAggregatesFilter<'Notification'> | boolean;
    readAt?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
  };

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[];
    OR?: SystemSettingWhereInput[];
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[];
    id?: StringFilter<'SystemSetting'> | string;
    key?: StringFilter<'SystemSetting'> | string;
    value?: JsonFilter<'SystemSetting'>;
    description?: StringNullableFilter<'SystemSetting'> | string | null;
    isPublic?: BoolFilter<'SystemSetting'> | boolean;
    createdAt?: DateTimeFilter<'SystemSetting'> | Date | string;
    updatedAt?: DateTimeFilter<'SystemSetting'> | Date | string;
  };

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder;
    key?: SortOrder;
    value?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isPublic?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _relevance?: SystemSettingOrderByRelevanceInput;
  };

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      key?: string;
      AND?: SystemSettingWhereInput | SystemSettingWhereInput[];
      OR?: SystemSettingWhereInput[];
      NOT?: SystemSettingWhereInput | SystemSettingWhereInput[];
      value?: JsonFilter<'SystemSetting'>;
      description?: StringNullableFilter<'SystemSetting'> | string | null;
      isPublic?: BoolFilter<'SystemSetting'> | boolean;
      createdAt?: DateTimeFilter<'SystemSetting'> | Date | string;
      updatedAt?: DateTimeFilter<'SystemSetting'> | Date | string;
    },
    'id' | 'key'
  >;

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder;
    key?: SortOrder;
    value?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isPublic?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SystemSettingCountOrderByAggregateInput;
    _max?: SystemSettingMaxOrderByAggregateInput;
    _min?: SystemSettingMinOrderByAggregateInput;
  };

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?:
      | SystemSettingScalarWhereWithAggregatesInput
      | SystemSettingScalarWhereWithAggregatesInput[];
    OR?: SystemSettingScalarWhereWithAggregatesInput[];
    NOT?:
      | SystemSettingScalarWhereWithAggregatesInput
      | SystemSettingScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'SystemSetting'> | string;
    key?: StringWithAggregatesFilter<'SystemSetting'> | string;
    value?: JsonWithAggregatesFilter<'SystemSetting'>;
    description?: StringNullableWithAggregatesFilter<'SystemSetting'> | string | null;
    isPublic?: BoolWithAggregatesFilter<'SystemSetting'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'SystemSetting'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'SystemSetting'> | Date | string;
  };

  export type AccountCreateInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    user: UserCreateNestedOneWithoutAccountsInput;
  };

  export type AccountUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountCreateManyInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionCreateInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateManyInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateManyInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceUncheckedCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUncheckedUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type CompanyCreateInput = {
    id?: string;
    code: string;
    legalName: string;
    tradeName?: string | null;
    vatNumber: string;
    registrationNo?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    phone: string;
    fax?: string | null;
    email: string;
    website?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    timezone?: string;
    fiscalYearEnd?: string | null;
    invoicePrefix?: string | null;
    logoUrl?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    asClient?: ClientCreateNestedManyWithoutCompanyInput;
    asSupplier?: SupplierCreateNestedManyWithoutCompanyInput;
  };

  export type CompanyUncheckedCreateInput = {
    id?: string;
    code: string;
    legalName: string;
    tradeName?: string | null;
    vatNumber: string;
    registrationNo?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    phone: string;
    fax?: string | null;
    email: string;
    website?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    timezone?: string;
    fiscalYearEnd?: string | null;
    invoicePrefix?: string | null;
    logoUrl?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    asClient?: ClientUncheckedCreateNestedManyWithoutCompanyInput;
    asSupplier?: SupplierUncheckedCreateNestedManyWithoutCompanyInput;
  };

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    legalName?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: StringFieldUpdateOperationsInput | string;
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    timezone?: StringFieldUpdateOperationsInput | string;
    fiscalYearEnd?: NullableStringFieldUpdateOperationsInput | string | null;
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    asClient?: ClientUpdateManyWithoutCompanyNestedInput;
    asSupplier?: SupplierUpdateManyWithoutCompanyNestedInput;
  };

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    legalName?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: StringFieldUpdateOperationsInput | string;
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    timezone?: StringFieldUpdateOperationsInput | string;
    fiscalYearEnd?: NullableStringFieldUpdateOperationsInput | string | null;
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    asClient?: ClientUncheckedUpdateManyWithoutCompanyNestedInput;
    asSupplier?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput;
  };

  export type CompanyCreateManyInput = {
    id?: string;
    code: string;
    legalName: string;
    tradeName?: string | null;
    vatNumber: string;
    registrationNo?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    phone: string;
    fax?: string | null;
    email: string;
    website?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    timezone?: string;
    fiscalYearEnd?: string | null;
    invoicePrefix?: string | null;
    logoUrl?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    legalName?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: StringFieldUpdateOperationsInput | string;
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    timezone?: StringFieldUpdateOperationsInput | string;
    fiscalYearEnd?: NullableStringFieldUpdateOperationsInput | string | null;
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    legalName?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: StringFieldUpdateOperationsInput | string;
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    timezone?: StringFieldUpdateOperationsInput | string;
    fiscalYearEnd?: NullableStringFieldUpdateOperationsInput | string | null;
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ClientCreateInput = {
    id?: string;
    clientCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    company?: CompanyCreateNestedOneWithoutAsClientInput;
    services?: ServiceCreateNestedManyWithoutClientInput;
    contacts?: ClientContactCreateNestedManyWithoutClientInput;
    documents?: DocumentCreateNestedManyWithoutClientInput;
  };

  export type ClientUncheckedCreateInput = {
    id?: string;
    clientCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutClientInput;
    contacts?: ClientContactUncheckedCreateNestedManyWithoutClientInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    company?: CompanyUpdateOneWithoutAsClientNestedInput;
    services?: ServiceUpdateManyWithoutClientNestedInput;
    contacts?: ClientContactUpdateManyWithoutClientNestedInput;
    documents?: DocumentUpdateManyWithoutClientNestedInput;
  };

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUncheckedUpdateManyWithoutClientNestedInput;
    contacts?: ClientContactUncheckedUpdateManyWithoutClientNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type ClientCreateManyInput = {
    id?: string;
    clientCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ClientContactCreateInput = {
    id?: string;
    name: string;
    position?: string | null;
    email: string;
    phone?: string | null;
    mobile?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    client: ClientCreateNestedOneWithoutContactsInput;
  };

  export type ClientContactUncheckedCreateInput = {
    id?: string;
    clientId: string;
    name: string;
    position?: string | null;
    email: string;
    phone?: string | null;
    mobile?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ClientContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    position?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    client?: ClientUpdateOneRequiredWithoutContactsNestedInput;
  };

  export type ClientContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    position?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ClientContactCreateManyInput = {
    id?: string;
    clientId: string;
    name: string;
    position?: string | null;
    email: string;
    phone?: string | null;
    mobile?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ClientContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    position?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ClientContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    position?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SupplierCreateInput = {
    id?: string;
    supplierCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    company?: CompanyCreateNestedOneWithoutAsSupplierInput;
    services?: ServiceCreateNestedManyWithoutSupplierInput;
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput;
    documents?: DocumentCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierUncheckedCreateInput = {
    id?: string;
    supplierCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutSupplierInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    company?: CompanyUpdateOneWithoutAsSupplierNestedInput;
    services?: ServiceUpdateManyWithoutSupplierNestedInput;
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput;
    documents?: DocumentUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUncheckedUpdateManyWithoutSupplierNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierCreateManyInput = {
    id?: string;
    supplierCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceCreateInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    client: ClientCreateNestedOneWithoutServicesInput;
    supplier: SupplierCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
    assignedTo?: UserCreateNestedOneWithoutAssignedServicesInput;
    loadingOrders?: ServiceLoadingOrderCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput;
    documents?: DocumentCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneRequiredWithoutServicesNestedInput;
    supplier?: SupplierUpdateOneRequiredWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
    assignedTo?: UserUpdateOneWithoutAssignedServicesNestedInput;
    loadingOrders?: ServiceLoadingOrderUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceCreateManyInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceStatusHistoryCreateInput = {
    id?: string;
    fromStatus?: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus;
    reason?: string | null;
    changedBy: string;
    changedAt?: Date | string;
    service: ServiceCreateNestedOneWithoutStatusHistoryInput;
  };

  export type ServiceStatusHistoryUncheckedCreateInput = {
    id?: string;
    serviceId: string;
    fromStatus?: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus;
    reason?: string | null;
    changedBy: string;
    changedAt?: Date | string;
  };

  export type ServiceStatusHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?: NullableEnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus | null;
    toStatus?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: StringFieldUpdateOperationsInput | string;
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    service?: ServiceUpdateOneRequiredWithoutStatusHistoryNestedInput;
  };

  export type ServiceStatusHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    fromStatus?: NullableEnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus | null;
    toStatus?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: StringFieldUpdateOperationsInput | string;
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceStatusHistoryCreateManyInput = {
    id?: string;
    serviceId: string;
    fromStatus?: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus;
    reason?: string | null;
    changedBy: string;
    changedAt?: Date | string;
  };

  export type ServiceStatusHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?: NullableEnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus | null;
    toStatus?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: StringFieldUpdateOperationsInput | string;
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceStatusHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    fromStatus?: NullableEnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus | null;
    toStatus?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: StringFieldUpdateOperationsInput | string;
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LoadingOrderCreateInput = {
    id?: string;
    orderNumber: string;
    generatedAt?: Date | string;
    clientId?: string | null;
    notes?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    pdfSize?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    generatedBy: UserCreateNestedOneWithoutLoadingOrdersInput;
    services?: ServiceLoadingOrderCreateNestedManyWithoutLoadingOrderInput;
  };

  export type LoadingOrderUncheckedCreateInput = {
    id?: string;
    orderNumber: string;
    generatedAt?: Date | string;
    generatedById: string;
    clientId?: string | null;
    notes?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    pdfSize?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutLoadingOrderInput;
  };

  export type LoadingOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    generatedBy?: UserUpdateOneRequiredWithoutLoadingOrdersNestedInput;
    services?: ServiceLoadingOrderUpdateManyWithoutLoadingOrderNestedInput;
  };

  export type LoadingOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    generatedById?: StringFieldUpdateOperationsInput | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceLoadingOrderUncheckedUpdateManyWithoutLoadingOrderNestedInput;
  };

  export type LoadingOrderCreateManyInput = {
    id?: string;
    orderNumber: string;
    generatedAt?: Date | string;
    generatedById: string;
    clientId?: string | null;
    notes?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    pdfSize?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type LoadingOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type LoadingOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    generatedById?: StringFieldUpdateOperationsInput | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceLoadingOrderCreateInput = {
    id?: string;
    position: number;
    service: ServiceCreateNestedOneWithoutLoadingOrdersInput;
    loadingOrder: LoadingOrderCreateNestedOneWithoutServicesInput;
  };

  export type ServiceLoadingOrderUncheckedCreateInput = {
    id?: string;
    serviceId: string;
    loadingOrderId: string;
    position: number;
  };

  export type ServiceLoadingOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
    service?: ServiceUpdateOneRequiredWithoutLoadingOrdersNestedInput;
    loadingOrder?: LoadingOrderUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceLoadingOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    loadingOrderId?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type ServiceLoadingOrderCreateManyInput = {
    id?: string;
    serviceId: string;
    loadingOrderId: string;
    position: number;
  };

  export type ServiceLoadingOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type ServiceLoadingOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    loadingOrderId?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type InvoiceCreateInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    supplier: SupplierCreateNestedOneWithoutInvoicesInput;
    createdBy: UserCreateNestedOneWithoutInvoicesInput;
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput;
    payments?: PaymentCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceUncheckedCreateInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    supplierId: string;
    createdById: string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    supplier?: SupplierUpdateOneRequiredWithoutInvoicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutInvoicesNestedInput;
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput;
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoiceCreateManyInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    supplierId: string;
    createdById: string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type InvoiceItemCreateInput = {
    id?: string;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    invoice: InvoiceCreateNestedOneWithoutItemsInput;
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput;
  };

  export type InvoiceItemUncheckedCreateInput = {
    id?: string;
    invoiceId: string;
    serviceId?: string | null;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
  };

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput;
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput;
  };

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceId?: StringFieldUpdateOperationsInput | string;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
  };

  export type InvoiceItemCreateManyInput = {
    id?: string;
    invoiceId: string;
    serviceId?: string | null;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
  };

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
  };

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceId?: StringFieldUpdateOperationsInput | string;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
  };

  export type PaymentCreateInput = {
    id?: string;
    paymentNumber: string;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    paymentDate: Date | string;
    paymentMethod: string;
    reference?: string | null;
    status?: $Enums.PaymentStatus;
    notes?: string | null;
    receiptPath?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput;
  };

  export type PaymentUncheckedCreateInput = {
    id?: string;
    paymentNumber: string;
    invoiceId: string;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    paymentDate: Date | string;
    paymentMethod: string;
    reference?: string | null;
    status?: $Enums.PaymentStatus;
    notes?: string | null;
    receiptPath?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paymentNumber?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMethod?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput;
  };

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paymentNumber?: StringFieldUpdateOperationsInput | string;
    invoiceId?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMethod?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentCreateManyInput = {
    id?: string;
    paymentNumber: string;
    invoiceId: string;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    paymentDate: Date | string;
    paymentMethod: string;
    reference?: string | null;
    status?: $Enums.PaymentStatus;
    notes?: string | null;
    receiptPath?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paymentNumber?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMethod?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paymentNumber?: StringFieldUpdateOperationsInput | string;
    invoiceId?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMethod?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentCreateInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
    client?: ClientCreateNestedOneWithoutDocumentsInput;
    supplier?: SupplierCreateNestedOneWithoutDocumentsInput;
    service?: ServiceCreateNestedOneWithoutDocumentsInput;
  };

  export type DocumentUncheckedCreateInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    clientId?: string | null;
    supplierId?: string | null;
    serviceId?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneWithoutDocumentsNestedInput;
    supplier?: SupplierUpdateOneWithoutDocumentsNestedInput;
    service?: ServiceUpdateOneWithoutDocumentsNestedInput;
  };

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type DocumentCreateManyInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    clientId?: string | null;
    supplierId?: string | null;
    serviceId?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type AuditLogCreateInput = {
    id?: string;
    action: $Enums.AuditAction;
    tableName: string;
    recordId: string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    requestId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutAuditLogsInput;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: string;
    userId?: string | null;
    action: $Enums.AuditAction;
    tableName: string;
    recordId: string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    requestId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    requestId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    requestId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateManyInput = {
    id?: string;
    userId?: string | null;
    action: $Enums.AuditAction;
    tableName: string;
    recordId: string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    requestId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    requestId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    requestId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    category: string;
    actionUrl?: string | null;
    actionLabel?: string | null;
    isRead?: boolean;
    readAt?: Date | string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateInput = {
    id?: string;
    userId: string;
    title: string;
    message: string;
    type: string;
    category: string;
    actionUrl?: string | null;
    actionLabel?: string | null;
    isRead?: boolean;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateManyInput = {
    id?: string;
    userId: string;
    title: string;
    message: string;
    type: string;
    category: string;
    actionUrl?: string | null;
    actionLabel?: string | null;
    isRead?: boolean;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SystemSettingCreateInput = {
    id?: string;
    key: string;
    value: JsonNullValueInput | InputJsonValue;
    description?: string | null;
    isPublic?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SystemSettingUncheckedCreateInput = {
    id?: string;
    key: string;
    value: JsonNullValueInput | InputJsonValue;
    description?: string | null;
    isPublic?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    key?: StringFieldUpdateOperationsInput | string;
    value?: JsonNullValueInput | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    key?: StringFieldUpdateOperationsInput | string;
    value?: JsonNullValueInput | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SystemSettingCreateManyInput = {
    id?: string;
    key: string;
    value: JsonNullValueInput | InputJsonValue;
    description?: string | null;
    isPublic?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    key?: StringFieldUpdateOperationsInput | string;
    value?: JsonNullValueInput | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    key?: StringFieldUpdateOperationsInput | string;
    value?: JsonNullValueInput | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string;
    providerAccountId: string;
  };

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type VerificationTokenOrderByRelevanceInput = {
    fields:
      | VerificationTokenOrderByRelevanceFieldEnum
      | VerificationTokenOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string;
    token: string;
  };

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput;
    some?: ServiceWhereInput;
    none?: ServiceWhereInput;
  };

  export type LoadingOrderListRelationFilter = {
    every?: LoadingOrderWhereInput;
    some?: LoadingOrderWhereInput;
    none?: LoadingOrderWhereInput;
  };

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput;
    some?: InvoiceWhereInput;
    none?: InvoiceWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LoadingOrderOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    password?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    avatar?: SortOrder;
    phone?: SortOrder;
    department?: SortOrder;
    isActive?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    lastLoginAt?: SortOrder;
    lastLoginIp?: SortOrder;
    passwordChangedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    password?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    avatar?: SortOrder;
    phone?: SortOrder;
    department?: SortOrder;
    isActive?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    lastLoginAt?: SortOrder;
    lastLoginIp?: SortOrder;
    passwordChangedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    password?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    avatar?: SortOrder;
    phone?: SortOrder;
    department?: SortOrder;
    isActive?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    lastLoginAt?: SortOrder;
    lastLoginIp?: SortOrder;
    passwordChangedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type ClientListRelationFilter = {
    every?: ClientWhereInput;
    some?: ClientWhereInput;
    none?: ClientWhereInput;
  };

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput;
    some?: SupplierWhereInput;
    none?: SupplierWhereInput;
  };

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CompanyOrderByRelevanceInput = {
    fields: CompanyOrderByRelevanceFieldEnum | CompanyOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    legalName?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    registrationNo?: SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    fax?: SortOrder;
    email?: SortOrder;
    website?: SortOrder;
    bankName?: SortOrder;
    bankAccount?: SortOrder;
    swiftCode?: SortOrder;
    iban?: SortOrder;
    currency?: SortOrder;
    timezone?: SortOrder;
    fiscalYearEnd?: SortOrder;
    invoicePrefix?: SortOrder;
    logoUrl?: SortOrder;
    metadata?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    legalName?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    registrationNo?: SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    fax?: SortOrder;
    email?: SortOrder;
    website?: SortOrder;
    bankName?: SortOrder;
    bankAccount?: SortOrder;
    swiftCode?: SortOrder;
    iban?: SortOrder;
    currency?: SortOrder;
    timezone?: SortOrder;
    fiscalYearEnd?: SortOrder;
    invoicePrefix?: SortOrder;
    logoUrl?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    legalName?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    registrationNo?: SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    fax?: SortOrder;
    email?: SortOrder;
    website?: SortOrder;
    bankName?: SortOrder;
    bankAccount?: SortOrder;
    swiftCode?: SortOrder;
    iban?: SortOrder;
    currency?: SortOrder;
    timezone?: SortOrder;
    fiscalYearEnd?: SortOrder;
    invoicePrefix?: SortOrder;
    logoUrl?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null;
    isNot?: CompanyWhereInput | null;
  };

  export type ClientContactListRelationFilter = {
    every?: ClientContactWhereInput;
    some?: ClientContactWhereInput;
    none?: ClientContactWhereInput;
  };

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput;
    some?: DocumentWhereInput;
    none?: DocumentWhereInput;
  };

  export type ClientContactOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ClientOrderByRelevanceInput = {
    fields: ClientOrderByRelevanceFieldEnum | ClientOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder;
    clientCode?: SortOrder;
    companyId?: SortOrder;
    name?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    billingAddress?: SortOrder;
    shippingAddress?: SortOrder;
    billingEmail?: SortOrder;
    trafficEmail?: SortOrder;
    contactPerson?: SortOrder;
    contactPhone?: SortOrder;
    contactMobile?: SortOrder;
    creditLimit?: SortOrder;
    paymentTerms?: SortOrder;
    discount?: SortOrder;
    currency?: SortOrder;
    language?: SortOrder;
    sendReminders?: SortOrder;
    autoInvoice?: SortOrder;
    notes?: SortOrder;
    tags?: SortOrder;
    metadata?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ClientAvgOrderByAggregateInput = {
    creditLimit?: SortOrder;
    paymentTerms?: SortOrder;
    discount?: SortOrder;
  };

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder;
    clientCode?: SortOrder;
    companyId?: SortOrder;
    name?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    billingEmail?: SortOrder;
    trafficEmail?: SortOrder;
    contactPerson?: SortOrder;
    contactPhone?: SortOrder;
    contactMobile?: SortOrder;
    creditLimit?: SortOrder;
    paymentTerms?: SortOrder;
    discount?: SortOrder;
    currency?: SortOrder;
    language?: SortOrder;
    sendReminders?: SortOrder;
    autoInvoice?: SortOrder;
    notes?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder;
    clientCode?: SortOrder;
    companyId?: SortOrder;
    name?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    billingEmail?: SortOrder;
    trafficEmail?: SortOrder;
    contactPerson?: SortOrder;
    contactPhone?: SortOrder;
    contactMobile?: SortOrder;
    creditLimit?: SortOrder;
    paymentTerms?: SortOrder;
    discount?: SortOrder;
    currency?: SortOrder;
    language?: SortOrder;
    sendReminders?: SortOrder;
    autoInvoice?: SortOrder;
    notes?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ClientSumOrderByAggregateInput = {
    creditLimit?: SortOrder;
    paymentTerms?: SortOrder;
    discount?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput;
    isNot?: ClientWhereInput;
  };

  export type ClientContactOrderByRelevanceInput = {
    fields: ClientContactOrderByRelevanceFieldEnum | ClientContactOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ClientContactCountOrderByAggregateInput = {
    id?: SortOrder;
    clientId?: SortOrder;
    name?: SortOrder;
    position?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    mobile?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ClientContactMaxOrderByAggregateInput = {
    id?: SortOrder;
    clientId?: SortOrder;
    name?: SortOrder;
    position?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    mobile?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ClientContactMinOrderByAggregateInput = {
    id?: SortOrder;
    clientId?: SortOrder;
    name?: SortOrder;
    position?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    mobile?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string;
  };

  export type SupplierOrderByRelevanceInput = {
    fields: SupplierOrderByRelevanceFieldEnum | SupplierOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder;
    supplierCode?: SortOrder;
    companyId?: SortOrder;
    name?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    fax?: SortOrder;
    contactPerson?: SortOrder;
    contactMobile?: SortOrder;
    irpfRate?: SortOrder;
    vatRate?: SortOrder;
    paymentTerms?: SortOrder;
    paymentMethod?: SortOrder;
    bankName?: SortOrder;
    bankAccount?: SortOrder;
    swiftCode?: SortOrder;
    iban?: SortOrder;
    currency?: SortOrder;
    autoApprove?: SortOrder;
    requirePO?: SortOrder;
    notes?: SortOrder;
    tags?: SortOrder;
    metadata?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type SupplierAvgOrderByAggregateInput = {
    irpfRate?: SortOrder;
    vatRate?: SortOrder;
    paymentTerms?: SortOrder;
  };

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder;
    supplierCode?: SortOrder;
    companyId?: SortOrder;
    name?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    fax?: SortOrder;
    contactPerson?: SortOrder;
    contactMobile?: SortOrder;
    irpfRate?: SortOrder;
    vatRate?: SortOrder;
    paymentTerms?: SortOrder;
    paymentMethod?: SortOrder;
    bankName?: SortOrder;
    bankAccount?: SortOrder;
    swiftCode?: SortOrder;
    iban?: SortOrder;
    currency?: SortOrder;
    autoApprove?: SortOrder;
    requirePO?: SortOrder;
    notes?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder;
    supplierCode?: SortOrder;
    companyId?: SortOrder;
    name?: SortOrder;
    tradeName?: SortOrder;
    vatNumber?: SortOrder;
    addressLine1?: SortOrder;
    addressLine2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    fax?: SortOrder;
    contactPerson?: SortOrder;
    contactMobile?: SortOrder;
    irpfRate?: SortOrder;
    vatRate?: SortOrder;
    paymentTerms?: SortOrder;
    paymentMethod?: SortOrder;
    bankName?: SortOrder;
    bankAccount?: SortOrder;
    swiftCode?: SortOrder;
    iban?: SortOrder;
    currency?: SortOrder;
    autoApprove?: SortOrder;
    requirePO?: SortOrder;
    notes?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type SupplierSumOrderByAggregateInput = {
    irpfRate?: SortOrder;
    vatRate?: SortOrder;
    paymentTerms?: SortOrder;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type EnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus;
  };

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput;
    isNot?: SupplierWhereInput;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type ServiceLoadingOrderListRelationFilter = {
    every?: ServiceLoadingOrderWhereInput;
    some?: ServiceLoadingOrderWhereInput;
    none?: ServiceLoadingOrderWhereInput;
  };

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput;
    some?: InvoiceItemWhereInput;
    none?: InvoiceItemWhereInput;
  };

  export type ServiceStatusHistoryListRelationFilter = {
    every?: ServiceStatusHistoryWhereInput;
    some?: ServiceStatusHistoryWhereInput;
    none?: ServiceStatusHistoryWhereInput;
  };

  export type ServiceLoadingOrderOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceOrderByRelevanceInput = {
    fields: ServiceOrderByRelevanceFieldEnum | ServiceOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder;
    serviceNumber?: SortOrder;
    date?: SortOrder;
    clientId?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    assignedToId?: SortOrder;
    description?: SortOrder;
    reference?: SortOrder;
    origin?: SortOrder;
    destination?: SortOrder;
    distance?: SortOrder;
    vehicleType?: SortOrder;
    vehiclePlate?: SortOrder;
    driverName?: SortOrder;
    costAmount?: SortOrder;
    costCurrency?: SortOrder;
    saleAmount?: SortOrder;
    saleCurrency?: SortOrder;
    margin?: SortOrder;
    marginPercentage?: SortOrder;
    costVatRate?: SortOrder;
    costVatAmount?: SortOrder;
    saleVatRate?: SortOrder;
    saleVatAmount?: SortOrder;
    status?: SortOrder;
    completedAt?: SortOrder;
    cancelledAt?: SortOrder;
    cancellationReason?: SortOrder;
    archivedAt?: SortOrder;
    notes?: SortOrder;
    internalNotes?: SortOrder;
    attachments?: SortOrder;
    customFields?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ServiceAvgOrderByAggregateInput = {
    distance?: SortOrder;
    costAmount?: SortOrder;
    saleAmount?: SortOrder;
    margin?: SortOrder;
    marginPercentage?: SortOrder;
    costVatRate?: SortOrder;
    costVatAmount?: SortOrder;
    saleVatRate?: SortOrder;
    saleVatAmount?: SortOrder;
  };

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder;
    serviceNumber?: SortOrder;
    date?: SortOrder;
    clientId?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    assignedToId?: SortOrder;
    description?: SortOrder;
    reference?: SortOrder;
    origin?: SortOrder;
    destination?: SortOrder;
    distance?: SortOrder;
    vehicleType?: SortOrder;
    vehiclePlate?: SortOrder;
    driverName?: SortOrder;
    costAmount?: SortOrder;
    costCurrency?: SortOrder;
    saleAmount?: SortOrder;
    saleCurrency?: SortOrder;
    margin?: SortOrder;
    marginPercentage?: SortOrder;
    costVatRate?: SortOrder;
    costVatAmount?: SortOrder;
    saleVatRate?: SortOrder;
    saleVatAmount?: SortOrder;
    status?: SortOrder;
    completedAt?: SortOrder;
    cancelledAt?: SortOrder;
    cancellationReason?: SortOrder;
    archivedAt?: SortOrder;
    notes?: SortOrder;
    internalNotes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder;
    serviceNumber?: SortOrder;
    date?: SortOrder;
    clientId?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    assignedToId?: SortOrder;
    description?: SortOrder;
    reference?: SortOrder;
    origin?: SortOrder;
    destination?: SortOrder;
    distance?: SortOrder;
    vehicleType?: SortOrder;
    vehiclePlate?: SortOrder;
    driverName?: SortOrder;
    costAmount?: SortOrder;
    costCurrency?: SortOrder;
    saleAmount?: SortOrder;
    saleCurrency?: SortOrder;
    margin?: SortOrder;
    marginPercentage?: SortOrder;
    costVatRate?: SortOrder;
    costVatAmount?: SortOrder;
    saleVatRate?: SortOrder;
    saleVatAmount?: SortOrder;
    status?: SortOrder;
    completedAt?: SortOrder;
    cancelledAt?: SortOrder;
    cancellationReason?: SortOrder;
    archivedAt?: SortOrder;
    notes?: SortOrder;
    internalNotes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ServiceSumOrderByAggregateInput = {
    distance?: SortOrder;
    costAmount?: SortOrder;
    saleAmount?: SortOrder;
    margin?: SortOrder;
    marginPercentage?: SortOrder;
    costVatRate?: SortOrder;
    costVatAmount?: SortOrder;
    saleVatRate?: SortOrder;
    saleVatAmount?: SortOrder;
  };

  export type EnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>;
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>;
  };

  export type EnumServiceStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel> | null;
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumServiceStatusNullableFilter<$PrismaModel> | $Enums.ServiceStatus | null;
  };

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput;
    isNot?: ServiceWhereInput;
  };

  export type ServiceStatusHistoryOrderByRelevanceInput = {
    fields:
      | ServiceStatusHistoryOrderByRelevanceFieldEnum
      | ServiceStatusHistoryOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ServiceStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    fromStatus?: SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrder;
    changedBy?: SortOrder;
    changedAt?: SortOrder;
  };

  export type ServiceStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    fromStatus?: SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrder;
    changedBy?: SortOrder;
    changedAt?: SortOrder;
  };

  export type ServiceStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    fromStatus?: SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrder;
    changedBy?: SortOrder;
    changedAt?: SortOrder;
  };

  export type EnumServiceStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel> | null;
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel> | null;
    not?:
      | NestedEnumServiceStatusNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.ServiceStatus
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumServiceStatusNullableFilter<$PrismaModel>;
    _max?: NestedEnumServiceStatusNullableFilter<$PrismaModel>;
  };

  export type LoadingOrderOrderByRelevanceInput = {
    fields: LoadingOrderOrderByRelevanceFieldEnum | LoadingOrderOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type LoadingOrderCountOrderByAggregateInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    generatedAt?: SortOrder;
    generatedById?: SortOrder;
    clientId?: SortOrder;
    notes?: SortOrder;
    pdfPath?: SortOrder;
    pdfGeneratedAt?: SortOrder;
    pdfSize?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type LoadingOrderAvgOrderByAggregateInput = {
    pdfSize?: SortOrder;
  };

  export type LoadingOrderMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    generatedAt?: SortOrder;
    generatedById?: SortOrder;
    clientId?: SortOrder;
    notes?: SortOrder;
    pdfPath?: SortOrder;
    pdfGeneratedAt?: SortOrder;
    pdfSize?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type LoadingOrderMinOrderByAggregateInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    generatedAt?: SortOrder;
    generatedById?: SortOrder;
    clientId?: SortOrder;
    notes?: SortOrder;
    pdfPath?: SortOrder;
    pdfGeneratedAt?: SortOrder;
    pdfSize?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type LoadingOrderSumOrderByAggregateInput = {
    pdfSize?: SortOrder;
  };

  export type LoadingOrderScalarRelationFilter = {
    is?: LoadingOrderWhereInput;
    isNot?: LoadingOrderWhereInput;
  };

  export type ServiceLoadingOrderOrderByRelevanceInput = {
    fields:
      | ServiceLoadingOrderOrderByRelevanceFieldEnum
      | ServiceLoadingOrderOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ServiceLoadingOrderServiceIdLoadingOrderIdCompoundUniqueInput = {
    serviceId: string;
    loadingOrderId: string;
  };

  export type ServiceLoadingOrderCountOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    loadingOrderId?: SortOrder;
    position?: SortOrder;
  };

  export type ServiceLoadingOrderAvgOrderByAggregateInput = {
    position?: SortOrder;
  };

  export type ServiceLoadingOrderMaxOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    loadingOrderId?: SortOrder;
    position?: SortOrder;
  };

  export type ServiceLoadingOrderMinOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    loadingOrderId?: SortOrder;
    position?: SortOrder;
  };

  export type ServiceLoadingOrderSumOrderByAggregateInput = {
    position?: SortOrder;
  };

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus;
  };

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus;
  };

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput;
    some?: PaymentWhereInput;
    none?: PaymentWhereInput;
  };

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type InvoiceOrderByRelevanceInput = {
    fields: InvoiceOrderByRelevanceFieldEnum | InvoiceOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    invoiceDate?: SortOrder;
    dueDate?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    totalAmount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrder;
    paymentMethod?: SortOrder;
    paymentReference?: SortOrder;
    irpfRate?: SortOrder;
    irpfAmount?: SortOrder;
    description?: SortOrder;
    notes?: SortOrder;
    termsConditions?: SortOrder;
    pdfPath?: SortOrder;
    pdfGeneratedAt?: SortOrder;
    sentAt?: SortOrder;
    sentTo?: SortOrder;
    viewedAt?: SortOrder;
    reminderSentAt?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    totalAmount?: SortOrder;
    paidAmount?: SortOrder;
    irpfRate?: SortOrder;
    irpfAmount?: SortOrder;
  };

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    invoiceDate?: SortOrder;
    dueDate?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    totalAmount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrder;
    paymentMethod?: SortOrder;
    paymentReference?: SortOrder;
    irpfRate?: SortOrder;
    irpfAmount?: SortOrder;
    description?: SortOrder;
    notes?: SortOrder;
    termsConditions?: SortOrder;
    pdfPath?: SortOrder;
    pdfGeneratedAt?: SortOrder;
    sentAt?: SortOrder;
    sentTo?: SortOrder;
    viewedAt?: SortOrder;
    reminderSentAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    invoiceDate?: SortOrder;
    dueDate?: SortOrder;
    supplierId?: SortOrder;
    createdById?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    totalAmount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrder;
    paymentMethod?: SortOrder;
    paymentReference?: SortOrder;
    irpfRate?: SortOrder;
    irpfAmount?: SortOrder;
    description?: SortOrder;
    notes?: SortOrder;
    termsConditions?: SortOrder;
    pdfPath?: SortOrder;
    pdfGeneratedAt?: SortOrder;
    sentAt?: SortOrder;
    sentTo?: SortOrder;
    viewedAt?: SortOrder;
    reminderSentAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    totalAmount?: SortOrder;
    paidAmount?: SortOrder;
    irpfRate?: SortOrder;
    irpfAmount?: SortOrder;
  };

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
  };

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>;
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>;
  };

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput;
    isNot?: InvoiceWhereInput;
  };

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null;
    isNot?: ServiceWhereInput | null;
  };

  export type InvoiceItemOrderByRelevanceInput = {
    fields: InvoiceItemOrderByRelevanceFieldEnum | InvoiceItemOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder;
    invoiceId?: SortOrder;
    serviceId?: SortOrder;
    description?: SortOrder;
    quantity?: SortOrder;
    unitPrice?: SortOrder;
    amount?: SortOrder;
    taxRate?: SortOrder;
    taxAmount?: SortOrder;
  };

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder;
    unitPrice?: SortOrder;
    amount?: SortOrder;
    taxRate?: SortOrder;
    taxAmount?: SortOrder;
  };

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    invoiceId?: SortOrder;
    serviceId?: SortOrder;
    description?: SortOrder;
    quantity?: SortOrder;
    unitPrice?: SortOrder;
    amount?: SortOrder;
    taxRate?: SortOrder;
    taxAmount?: SortOrder;
  };

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder;
    invoiceId?: SortOrder;
    serviceId?: SortOrder;
    description?: SortOrder;
    quantity?: SortOrder;
    unitPrice?: SortOrder;
    amount?: SortOrder;
    taxRate?: SortOrder;
    taxAmount?: SortOrder;
  };

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder;
    unitPrice?: SortOrder;
    amount?: SortOrder;
    taxRate?: SortOrder;
    taxAmount?: SortOrder;
  };

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder;
    paymentNumber?: SortOrder;
    invoiceId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    paymentDate?: SortOrder;
    paymentMethod?: SortOrder;
    reference?: SortOrder;
    status?: SortOrder;
    notes?: SortOrder;
    receiptPath?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder;
    paymentNumber?: SortOrder;
    invoiceId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    paymentDate?: SortOrder;
    paymentMethod?: SortOrder;
    reference?: SortOrder;
    status?: SortOrder;
    notes?: SortOrder;
    receiptPath?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder;
    paymentNumber?: SortOrder;
    invoiceId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    paymentDate?: SortOrder;
    paymentMethod?: SortOrder;
    reference?: SortOrder;
    status?: SortOrder;
    notes?: SortOrder;
    receiptPath?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType;
  };

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null;
    isNot?: ClientWhereInput | null;
  };

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null;
    isNot?: SupplierWhereInput | null;
  };

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder;
    documentType?: SortOrder;
    documentNumber?: SortOrder;
    clientId?: SortOrder;
    supplierId?: SortOrder;
    serviceId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    mimeType?: SortOrder;
    description?: SortOrder;
    tags?: SortOrder;
    metadata?: SortOrder;
    uploadedBy?: SortOrder;
    uploadedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder;
    documentType?: SortOrder;
    documentNumber?: SortOrder;
    clientId?: SortOrder;
    supplierId?: SortOrder;
    serviceId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    mimeType?: SortOrder;
    description?: SortOrder;
    uploadedBy?: SortOrder;
    uploadedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder;
    documentType?: SortOrder;
    documentNumber?: SortOrder;
    clientId?: SortOrder;
    supplierId?: SortOrder;
    serviceId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    mimeType?: SortOrder;
    description?: SortOrder;
    uploadedBy?: SortOrder;
    uploadedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>;
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>;
  };

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>;
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>;
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction;
  };

  export type AuditLogOrderByRelevanceInput = {
    fields: AuditLogOrderByRelevanceFieldEnum | AuditLogOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    oldValues?: SortOrder;
    newValues?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    requestId?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    requestId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    tableName?: SortOrder;
    recordId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    requestId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>;
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>;
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAuditActionFilter<$PrismaModel>;
    _max?: NestedEnumAuditActionFilter<$PrismaModel>;
  };

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    actionUrl?: SortOrder;
    actionLabel?: SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    actionUrl?: SortOrder;
    actionLabel?: SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    actionUrl?: SortOrder;
    actionLabel?: SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type SystemSettingOrderByRelevanceInput = {
    fields: SystemSettingOrderByRelevanceFieldEnum | SystemSettingOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder;
    key?: SortOrder;
    value?: SortOrder;
    description?: SortOrder;
    isPublic?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder;
    key?: SortOrder;
    description?: SortOrder;
    isPublic?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder;
    key?: SortOrder;
    description?: SortOrder;
    isPublic?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    upsert?: UserUpsertWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type ServiceCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>
      | ServiceCreateWithoutCreatedByInput[]
      | ServiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatedByInput
      | ServiceCreateOrConnectWithoutCreatedByInput[];
    createMany?: ServiceCreateManyCreatedByInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type ServiceCreateNestedManyWithoutAssignedToInput = {
    create?:
      | XOR<ServiceCreateWithoutAssignedToInput, ServiceUncheckedCreateWithoutAssignedToInput>
      | ServiceCreateWithoutAssignedToInput[]
      | ServiceUncheckedCreateWithoutAssignedToInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutAssignedToInput
      | ServiceCreateOrConnectWithoutAssignedToInput[];
    createMany?: ServiceCreateManyAssignedToInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type LoadingOrderCreateNestedManyWithoutGeneratedByInput = {
    create?:
      | XOR<
          LoadingOrderCreateWithoutGeneratedByInput,
          LoadingOrderUncheckedCreateWithoutGeneratedByInput
        >
      | LoadingOrderCreateWithoutGeneratedByInput[]
      | LoadingOrderUncheckedCreateWithoutGeneratedByInput[];
    connectOrCreate?:
      | LoadingOrderCreateOrConnectWithoutGeneratedByInput
      | LoadingOrderCreateOrConnectWithoutGeneratedByInput[];
    createMany?: LoadingOrderCreateManyGeneratedByInputEnvelope;
    connect?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
  };

  export type InvoiceCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
      | InvoiceCreateWithoutCreatedByInput[]
      | InvoiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutCreatedByInput
      | InvoiceCreateOrConnectWithoutCreatedByInput[];
    createMany?: InvoiceCreateManyCreatedByInputEnvelope;
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>
      | ServiceCreateWithoutCreatedByInput[]
      | ServiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatedByInput
      | ServiceCreateOrConnectWithoutCreatedByInput[];
    createMany?: ServiceCreateManyCreatedByInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?:
      | XOR<ServiceCreateWithoutAssignedToInput, ServiceUncheckedCreateWithoutAssignedToInput>
      | ServiceCreateWithoutAssignedToInput[]
      | ServiceUncheckedCreateWithoutAssignedToInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutAssignedToInput
      | ServiceCreateOrConnectWithoutAssignedToInput[];
    createMany?: ServiceCreateManyAssignedToInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput = {
    create?:
      | XOR<
          LoadingOrderCreateWithoutGeneratedByInput,
          LoadingOrderUncheckedCreateWithoutGeneratedByInput
        >
      | LoadingOrderCreateWithoutGeneratedByInput[]
      | LoadingOrderUncheckedCreateWithoutGeneratedByInput[];
    connectOrCreate?:
      | LoadingOrderCreateOrConnectWithoutGeneratedByInput
      | LoadingOrderCreateOrConnectWithoutGeneratedByInput[];
    createMany?: LoadingOrderCreateManyGeneratedByInputEnvelope;
    connect?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
  };

  export type InvoiceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
      | InvoiceCreateWithoutCreatedByInput[]
      | InvoiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutCreatedByInput
      | InvoiceCreateOrConnectWithoutCreatedByInput[];
    createMany?: InvoiceCreateManyCreatedByInputEnvelope;
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type ServiceUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>
      | ServiceCreateWithoutCreatedByInput[]
      | ServiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatedByInput
      | ServiceCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutCreatedByInput
      | ServiceUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ServiceCreateManyCreatedByInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutCreatedByInput
      | ServiceUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutCreatedByInput
      | ServiceUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type ServiceUpdateManyWithoutAssignedToNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutAssignedToInput, ServiceUncheckedCreateWithoutAssignedToInput>
      | ServiceCreateWithoutAssignedToInput[]
      | ServiceUncheckedCreateWithoutAssignedToInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutAssignedToInput
      | ServiceCreateOrConnectWithoutAssignedToInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutAssignedToInput
      | ServiceUpsertWithWhereUniqueWithoutAssignedToInput[];
    createMany?: ServiceCreateManyAssignedToInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutAssignedToInput
      | ServiceUpdateWithWhereUniqueWithoutAssignedToInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutAssignedToInput
      | ServiceUpdateManyWithWhereWithoutAssignedToInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type LoadingOrderUpdateManyWithoutGeneratedByNestedInput = {
    create?:
      | XOR<
          LoadingOrderCreateWithoutGeneratedByInput,
          LoadingOrderUncheckedCreateWithoutGeneratedByInput
        >
      | LoadingOrderCreateWithoutGeneratedByInput[]
      | LoadingOrderUncheckedCreateWithoutGeneratedByInput[];
    connectOrCreate?:
      | LoadingOrderCreateOrConnectWithoutGeneratedByInput
      | LoadingOrderCreateOrConnectWithoutGeneratedByInput[];
    upsert?:
      | LoadingOrderUpsertWithWhereUniqueWithoutGeneratedByInput
      | LoadingOrderUpsertWithWhereUniqueWithoutGeneratedByInput[];
    createMany?: LoadingOrderCreateManyGeneratedByInputEnvelope;
    set?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
    disconnect?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
    delete?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
    connect?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
    update?:
      | LoadingOrderUpdateWithWhereUniqueWithoutGeneratedByInput
      | LoadingOrderUpdateWithWhereUniqueWithoutGeneratedByInput[];
    updateMany?:
      | LoadingOrderUpdateManyWithWhereWithoutGeneratedByInput
      | LoadingOrderUpdateManyWithWhereWithoutGeneratedByInput[];
    deleteMany?: LoadingOrderScalarWhereInput | LoadingOrderScalarWhereInput[];
  };

  export type InvoiceUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
      | InvoiceCreateWithoutCreatedByInput[]
      | InvoiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutCreatedByInput
      | InvoiceCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput
      | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: InvoiceCreateManyCreatedByInputEnvelope;
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    update?:
      | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput
      | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | InvoiceUpdateManyWithWhereWithoutCreatedByInput
      | InvoiceUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>
      | ServiceCreateWithoutCreatedByInput[]
      | ServiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatedByInput
      | ServiceCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutCreatedByInput
      | ServiceUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ServiceCreateManyCreatedByInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutCreatedByInput
      | ServiceUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutCreatedByInput
      | ServiceUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutAssignedToInput, ServiceUncheckedCreateWithoutAssignedToInput>
      | ServiceCreateWithoutAssignedToInput[]
      | ServiceUncheckedCreateWithoutAssignedToInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutAssignedToInput
      | ServiceCreateOrConnectWithoutAssignedToInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutAssignedToInput
      | ServiceUpsertWithWhereUniqueWithoutAssignedToInput[];
    createMany?: ServiceCreateManyAssignedToInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutAssignedToInput
      | ServiceUpdateWithWhereUniqueWithoutAssignedToInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutAssignedToInput
      | ServiceUpdateManyWithWhereWithoutAssignedToInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput = {
    create?:
      | XOR<
          LoadingOrderCreateWithoutGeneratedByInput,
          LoadingOrderUncheckedCreateWithoutGeneratedByInput
        >
      | LoadingOrderCreateWithoutGeneratedByInput[]
      | LoadingOrderUncheckedCreateWithoutGeneratedByInput[];
    connectOrCreate?:
      | LoadingOrderCreateOrConnectWithoutGeneratedByInput
      | LoadingOrderCreateOrConnectWithoutGeneratedByInput[];
    upsert?:
      | LoadingOrderUpsertWithWhereUniqueWithoutGeneratedByInput
      | LoadingOrderUpsertWithWhereUniqueWithoutGeneratedByInput[];
    createMany?: LoadingOrderCreateManyGeneratedByInputEnvelope;
    set?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
    disconnect?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
    delete?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
    connect?: LoadingOrderWhereUniqueInput | LoadingOrderWhereUniqueInput[];
    update?:
      | LoadingOrderUpdateWithWhereUniqueWithoutGeneratedByInput
      | LoadingOrderUpdateWithWhereUniqueWithoutGeneratedByInput[];
    updateMany?:
      | LoadingOrderUpdateManyWithWhereWithoutGeneratedByInput
      | LoadingOrderUpdateManyWithWhereWithoutGeneratedByInput[];
    deleteMany?: LoadingOrderScalarWhereInput | LoadingOrderScalarWhereInput[];
  };

  export type InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
      | InvoiceCreateWithoutCreatedByInput[]
      | InvoiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutCreatedByInput
      | InvoiceCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput
      | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: InvoiceCreateManyCreatedByInputEnvelope;
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    update?:
      | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput
      | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | InvoiceUpdateManyWithWhereWithoutCreatedByInput
      | InvoiceUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type ClientCreateNestedManyWithoutCompanyInput = {
    create?:
      | XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>
      | ClientCreateWithoutCompanyInput[]
      | ClientUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | ClientCreateOrConnectWithoutCompanyInput
      | ClientCreateOrConnectWithoutCompanyInput[];
    createMany?: ClientCreateManyCompanyInputEnvelope;
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
  };

  export type SupplierCreateNestedManyWithoutCompanyInput = {
    create?:
      | XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>
      | SupplierCreateWithoutCompanyInput[]
      | SupplierUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | SupplierCreateOrConnectWithoutCompanyInput
      | SupplierCreateOrConnectWithoutCompanyInput[];
    createMany?: SupplierCreateManyCompanyInputEnvelope;
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
  };

  export type ClientUncheckedCreateNestedManyWithoutCompanyInput = {
    create?:
      | XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>
      | ClientCreateWithoutCompanyInput[]
      | ClientUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | ClientCreateOrConnectWithoutCompanyInput
      | ClientCreateOrConnectWithoutCompanyInput[];
    createMany?: ClientCreateManyCompanyInputEnvelope;
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
  };

  export type SupplierUncheckedCreateNestedManyWithoutCompanyInput = {
    create?:
      | XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>
      | SupplierCreateWithoutCompanyInput[]
      | SupplierUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | SupplierCreateOrConnectWithoutCompanyInput
      | SupplierCreateOrConnectWithoutCompanyInput[];
    createMany?: SupplierCreateManyCompanyInputEnvelope;
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
  };

  export type ClientUpdateManyWithoutCompanyNestedInput = {
    create?:
      | XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>
      | ClientCreateWithoutCompanyInput[]
      | ClientUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | ClientCreateOrConnectWithoutCompanyInput
      | ClientCreateOrConnectWithoutCompanyInput[];
    upsert?:
      | ClientUpsertWithWhereUniqueWithoutCompanyInput
      | ClientUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: ClientCreateManyCompanyInputEnvelope;
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
    update?:
      | ClientUpdateWithWhereUniqueWithoutCompanyInput
      | ClientUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
      | ClientUpdateManyWithWhereWithoutCompanyInput
      | ClientUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[];
  };

  export type SupplierUpdateManyWithoutCompanyNestedInput = {
    create?:
      | XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>
      | SupplierCreateWithoutCompanyInput[]
      | SupplierUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | SupplierCreateOrConnectWithoutCompanyInput
      | SupplierCreateOrConnectWithoutCompanyInput[];
    upsert?:
      | SupplierUpsertWithWhereUniqueWithoutCompanyInput
      | SupplierUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: SupplierCreateManyCompanyInputEnvelope;
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
    update?:
      | SupplierUpdateWithWhereUniqueWithoutCompanyInput
      | SupplierUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
      | SupplierUpdateManyWithWhereWithoutCompanyInput
      | SupplierUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[];
  };

  export type ClientUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?:
      | XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>
      | ClientCreateWithoutCompanyInput[]
      | ClientUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | ClientCreateOrConnectWithoutCompanyInput
      | ClientCreateOrConnectWithoutCompanyInput[];
    upsert?:
      | ClientUpsertWithWhereUniqueWithoutCompanyInput
      | ClientUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: ClientCreateManyCompanyInputEnvelope;
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[];
    update?:
      | ClientUpdateWithWhereUniqueWithoutCompanyInput
      | ClientUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
      | ClientUpdateManyWithWhereWithoutCompanyInput
      | ClientUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[];
  };

  export type SupplierUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?:
      | XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>
      | SupplierCreateWithoutCompanyInput[]
      | SupplierUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | SupplierCreateOrConnectWithoutCompanyInput
      | SupplierCreateOrConnectWithoutCompanyInput[];
    upsert?:
      | SupplierUpsertWithWhereUniqueWithoutCompanyInput
      | SupplierUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: SupplierCreateManyCompanyInputEnvelope;
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[];
    update?:
      | SupplierUpdateWithWhereUniqueWithoutCompanyInput
      | SupplierUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
      | SupplierUpdateManyWithWhereWithoutCompanyInput
      | SupplierUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[];
  };

  export type ClientCreatetagsInput = {
    set: string[];
  };

  export type CompanyCreateNestedOneWithoutAsClientInput = {
    create?: XOR<CompanyCreateWithoutAsClientInput, CompanyUncheckedCreateWithoutAsClientInput>;
    connectOrCreate?: CompanyCreateOrConnectWithoutAsClientInput;
    connect?: CompanyWhereUniqueInput;
  };

  export type ServiceCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<ServiceCreateWithoutClientInput, ServiceUncheckedCreateWithoutClientInput>
      | ServiceCreateWithoutClientInput[]
      | ServiceUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutClientInput
      | ServiceCreateOrConnectWithoutClientInput[];
    createMany?: ServiceCreateManyClientInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type ClientContactCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput>
      | ClientContactCreateWithoutClientInput[]
      | ClientContactUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | ClientContactCreateOrConnectWithoutClientInput
      | ClientContactCreateOrConnectWithoutClientInput[];
    createMany?: ClientContactCreateManyClientInputEnvelope;
    connect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
  };

  export type DocumentCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
      | DocumentCreateWithoutClientInput[]
      | DocumentUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutClientInput
      | DocumentCreateOrConnectWithoutClientInput[];
    createMany?: DocumentCreateManyClientInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<ServiceCreateWithoutClientInput, ServiceUncheckedCreateWithoutClientInput>
      | ServiceCreateWithoutClientInput[]
      | ServiceUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutClientInput
      | ServiceCreateOrConnectWithoutClientInput[];
    createMany?: ServiceCreateManyClientInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type ClientContactUncheckedCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput>
      | ClientContactCreateWithoutClientInput[]
      | ClientContactUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | ClientContactCreateOrConnectWithoutClientInput
      | ClientContactCreateOrConnectWithoutClientInput[];
    createMany?: ClientContactCreateManyClientInputEnvelope;
    connect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
  };

  export type DocumentUncheckedCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
      | DocumentCreateWithoutClientInput[]
      | DocumentUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutClientInput
      | DocumentCreateOrConnectWithoutClientInput[];
    createMany?: DocumentCreateManyClientInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ClientUpdatetagsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type CompanyUpdateOneWithoutAsClientNestedInput = {
    create?: XOR<CompanyCreateWithoutAsClientInput, CompanyUncheckedCreateWithoutAsClientInput>;
    connectOrCreate?: CompanyCreateOrConnectWithoutAsClientInput;
    upsert?: CompanyUpsertWithoutAsClientInput;
    disconnect?: CompanyWhereInput | boolean;
    delete?: CompanyWhereInput | boolean;
    connect?: CompanyWhereUniqueInput;
    update?: XOR<
      XOR<CompanyUpdateToOneWithWhereWithoutAsClientInput, CompanyUpdateWithoutAsClientInput>,
      CompanyUncheckedUpdateWithoutAsClientInput
    >;
  };

  export type ServiceUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutClientInput, ServiceUncheckedCreateWithoutClientInput>
      | ServiceCreateWithoutClientInput[]
      | ServiceUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutClientInput
      | ServiceCreateOrConnectWithoutClientInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutClientInput
      | ServiceUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: ServiceCreateManyClientInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutClientInput
      | ServiceUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutClientInput
      | ServiceUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type ClientContactUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput>
      | ClientContactCreateWithoutClientInput[]
      | ClientContactUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | ClientContactCreateOrConnectWithoutClientInput
      | ClientContactCreateOrConnectWithoutClientInput[];
    upsert?:
      | ClientContactUpsertWithWhereUniqueWithoutClientInput
      | ClientContactUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: ClientContactCreateManyClientInputEnvelope;
    set?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
    disconnect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
    delete?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
    connect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
    update?:
      | ClientContactUpdateWithWhereUniqueWithoutClientInput
      | ClientContactUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | ClientContactUpdateManyWithWhereWithoutClientInput
      | ClientContactUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: ClientContactScalarWhereInput | ClientContactScalarWhereInput[];
  };

  export type DocumentUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
      | DocumentCreateWithoutClientInput[]
      | DocumentUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutClientInput
      | DocumentCreateOrConnectWithoutClientInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutClientInput
      | DocumentUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: DocumentCreateManyClientInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutClientInput
      | DocumentUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutClientInput
      | DocumentUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutClientInput, ServiceUncheckedCreateWithoutClientInput>
      | ServiceCreateWithoutClientInput[]
      | ServiceUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutClientInput
      | ServiceCreateOrConnectWithoutClientInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutClientInput
      | ServiceUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: ServiceCreateManyClientInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutClientInput
      | ServiceUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutClientInput
      | ServiceUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type ClientContactUncheckedUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput>
      | ClientContactCreateWithoutClientInput[]
      | ClientContactUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | ClientContactCreateOrConnectWithoutClientInput
      | ClientContactCreateOrConnectWithoutClientInput[];
    upsert?:
      | ClientContactUpsertWithWhereUniqueWithoutClientInput
      | ClientContactUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: ClientContactCreateManyClientInputEnvelope;
    set?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
    disconnect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
    delete?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
    connect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[];
    update?:
      | ClientContactUpdateWithWhereUniqueWithoutClientInput
      | ClientContactUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | ClientContactUpdateManyWithWhereWithoutClientInput
      | ClientContactUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: ClientContactScalarWhereInput | ClientContactScalarWhereInput[];
  };

  export type DocumentUncheckedUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
      | DocumentCreateWithoutClientInput[]
      | DocumentUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutClientInput
      | DocumentCreateOrConnectWithoutClientInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutClientInput
      | DocumentUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: DocumentCreateManyClientInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutClientInput
      | DocumentUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutClientInput
      | DocumentUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ClientCreateNestedOneWithoutContactsInput = {
    create?: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>;
    connectOrCreate?: ClientCreateOrConnectWithoutContactsInput;
    connect?: ClientWhereUniqueInput;
  };

  export type ClientUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>;
    connectOrCreate?: ClientCreateOrConnectWithoutContactsInput;
    upsert?: ClientUpsertWithoutContactsInput;
    connect?: ClientWhereUniqueInput;
    update?: XOR<
      XOR<ClientUpdateToOneWithWhereWithoutContactsInput, ClientUpdateWithoutContactsInput>,
      ClientUncheckedUpdateWithoutContactsInput
    >;
  };

  export type SupplierCreatetagsInput = {
    set: string[];
  };

  export type CompanyCreateNestedOneWithoutAsSupplierInput = {
    create?: XOR<CompanyCreateWithoutAsSupplierInput, CompanyUncheckedCreateWithoutAsSupplierInput>;
    connectOrCreate?: CompanyCreateOrConnectWithoutAsSupplierInput;
    connect?: CompanyWhereUniqueInput;
  };

  export type ServiceCreateNestedManyWithoutSupplierInput = {
    create?:
      | XOR<ServiceCreateWithoutSupplierInput, ServiceUncheckedCreateWithoutSupplierInput>
      | ServiceCreateWithoutSupplierInput[]
      | ServiceUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutSupplierInput
      | ServiceCreateOrConnectWithoutSupplierInput[];
    createMany?: ServiceCreateManySupplierInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type InvoiceCreateNestedManyWithoutSupplierInput = {
    create?:
      | XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>
      | InvoiceCreateWithoutSupplierInput[]
      | InvoiceUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutSupplierInput
      | InvoiceCreateOrConnectWithoutSupplierInput[];
    createMany?: InvoiceCreateManySupplierInputEnvelope;
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
  };

  export type DocumentCreateNestedManyWithoutSupplierInput = {
    create?:
      | XOR<DocumentCreateWithoutSupplierInput, DocumentUncheckedCreateWithoutSupplierInput>
      | DocumentCreateWithoutSupplierInput[]
      | DocumentUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutSupplierInput
      | DocumentCreateOrConnectWithoutSupplierInput[];
    createMany?: DocumentCreateManySupplierInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutSupplierInput = {
    create?:
      | XOR<ServiceCreateWithoutSupplierInput, ServiceUncheckedCreateWithoutSupplierInput>
      | ServiceCreateWithoutSupplierInput[]
      | ServiceUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutSupplierInput
      | ServiceCreateOrConnectWithoutSupplierInput[];
    createMany?: ServiceCreateManySupplierInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type InvoiceUncheckedCreateNestedManyWithoutSupplierInput = {
    create?:
      | XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>
      | InvoiceCreateWithoutSupplierInput[]
      | InvoiceUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutSupplierInput
      | InvoiceCreateOrConnectWithoutSupplierInput[];
    createMany?: InvoiceCreateManySupplierInputEnvelope;
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
  };

  export type DocumentUncheckedCreateNestedManyWithoutSupplierInput = {
    create?:
      | XOR<DocumentCreateWithoutSupplierInput, DocumentUncheckedCreateWithoutSupplierInput>
      | DocumentCreateWithoutSupplierInput[]
      | DocumentUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutSupplierInput
      | DocumentCreateOrConnectWithoutSupplierInput[];
    createMany?: DocumentCreateManySupplierInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type SupplierUpdatetagsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type CompanyUpdateOneWithoutAsSupplierNestedInput = {
    create?: XOR<CompanyCreateWithoutAsSupplierInput, CompanyUncheckedCreateWithoutAsSupplierInput>;
    connectOrCreate?: CompanyCreateOrConnectWithoutAsSupplierInput;
    upsert?: CompanyUpsertWithoutAsSupplierInput;
    disconnect?: CompanyWhereInput | boolean;
    delete?: CompanyWhereInput | boolean;
    connect?: CompanyWhereUniqueInput;
    update?: XOR<
      XOR<CompanyUpdateToOneWithWhereWithoutAsSupplierInput, CompanyUpdateWithoutAsSupplierInput>,
      CompanyUncheckedUpdateWithoutAsSupplierInput
    >;
  };

  export type ServiceUpdateManyWithoutSupplierNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutSupplierInput, ServiceUncheckedCreateWithoutSupplierInput>
      | ServiceCreateWithoutSupplierInput[]
      | ServiceUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutSupplierInput
      | ServiceCreateOrConnectWithoutSupplierInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutSupplierInput
      | ServiceUpsertWithWhereUniqueWithoutSupplierInput[];
    createMany?: ServiceCreateManySupplierInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutSupplierInput
      | ServiceUpdateWithWhereUniqueWithoutSupplierInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutSupplierInput
      | ServiceUpdateManyWithWhereWithoutSupplierInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type InvoiceUpdateManyWithoutSupplierNestedInput = {
    create?:
      | XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>
      | InvoiceCreateWithoutSupplierInput[]
      | InvoiceUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutSupplierInput
      | InvoiceCreateOrConnectWithoutSupplierInput[];
    upsert?:
      | InvoiceUpsertWithWhereUniqueWithoutSupplierInput
      | InvoiceUpsertWithWhereUniqueWithoutSupplierInput[];
    createMany?: InvoiceCreateManySupplierInputEnvelope;
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    update?:
      | InvoiceUpdateWithWhereUniqueWithoutSupplierInput
      | InvoiceUpdateWithWhereUniqueWithoutSupplierInput[];
    updateMany?:
      | InvoiceUpdateManyWithWhereWithoutSupplierInput
      | InvoiceUpdateManyWithWhereWithoutSupplierInput[];
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
  };

  export type DocumentUpdateManyWithoutSupplierNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutSupplierInput, DocumentUncheckedCreateWithoutSupplierInput>
      | DocumentCreateWithoutSupplierInput[]
      | DocumentUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutSupplierInput
      | DocumentCreateOrConnectWithoutSupplierInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutSupplierInput
      | DocumentUpsertWithWhereUniqueWithoutSupplierInput[];
    createMany?: DocumentCreateManySupplierInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutSupplierInput
      | DocumentUpdateWithWhereUniqueWithoutSupplierInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutSupplierInput
      | DocumentUpdateManyWithWhereWithoutSupplierInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutSupplierInput, ServiceUncheckedCreateWithoutSupplierInput>
      | ServiceCreateWithoutSupplierInput[]
      | ServiceUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutSupplierInput
      | ServiceCreateOrConnectWithoutSupplierInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutSupplierInput
      | ServiceUpsertWithWhereUniqueWithoutSupplierInput[];
    createMany?: ServiceCreateManySupplierInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutSupplierInput
      | ServiceUpdateWithWhereUniqueWithoutSupplierInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutSupplierInput
      | ServiceUpdateManyWithWhereWithoutSupplierInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type InvoiceUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?:
      | XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>
      | InvoiceCreateWithoutSupplierInput[]
      | InvoiceUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutSupplierInput
      | InvoiceCreateOrConnectWithoutSupplierInput[];
    upsert?:
      | InvoiceUpsertWithWhereUniqueWithoutSupplierInput
      | InvoiceUpsertWithWhereUniqueWithoutSupplierInput[];
    createMany?: InvoiceCreateManySupplierInputEnvelope;
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    update?:
      | InvoiceUpdateWithWhereUniqueWithoutSupplierInput
      | InvoiceUpdateWithWhereUniqueWithoutSupplierInput[];
    updateMany?:
      | InvoiceUpdateManyWithWhereWithoutSupplierInput
      | InvoiceUpdateManyWithWhereWithoutSupplierInput[];
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
  };

  export type DocumentUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutSupplierInput, DocumentUncheckedCreateWithoutSupplierInput>
      | DocumentCreateWithoutSupplierInput[]
      | DocumentUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutSupplierInput
      | DocumentCreateOrConnectWithoutSupplierInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutSupplierInput
      | DocumentUpsertWithWhereUniqueWithoutSupplierInput[];
    createMany?: DocumentCreateManySupplierInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutSupplierInput
      | DocumentUpdateWithWhereUniqueWithoutSupplierInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutSupplierInput
      | DocumentUpdateManyWithWhereWithoutSupplierInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ServiceCreateattachmentsInput = {
    set: string[];
  };

  export type ClientCreateNestedOneWithoutServicesInput = {
    create?: XOR<ClientCreateWithoutServicesInput, ClientUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: ClientCreateOrConnectWithoutServicesInput;
    connect?: ClientWhereUniqueInput;
  };

  export type SupplierCreateNestedOneWithoutServicesInput = {
    create?: XOR<SupplierCreateWithoutServicesInput, SupplierUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: SupplierCreateOrConnectWithoutServicesInput;
    connect?: SupplierWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAssignedServicesInput = {
    create?: XOR<
      UserCreateWithoutAssignedServicesInput,
      UserUncheckedCreateWithoutAssignedServicesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAssignedServicesInput;
    connect?: UserWhereUniqueInput;
  };

  export type ServiceLoadingOrderCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          ServiceLoadingOrderCreateWithoutServiceInput,
          ServiceLoadingOrderUncheckedCreateWithoutServiceInput
        >
      | ServiceLoadingOrderCreateWithoutServiceInput[]
      | ServiceLoadingOrderUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceLoadingOrderCreateOrConnectWithoutServiceInput
      | ServiceLoadingOrderCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceLoadingOrderCreateManyServiceInputEnvelope;
    connect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
  };

  export type InvoiceItemCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
      | InvoiceItemCreateWithoutServiceInput[]
      | InvoiceItemUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | InvoiceItemCreateOrConnectWithoutServiceInput
      | InvoiceItemCreateOrConnectWithoutServiceInput[];
    createMany?: InvoiceItemCreateManyServiceInputEnvelope;
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
  };

  export type DocumentCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<DocumentCreateWithoutServiceInput, DocumentUncheckedCreateWithoutServiceInput>
      | DocumentCreateWithoutServiceInput[]
      | DocumentUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutServiceInput
      | DocumentCreateOrConnectWithoutServiceInput[];
    createMany?: DocumentCreateManyServiceInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type ServiceStatusHistoryCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          ServiceStatusHistoryCreateWithoutServiceInput,
          ServiceStatusHistoryUncheckedCreateWithoutServiceInput
        >
      | ServiceStatusHistoryCreateWithoutServiceInput[]
      | ServiceStatusHistoryUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceStatusHistoryCreateOrConnectWithoutServiceInput
      | ServiceStatusHistoryCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceStatusHistoryCreateManyServiceInputEnvelope;
    connect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
  };

  export type ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          ServiceLoadingOrderCreateWithoutServiceInput,
          ServiceLoadingOrderUncheckedCreateWithoutServiceInput
        >
      | ServiceLoadingOrderCreateWithoutServiceInput[]
      | ServiceLoadingOrderUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceLoadingOrderCreateOrConnectWithoutServiceInput
      | ServiceLoadingOrderCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceLoadingOrderCreateManyServiceInputEnvelope;
    connect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
  };

  export type InvoiceItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
      | InvoiceItemCreateWithoutServiceInput[]
      | InvoiceItemUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | InvoiceItemCreateOrConnectWithoutServiceInput
      | InvoiceItemCreateOrConnectWithoutServiceInput[];
    createMany?: InvoiceItemCreateManyServiceInputEnvelope;
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
  };

  export type DocumentUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<DocumentCreateWithoutServiceInput, DocumentUncheckedCreateWithoutServiceInput>
      | DocumentCreateWithoutServiceInput[]
      | DocumentUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutServiceInput
      | DocumentCreateOrConnectWithoutServiceInput[];
    createMany?: DocumentCreateManyServiceInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          ServiceStatusHistoryCreateWithoutServiceInput,
          ServiceStatusHistoryUncheckedCreateWithoutServiceInput
        >
      | ServiceStatusHistoryCreateWithoutServiceInput[]
      | ServiceStatusHistoryUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceStatusHistoryCreateOrConnectWithoutServiceInput
      | ServiceStatusHistoryCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceStatusHistoryCreateManyServiceInputEnvelope;
    connect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
  };

  export type EnumServiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceStatus;
  };

  export type ServiceUpdateattachmentsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type ClientUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ClientCreateWithoutServicesInput, ClientUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: ClientCreateOrConnectWithoutServicesInput;
    upsert?: ClientUpsertWithoutServicesInput;
    connect?: ClientWhereUniqueInput;
    update?: XOR<
      XOR<ClientUpdateToOneWithWhereWithoutServicesInput, ClientUpdateWithoutServicesInput>,
      ClientUncheckedUpdateWithoutServicesInput
    >;
  };

  export type SupplierUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<SupplierCreateWithoutServicesInput, SupplierUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: SupplierCreateOrConnectWithoutServicesInput;
    upsert?: SupplierUpsertWithoutServicesInput;
    connect?: SupplierWhereUniqueInput;
    update?: XOR<
      XOR<SupplierUpdateToOneWithWhereWithoutServicesInput, SupplierUpdateWithoutServicesInput>,
      SupplierUncheckedUpdateWithoutServicesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput;
    upsert?: UserUpsertWithoutServicesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutServicesInput, UserUpdateWithoutServicesInput>,
      UserUncheckedUpdateWithoutServicesInput
    >;
  };

  export type UserUpdateOneWithoutAssignedServicesNestedInput = {
    create?: XOR<
      UserCreateWithoutAssignedServicesInput,
      UserUncheckedCreateWithoutAssignedServicesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAssignedServicesInput;
    upsert?: UserUpsertWithoutAssignedServicesInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAssignedServicesInput,
        UserUpdateWithoutAssignedServicesInput
      >,
      UserUncheckedUpdateWithoutAssignedServicesInput
    >;
  };

  export type ServiceLoadingOrderUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          ServiceLoadingOrderCreateWithoutServiceInput,
          ServiceLoadingOrderUncheckedCreateWithoutServiceInput
        >
      | ServiceLoadingOrderCreateWithoutServiceInput[]
      | ServiceLoadingOrderUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceLoadingOrderCreateOrConnectWithoutServiceInput
      | ServiceLoadingOrderCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceLoadingOrderUpsertWithWhereUniqueWithoutServiceInput
      | ServiceLoadingOrderUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceLoadingOrderCreateManyServiceInputEnvelope;
    set?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    disconnect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    delete?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    connect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    update?:
      | ServiceLoadingOrderUpdateWithWhereUniqueWithoutServiceInput
      | ServiceLoadingOrderUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceLoadingOrderUpdateManyWithWhereWithoutServiceInput
      | ServiceLoadingOrderUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceLoadingOrderScalarWhereInput | ServiceLoadingOrderScalarWhereInput[];
  };

  export type InvoiceItemUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
      | InvoiceItemCreateWithoutServiceInput[]
      | InvoiceItemUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | InvoiceItemCreateOrConnectWithoutServiceInput
      | InvoiceItemCreateOrConnectWithoutServiceInput[];
    upsert?:
      | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput
      | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: InvoiceItemCreateManyServiceInputEnvelope;
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    update?:
      | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput
      | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | InvoiceItemUpdateManyWithWhereWithoutServiceInput
      | InvoiceItemUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[];
  };

  export type DocumentUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutServiceInput, DocumentUncheckedCreateWithoutServiceInput>
      | DocumentCreateWithoutServiceInput[]
      | DocumentUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutServiceInput
      | DocumentCreateOrConnectWithoutServiceInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutServiceInput
      | DocumentUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: DocumentCreateManyServiceInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutServiceInput
      | DocumentUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutServiceInput
      | DocumentUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ServiceStatusHistoryUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          ServiceStatusHistoryCreateWithoutServiceInput,
          ServiceStatusHistoryUncheckedCreateWithoutServiceInput
        >
      | ServiceStatusHistoryCreateWithoutServiceInput[]
      | ServiceStatusHistoryUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceStatusHistoryCreateOrConnectWithoutServiceInput
      | ServiceStatusHistoryCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceStatusHistoryUpsertWithWhereUniqueWithoutServiceInput
      | ServiceStatusHistoryUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceStatusHistoryCreateManyServiceInputEnvelope;
    set?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
    disconnect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
    delete?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
    connect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
    update?:
      | ServiceStatusHistoryUpdateWithWhereUniqueWithoutServiceInput
      | ServiceStatusHistoryUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceStatusHistoryUpdateManyWithWhereWithoutServiceInput
      | ServiceStatusHistoryUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceStatusHistoryScalarWhereInput | ServiceStatusHistoryScalarWhereInput[];
  };

  export type ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          ServiceLoadingOrderCreateWithoutServiceInput,
          ServiceLoadingOrderUncheckedCreateWithoutServiceInput
        >
      | ServiceLoadingOrderCreateWithoutServiceInput[]
      | ServiceLoadingOrderUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceLoadingOrderCreateOrConnectWithoutServiceInput
      | ServiceLoadingOrderCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceLoadingOrderUpsertWithWhereUniqueWithoutServiceInput
      | ServiceLoadingOrderUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceLoadingOrderCreateManyServiceInputEnvelope;
    set?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    disconnect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    delete?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    connect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    update?:
      | ServiceLoadingOrderUpdateWithWhereUniqueWithoutServiceInput
      | ServiceLoadingOrderUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceLoadingOrderUpdateManyWithWhereWithoutServiceInput
      | ServiceLoadingOrderUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceLoadingOrderScalarWhereInput | ServiceLoadingOrderScalarWhereInput[];
  };

  export type InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
      | InvoiceItemCreateWithoutServiceInput[]
      | InvoiceItemUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | InvoiceItemCreateOrConnectWithoutServiceInput
      | InvoiceItemCreateOrConnectWithoutServiceInput[];
    upsert?:
      | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput
      | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: InvoiceItemCreateManyServiceInputEnvelope;
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    update?:
      | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput
      | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | InvoiceItemUpdateManyWithWhereWithoutServiceInput
      | InvoiceItemUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[];
  };

  export type DocumentUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutServiceInput, DocumentUncheckedCreateWithoutServiceInput>
      | DocumentCreateWithoutServiceInput[]
      | DocumentUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutServiceInput
      | DocumentCreateOrConnectWithoutServiceInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutServiceInput
      | DocumentUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: DocumentCreateManyServiceInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutServiceInput
      | DocumentUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutServiceInput
      | DocumentUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          ServiceStatusHistoryCreateWithoutServiceInput,
          ServiceStatusHistoryUncheckedCreateWithoutServiceInput
        >
      | ServiceStatusHistoryCreateWithoutServiceInput[]
      | ServiceStatusHistoryUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceStatusHistoryCreateOrConnectWithoutServiceInput
      | ServiceStatusHistoryCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceStatusHistoryUpsertWithWhereUniqueWithoutServiceInput
      | ServiceStatusHistoryUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceStatusHistoryCreateManyServiceInputEnvelope;
    set?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
    disconnect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
    delete?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
    connect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[];
    update?:
      | ServiceStatusHistoryUpdateWithWhereUniqueWithoutServiceInput
      | ServiceStatusHistoryUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceStatusHistoryUpdateManyWithWhereWithoutServiceInput
      | ServiceStatusHistoryUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceStatusHistoryScalarWhereInput | ServiceStatusHistoryScalarWhereInput[];
  };

  export type ServiceCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<
      ServiceCreateWithoutStatusHistoryInput,
      ServiceUncheckedCreateWithoutStatusHistoryInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutStatusHistoryInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type NullableEnumServiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceStatus | null;
  };

  export type ServiceUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<
      ServiceCreateWithoutStatusHistoryInput,
      ServiceUncheckedCreateWithoutStatusHistoryInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutStatusHistoryInput;
    upsert?: ServiceUpsertWithoutStatusHistoryInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceUpdateToOneWithWhereWithoutStatusHistoryInput,
        ServiceUpdateWithoutStatusHistoryInput
      >,
      ServiceUncheckedUpdateWithoutStatusHistoryInput
    >;
  };

  export type UserCreateNestedOneWithoutLoadingOrdersInput = {
    create?: XOR<UserCreateWithoutLoadingOrdersInput, UserUncheckedCreateWithoutLoadingOrdersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutLoadingOrdersInput;
    connect?: UserWhereUniqueInput;
  };

  export type ServiceLoadingOrderCreateNestedManyWithoutLoadingOrderInput = {
    create?:
      | XOR<
          ServiceLoadingOrderCreateWithoutLoadingOrderInput,
          ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput
        >
      | ServiceLoadingOrderCreateWithoutLoadingOrderInput[]
      | ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput[];
    connectOrCreate?:
      | ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput
      | ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput[];
    createMany?: ServiceLoadingOrderCreateManyLoadingOrderInputEnvelope;
    connect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
  };

  export type ServiceLoadingOrderUncheckedCreateNestedManyWithoutLoadingOrderInput = {
    create?:
      | XOR<
          ServiceLoadingOrderCreateWithoutLoadingOrderInput,
          ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput
        >
      | ServiceLoadingOrderCreateWithoutLoadingOrderInput[]
      | ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput[];
    connectOrCreate?:
      | ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput
      | ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput[];
    createMany?: ServiceLoadingOrderCreateManyLoadingOrderInputEnvelope;
    connect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutLoadingOrdersNestedInput = {
    create?: XOR<UserCreateWithoutLoadingOrdersInput, UserUncheckedCreateWithoutLoadingOrdersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutLoadingOrdersInput;
    upsert?: UserUpsertWithoutLoadingOrdersInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutLoadingOrdersInput, UserUpdateWithoutLoadingOrdersInput>,
      UserUncheckedUpdateWithoutLoadingOrdersInput
    >;
  };

  export type ServiceLoadingOrderUpdateManyWithoutLoadingOrderNestedInput = {
    create?:
      | XOR<
          ServiceLoadingOrderCreateWithoutLoadingOrderInput,
          ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput
        >
      | ServiceLoadingOrderCreateWithoutLoadingOrderInput[]
      | ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput[];
    connectOrCreate?:
      | ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput
      | ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput[];
    upsert?:
      | ServiceLoadingOrderUpsertWithWhereUniqueWithoutLoadingOrderInput
      | ServiceLoadingOrderUpsertWithWhereUniqueWithoutLoadingOrderInput[];
    createMany?: ServiceLoadingOrderCreateManyLoadingOrderInputEnvelope;
    set?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    disconnect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    delete?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    connect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    update?:
      | ServiceLoadingOrderUpdateWithWhereUniqueWithoutLoadingOrderInput
      | ServiceLoadingOrderUpdateWithWhereUniqueWithoutLoadingOrderInput[];
    updateMany?:
      | ServiceLoadingOrderUpdateManyWithWhereWithoutLoadingOrderInput
      | ServiceLoadingOrderUpdateManyWithWhereWithoutLoadingOrderInput[];
    deleteMany?: ServiceLoadingOrderScalarWhereInput | ServiceLoadingOrderScalarWhereInput[];
  };

  export type ServiceLoadingOrderUncheckedUpdateManyWithoutLoadingOrderNestedInput = {
    create?:
      | XOR<
          ServiceLoadingOrderCreateWithoutLoadingOrderInput,
          ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput
        >
      | ServiceLoadingOrderCreateWithoutLoadingOrderInput[]
      | ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput[];
    connectOrCreate?:
      | ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput
      | ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput[];
    upsert?:
      | ServiceLoadingOrderUpsertWithWhereUniqueWithoutLoadingOrderInput
      | ServiceLoadingOrderUpsertWithWhereUniqueWithoutLoadingOrderInput[];
    createMany?: ServiceLoadingOrderCreateManyLoadingOrderInputEnvelope;
    set?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    disconnect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    delete?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    connect?: ServiceLoadingOrderWhereUniqueInput | ServiceLoadingOrderWhereUniqueInput[];
    update?:
      | ServiceLoadingOrderUpdateWithWhereUniqueWithoutLoadingOrderInput
      | ServiceLoadingOrderUpdateWithWhereUniqueWithoutLoadingOrderInput[];
    updateMany?:
      | ServiceLoadingOrderUpdateManyWithWhereWithoutLoadingOrderInput
      | ServiceLoadingOrderUpdateManyWithWhereWithoutLoadingOrderInput[];
    deleteMany?: ServiceLoadingOrderScalarWhereInput | ServiceLoadingOrderScalarWhereInput[];
  };

  export type ServiceCreateNestedOneWithoutLoadingOrdersInput = {
    create?: XOR<
      ServiceCreateWithoutLoadingOrdersInput,
      ServiceUncheckedCreateWithoutLoadingOrdersInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutLoadingOrdersInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type LoadingOrderCreateNestedOneWithoutServicesInput = {
    create?: XOR<
      LoadingOrderCreateWithoutServicesInput,
      LoadingOrderUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: LoadingOrderCreateOrConnectWithoutServicesInput;
    connect?: LoadingOrderWhereUniqueInput;
  };

  export type ServiceUpdateOneRequiredWithoutLoadingOrdersNestedInput = {
    create?: XOR<
      ServiceCreateWithoutLoadingOrdersInput,
      ServiceUncheckedCreateWithoutLoadingOrdersInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutLoadingOrdersInput;
    upsert?: ServiceUpsertWithoutLoadingOrdersInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceUpdateToOneWithWhereWithoutLoadingOrdersInput,
        ServiceUpdateWithoutLoadingOrdersInput
      >,
      ServiceUncheckedUpdateWithoutLoadingOrdersInput
    >;
  };

  export type LoadingOrderUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<
      LoadingOrderCreateWithoutServicesInput,
      LoadingOrderUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: LoadingOrderCreateOrConnectWithoutServicesInput;
    upsert?: LoadingOrderUpsertWithoutServicesInput;
    connect?: LoadingOrderWhereUniqueInput;
    update?: XOR<
      XOR<
        LoadingOrderUpdateToOneWithWhereWithoutServicesInput,
        LoadingOrderUpdateWithoutServicesInput
      >,
      LoadingOrderUncheckedUpdateWithoutServicesInput
    >;
  };

  export type SupplierCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>;
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoicesInput;
    connect?: SupplierWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput;
    connect?: UserWhereUniqueInput;
  };

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?:
      | XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
      | InvoiceItemCreateWithoutInvoiceInput[]
      | InvoiceItemUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | InvoiceItemCreateOrConnectWithoutInvoiceInput
      | InvoiceItemCreateOrConnectWithoutInvoiceInput[];
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope;
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
  };

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?:
      | XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
      | PaymentCreateWithoutInvoiceInput[]
      | PaymentUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutInvoiceInput
      | PaymentCreateOrConnectWithoutInvoiceInput[];
    createMany?: PaymentCreateManyInvoiceInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
  };

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?:
      | XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
      | InvoiceItemCreateWithoutInvoiceInput[]
      | InvoiceItemUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | InvoiceItemCreateOrConnectWithoutInvoiceInput
      | InvoiceItemCreateOrConnectWithoutInvoiceInput[];
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope;
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
  };

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?:
      | XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
      | PaymentCreateWithoutInvoiceInput[]
      | PaymentUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutInvoiceInput
      | PaymentCreateOrConnectWithoutInvoiceInput[];
    createMany?: PaymentCreateManyInvoiceInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
  };

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus;
  };

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus;
  };

  export type SupplierUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>;
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoicesInput;
    upsert?: SupplierUpsertWithoutInvoicesInput;
    connect?: SupplierWhereUniqueInput;
    update?: XOR<
      XOR<SupplierUpdateToOneWithWhereWithoutInvoicesInput, SupplierUpdateWithoutInvoicesInput>,
      SupplierUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput;
    upsert?: UserUpsertWithoutInvoicesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>,
      UserUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?:
      | XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
      | InvoiceItemCreateWithoutInvoiceInput[]
      | InvoiceItemUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | InvoiceItemCreateOrConnectWithoutInvoiceInput
      | InvoiceItemCreateOrConnectWithoutInvoiceInput[];
    upsert?:
      | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput
      | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[];
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope;
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    update?:
      | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput
      | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[];
    updateMany?:
      | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput
      | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[];
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[];
  };

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?:
      | XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
      | PaymentCreateWithoutInvoiceInput[]
      | PaymentUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutInvoiceInput
      | PaymentCreateOrConnectWithoutInvoiceInput[];
    upsert?:
      | PaymentUpsertWithWhereUniqueWithoutInvoiceInput
      | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[];
    createMany?: PaymentCreateManyInvoiceInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?:
      | PaymentUpdateWithWhereUniqueWithoutInvoiceInput
      | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[];
    updateMany?:
      | PaymentUpdateManyWithWhereWithoutInvoiceInput
      | PaymentUpdateManyWithWhereWithoutInvoiceInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
  };

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?:
      | XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
      | InvoiceItemCreateWithoutInvoiceInput[]
      | InvoiceItemUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | InvoiceItemCreateOrConnectWithoutInvoiceInput
      | InvoiceItemCreateOrConnectWithoutInvoiceInput[];
    upsert?:
      | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput
      | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[];
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope;
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[];
    update?:
      | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput
      | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[];
    updateMany?:
      | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput
      | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[];
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[];
  };

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?:
      | XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
      | PaymentCreateWithoutInvoiceInput[]
      | PaymentUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutInvoiceInput
      | PaymentCreateOrConnectWithoutInvoiceInput[];
    upsert?:
      | PaymentUpsertWithWhereUniqueWithoutInvoiceInput
      | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[];
    createMany?: PaymentCreateManyInvoiceInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?:
      | PaymentUpdateWithWhereUniqueWithoutInvoiceInput
      | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[];
    updateMany?:
      | PaymentUpdateManyWithWhereWithoutInvoiceInput
      | PaymentUpdateManyWithWhereWithoutInvoiceInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
  };

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>;
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput;
    connect?: InvoiceWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<
      ServiceCreateWithoutInvoiceItemsInput,
      ServiceUncheckedCreateWithoutInvoiceItemsInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutInvoiceItemsInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>;
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput;
    upsert?: InvoiceUpsertWithoutItemsInput;
    connect?: InvoiceWhereUniqueInput;
    update?: XOR<
      XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>,
      InvoiceUncheckedUpdateWithoutItemsInput
    >;
  };

  export type ServiceUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<
      ServiceCreateWithoutInvoiceItemsInput,
      ServiceUncheckedCreateWithoutInvoiceItemsInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutInvoiceItemsInput;
    upsert?: ServiceUpsertWithoutInvoiceItemsInput;
    disconnect?: ServiceWhereInput | boolean;
    delete?: ServiceWhereInput | boolean;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceUpdateToOneWithWhereWithoutInvoiceItemsInput,
        ServiceUpdateWithoutInvoiceItemsInput
      >,
      ServiceUncheckedUpdateWithoutInvoiceItemsInput
    >;
  };

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>;
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput;
    connect?: InvoiceWhereUniqueInput;
  };

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>;
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput;
    upsert?: InvoiceUpsertWithoutPaymentsInput;
    connect?: InvoiceWhereUniqueInput;
    update?: XOR<
      XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>,
      InvoiceUncheckedUpdateWithoutPaymentsInput
    >;
  };

  export type DocumentCreatetagsInput = {
    set: string[];
  };

  export type ClientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput;
    connect?: ClientWhereUniqueInput;
  };

  export type SupplierCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<SupplierCreateWithoutDocumentsInput, SupplierUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: SupplierCreateOrConnectWithoutDocumentsInput;
    connect?: SupplierWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ServiceCreateWithoutDocumentsInput, ServiceUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutDocumentsInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType;
  };

  export type DocumentUpdatetagsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type ClientUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput;
    upsert?: ClientUpsertWithoutDocumentsInput;
    disconnect?: ClientWhereInput | boolean;
    delete?: ClientWhereInput | boolean;
    connect?: ClientWhereUniqueInput;
    update?: XOR<
      XOR<ClientUpdateToOneWithWhereWithoutDocumentsInput, ClientUpdateWithoutDocumentsInput>,
      ClientUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type SupplierUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<SupplierCreateWithoutDocumentsInput, SupplierUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: SupplierCreateOrConnectWithoutDocumentsInput;
    upsert?: SupplierUpsertWithoutDocumentsInput;
    disconnect?: SupplierWhereInput | boolean;
    delete?: SupplierWhereInput | boolean;
    connect?: SupplierWhereUniqueInput;
    update?: XOR<
      XOR<SupplierUpdateToOneWithWhereWithoutDocumentsInput, SupplierUpdateWithoutDocumentsInput>,
      SupplierUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type ServiceUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ServiceCreateWithoutDocumentsInput, ServiceUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutDocumentsInput;
    upsert?: ServiceUpsertWithoutDocumentsInput;
    disconnect?: ServiceWhereInput | boolean;
    delete?: ServiceWhereInput | boolean;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<ServiceUpdateToOneWithWhereWithoutDocumentsInput, ServiceUpdateWithoutDocumentsInput>,
      ServiceUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction;
  };

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    upsert?: UserUpsertWithoutAuditLogsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>,
      UserUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    upsert?: UserUpsertWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type NestedEnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus;
  };

  export type NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>;
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>;
  };

  export type NestedEnumServiceStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel> | null;
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumServiceStatusNullableFilter<$PrismaModel> | $Enums.ServiceStatus | null;
  };

  export type NestedEnumServiceStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel> | null;
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel> | null;
    not?:
      | NestedEnumServiceStatusNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.ServiceStatus
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumServiceStatusNullableFilter<$PrismaModel>;
    _max?: NestedEnumServiceStatusNullableFilter<$PrismaModel>;
  };

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus;
  };

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus;
  };

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
  };

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>;
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>;
  };

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType;
  };

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>;
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>;
  };

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>;
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>;
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction;
  };

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>;
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>;
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAuditActionFilter<$PrismaModel>;
    _max?: NestedEnumAuditActionFilter<$PrismaModel>;
  };

  export type UserCreateWithoutAccountsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceUncheckedCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
  };

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>;
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>;
  };

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUncheckedUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceUncheckedCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>;
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUncheckedUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AccountCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SessionCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutCreatedByInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    client: ClientCreateNestedOneWithoutServicesInput;
    supplier: SupplierCreateNestedOneWithoutServicesInput;
    assignedTo?: UserCreateNestedOneWithoutAssignedServicesInput;
    loadingOrders?: ServiceLoadingOrderCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput;
    documents?: DocumentCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutCreatedByInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>;
  };

  export type ServiceCreateManyCreatedByInputEnvelope = {
    data: ServiceCreateManyCreatedByInput | ServiceCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutAssignedToInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    client: ClientCreateNestedOneWithoutServicesInput;
    supplier: SupplierCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
    loadingOrders?: ServiceLoadingOrderCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput;
    documents?: DocumentCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutAssignedToInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    createdById: string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutAssignedToInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutAssignedToInput, ServiceUncheckedCreateWithoutAssignedToInput>;
  };

  export type ServiceCreateManyAssignedToInputEnvelope = {
    data: ServiceCreateManyAssignedToInput | ServiceCreateManyAssignedToInput[];
    skipDuplicates?: boolean;
  };

  export type LoadingOrderCreateWithoutGeneratedByInput = {
    id?: string;
    orderNumber: string;
    generatedAt?: Date | string;
    clientId?: string | null;
    notes?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    pdfSize?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceLoadingOrderCreateNestedManyWithoutLoadingOrderInput;
  };

  export type LoadingOrderUncheckedCreateWithoutGeneratedByInput = {
    id?: string;
    orderNumber: string;
    generatedAt?: Date | string;
    clientId?: string | null;
    notes?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    pdfSize?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutLoadingOrderInput;
  };

  export type LoadingOrderCreateOrConnectWithoutGeneratedByInput = {
    where: LoadingOrderWhereUniqueInput;
    create: XOR<
      LoadingOrderCreateWithoutGeneratedByInput,
      LoadingOrderUncheckedCreateWithoutGeneratedByInput
    >;
  };

  export type LoadingOrderCreateManyGeneratedByInputEnvelope = {
    data: LoadingOrderCreateManyGeneratedByInput | LoadingOrderCreateManyGeneratedByInput[];
    skipDuplicates?: boolean;
  };

  export type InvoiceCreateWithoutCreatedByInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    supplier: SupplierCreateNestedOneWithoutInvoicesInput;
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput;
    payments?: PaymentCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    supplierId: string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceCreateOrConnectWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput;
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>;
  };

  export type InvoiceCreateManyCreatedByInputEnvelope = {
    data: InvoiceCreateManyCreatedByInput | InvoiceCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutUserInput = {
    id?: string;
    action: $Enums.AuditAction;
    tableName: string;
    recordId: string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    requestId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string;
    action: $Enums.AuditAction;
    tableName: string;
    recordId: string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    requestId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>;
  };

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationCreateWithoutUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    category: string;
    actionUrl?: string | null;
    actionLabel?: string | null;
    isRead?: boolean;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    category: string;
    actionUrl?: string | null;
    actionLabel?: string | null;
    isRead?: boolean;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
  };

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>;
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    id?: StringFilter<'Account'> | string;
    userId?: StringFilter<'Account'> | string;
    type?: StringFilter<'Account'> | string;
    provider?: StringFilter<'Account'> | string;
    providerAccountId?: StringFilter<'Account'> | string;
    refresh_token?: StringNullableFilter<'Account'> | string | null;
    access_token?: StringNullableFilter<'Account'> | string | null;
    expires_at?: IntNullableFilter<'Account'> | number | null;
    token_type?: StringNullableFilter<'Account'> | string | null;
    scope?: StringNullableFilter<'Account'> | string | null;
    id_token?: StringNullableFilter<'Account'> | string | null;
    session_state?: StringNullableFilter<'Account'> | string | null;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>;
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<'Session'> | string;
    sessionToken?: StringFilter<'Session'> | string;
    userId?: StringFilter<'Session'> | string;
    expires?: DateTimeFilter<'Session'> | Date | string;
  };

  export type ServiceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutCreatedByInput, ServiceUncheckedUpdateWithoutCreatedByInput>;
    create: XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutCreatedByInput, ServiceUncheckedUpdateWithoutCreatedByInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutCreatedByInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCreatedByInput>;
  };

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    OR?: ServiceScalarWhereInput[];
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    id?: StringFilter<'Service'> | string;
    serviceNumber?: StringFilter<'Service'> | string;
    date?: DateTimeFilter<'Service'> | Date | string;
    clientId?: StringFilter<'Service'> | string;
    supplierId?: StringFilter<'Service'> | string;
    createdById?: StringFilter<'Service'> | string;
    assignedToId?: StringNullableFilter<'Service'> | string | null;
    description?: StringFilter<'Service'> | string;
    reference?: StringNullableFilter<'Service'> | string | null;
    origin?: StringFilter<'Service'> | string;
    destination?: StringFilter<'Service'> | string;
    distance?: IntNullableFilter<'Service'> | number | null;
    vehicleType?: StringNullableFilter<'Service'> | string | null;
    vehiclePlate?: StringNullableFilter<'Service'> | string | null;
    driverName?: StringNullableFilter<'Service'> | string | null;
    costAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFilter<'Service'> | string;
    saleAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFilter<'Service'> | string;
    margin?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    marginPercentage?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    costVatRate?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFilter<'Service'> | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFilter<'Service'> | $Enums.ServiceStatus;
    completedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
    cancelledAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
    cancellationReason?: StringNullableFilter<'Service'> | string | null;
    archivedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
    notes?: StringNullableFilter<'Service'> | string | null;
    internalNotes?: StringNullableFilter<'Service'> | string | null;
    attachments?: StringNullableListFilter<'Service'>;
    customFields?: JsonNullableFilter<'Service'>;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
  };

  export type ServiceUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutAssignedToInput, ServiceUncheckedUpdateWithoutAssignedToInput>;
    create: XOR<ServiceCreateWithoutAssignedToInput, ServiceUncheckedCreateWithoutAssignedToInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutAssignedToInput, ServiceUncheckedUpdateWithoutAssignedToInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutAssignedToInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutAssignedToInput>;
  };

  export type LoadingOrderUpsertWithWhereUniqueWithoutGeneratedByInput = {
    where: LoadingOrderWhereUniqueInput;
    update: XOR<
      LoadingOrderUpdateWithoutGeneratedByInput,
      LoadingOrderUncheckedUpdateWithoutGeneratedByInput
    >;
    create: XOR<
      LoadingOrderCreateWithoutGeneratedByInput,
      LoadingOrderUncheckedCreateWithoutGeneratedByInput
    >;
  };

  export type LoadingOrderUpdateWithWhereUniqueWithoutGeneratedByInput = {
    where: LoadingOrderWhereUniqueInput;
    data: XOR<
      LoadingOrderUpdateWithoutGeneratedByInput,
      LoadingOrderUncheckedUpdateWithoutGeneratedByInput
    >;
  };

  export type LoadingOrderUpdateManyWithWhereWithoutGeneratedByInput = {
    where: LoadingOrderScalarWhereInput;
    data: XOR<
      LoadingOrderUpdateManyMutationInput,
      LoadingOrderUncheckedUpdateManyWithoutGeneratedByInput
    >;
  };

  export type LoadingOrderScalarWhereInput = {
    AND?: LoadingOrderScalarWhereInput | LoadingOrderScalarWhereInput[];
    OR?: LoadingOrderScalarWhereInput[];
    NOT?: LoadingOrderScalarWhereInput | LoadingOrderScalarWhereInput[];
    id?: StringFilter<'LoadingOrder'> | string;
    orderNumber?: StringFilter<'LoadingOrder'> | string;
    generatedAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
    generatedById?: StringFilter<'LoadingOrder'> | string;
    clientId?: StringNullableFilter<'LoadingOrder'> | string | null;
    notes?: StringNullableFilter<'LoadingOrder'> | string | null;
    pdfPath?: StringNullableFilter<'LoadingOrder'> | string | null;
    pdfGeneratedAt?: DateTimeNullableFilter<'LoadingOrder'> | Date | string | null;
    pdfSize?: IntNullableFilter<'LoadingOrder'> | number | null;
    metadata?: JsonNullableFilter<'LoadingOrder'>;
    createdAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
    updatedAt?: DateTimeFilter<'LoadingOrder'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'LoadingOrder'> | Date | string | null;
  };

  export type InvoiceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput;
    update: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>;
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>;
  };

  export type InvoiceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput;
    data: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>;
  };

  export type InvoiceUpdateManyWithWhereWithoutCreatedByInput = {
    where: InvoiceScalarWhereInput;
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCreatedByInput>;
  };

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
    OR?: InvoiceScalarWhereInput[];
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
    id?: StringFilter<'Invoice'> | string;
    invoiceNumber?: StringFilter<'Invoice'> | string;
    invoiceDate?: DateTimeFilter<'Invoice'> | Date | string;
    dueDate?: DateTimeFilter<'Invoice'> | Date | string;
    supplierId?: StringFilter<'Invoice'> | string;
    createdById?: StringFilter<'Invoice'> | string;
    subtotal?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    currency?: StringFilter<'Invoice'> | string;
    status?: EnumInvoiceStatusFilter<'Invoice'> | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFilter<'Invoice'> | $Enums.PaymentStatus;
    paidAmount?: DecimalFilter<'Invoice'> | Decimal | DecimalJsLike | number | string;
    paidAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    paymentMethod?: StringNullableFilter<'Invoice'> | string | null;
    paymentReference?: StringNullableFilter<'Invoice'> | string | null;
    irpfRate?: DecimalNullableFilter<'Invoice'> | Decimal | DecimalJsLike | number | string | null;
    irpfAmount?:
      | DecimalNullableFilter<'Invoice'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: StringNullableFilter<'Invoice'> | string | null;
    notes?: StringNullableFilter<'Invoice'> | string | null;
    termsConditions?: StringNullableFilter<'Invoice'> | string | null;
    pdfPath?: StringNullableFilter<'Invoice'> | string | null;
    pdfGeneratedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    sentAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    sentTo?: StringNullableFilter<'Invoice'> | string | null;
    viewedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    reminderSentAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    metadata?: JsonNullableFilter<'Invoice'>;
    createdAt?: DateTimeFilter<'Invoice'> | Date | string;
    updatedAt?: DateTimeFilter<'Invoice'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>;
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>;
  };

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>;
  };

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    userId?: StringNullableFilter<'AuditLog'> | string | null;
    action?: EnumAuditActionFilter<'AuditLog'> | $Enums.AuditAction;
    tableName?: StringFilter<'AuditLog'> | string;
    recordId?: StringFilter<'AuditLog'> | string;
    oldValues?: JsonNullableFilter<'AuditLog'>;
    newValues?: JsonNullableFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    requestId?: StringNullableFilter<'AuditLog'> | string | null;
    metadata?: JsonNullableFilter<'AuditLog'>;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
  };

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
  };

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
  };

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    type?: StringFilter<'Notification'> | string;
    category?: StringFilter<'Notification'> | string;
    actionUrl?: StringNullableFilter<'Notification'> | string | null;
    actionLabel?: StringNullableFilter<'Notification'> | string | null;
    isRead?: BoolFilter<'Notification'> | boolean;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
  };

  export type ClientCreateWithoutCompanyInput = {
    id?: string;
    clientCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceCreateNestedManyWithoutClientInput;
    contacts?: ClientContactCreateNestedManyWithoutClientInput;
    documents?: DocumentCreateNestedManyWithoutClientInput;
  };

  export type ClientUncheckedCreateWithoutCompanyInput = {
    id?: string;
    clientCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutClientInput;
    contacts?: ClientContactUncheckedCreateNestedManyWithoutClientInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientCreateOrConnectWithoutCompanyInput = {
    where: ClientWhereUniqueInput;
    create: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>;
  };

  export type ClientCreateManyCompanyInputEnvelope = {
    data: ClientCreateManyCompanyInput | ClientCreateManyCompanyInput[];
    skipDuplicates?: boolean;
  };

  export type SupplierCreateWithoutCompanyInput = {
    id?: string;
    supplierCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceCreateNestedManyWithoutSupplierInput;
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput;
    documents?: DocumentCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierUncheckedCreateWithoutCompanyInput = {
    id?: string;
    supplierCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutSupplierInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierCreateOrConnectWithoutCompanyInput = {
    where: SupplierWhereUniqueInput;
    create: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>;
  };

  export type SupplierCreateManyCompanyInputEnvelope = {
    data: SupplierCreateManyCompanyInput | SupplierCreateManyCompanyInput[];
    skipDuplicates?: boolean;
  };

  export type ClientUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ClientWhereUniqueInput;
    update: XOR<ClientUpdateWithoutCompanyInput, ClientUncheckedUpdateWithoutCompanyInput>;
    create: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>;
  };

  export type ClientUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ClientWhereUniqueInput;
    data: XOR<ClientUpdateWithoutCompanyInput, ClientUncheckedUpdateWithoutCompanyInput>;
  };

  export type ClientUpdateManyWithWhereWithoutCompanyInput = {
    where: ClientScalarWhereInput;
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutCompanyInput>;
  };

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[];
    OR?: ClientScalarWhereInput[];
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[];
    id?: StringFilter<'Client'> | string;
    clientCode?: StringFilter<'Client'> | string;
    companyId?: StringNullableFilter<'Client'> | string | null;
    name?: StringFilter<'Client'> | string;
    tradeName?: StringNullableFilter<'Client'> | string | null;
    vatNumber?: StringNullableFilter<'Client'> | string | null;
    billingAddress?: JsonFilter<'Client'>;
    shippingAddress?: JsonNullableFilter<'Client'>;
    billingEmail?: StringFilter<'Client'> | string;
    trafficEmail?: StringNullableFilter<'Client'> | string | null;
    contactPerson?: StringNullableFilter<'Client'> | string | null;
    contactPhone?: StringNullableFilter<'Client'> | string | null;
    contactMobile?: StringNullableFilter<'Client'> | string | null;
    creditLimit?:
      | DecimalNullableFilter<'Client'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFilter<'Client'> | number;
    discount?: DecimalNullableFilter<'Client'> | Decimal | DecimalJsLike | number | string | null;
    currency?: StringFilter<'Client'> | string;
    language?: StringFilter<'Client'> | string;
    sendReminders?: BoolFilter<'Client'> | boolean;
    autoInvoice?: BoolFilter<'Client'> | boolean;
    notes?: StringNullableFilter<'Client'> | string | null;
    tags?: StringNullableListFilter<'Client'>;
    metadata?: JsonNullableFilter<'Client'>;
    isActive?: BoolFilter<'Client'> | boolean;
    createdAt?: DateTimeFilter<'Client'> | Date | string;
    updatedAt?: DateTimeFilter<'Client'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Client'> | Date | string | null;
  };

  export type SupplierUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SupplierWhereUniqueInput;
    update: XOR<SupplierUpdateWithoutCompanyInput, SupplierUncheckedUpdateWithoutCompanyInput>;
    create: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>;
  };

  export type SupplierUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SupplierWhereUniqueInput;
    data: XOR<SupplierUpdateWithoutCompanyInput, SupplierUncheckedUpdateWithoutCompanyInput>;
  };

  export type SupplierUpdateManyWithWhereWithoutCompanyInput = {
    where: SupplierScalarWhereInput;
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutCompanyInput>;
  };

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[];
    OR?: SupplierScalarWhereInput[];
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[];
    id?: StringFilter<'Supplier'> | string;
    supplierCode?: StringFilter<'Supplier'> | string;
    companyId?: StringNullableFilter<'Supplier'> | string | null;
    name?: StringFilter<'Supplier'> | string;
    tradeName?: StringNullableFilter<'Supplier'> | string | null;
    vatNumber?: StringNullableFilter<'Supplier'> | string | null;
    addressLine1?: StringFilter<'Supplier'> | string;
    addressLine2?: StringNullableFilter<'Supplier'> | string | null;
    city?: StringFilter<'Supplier'> | string;
    state?: StringNullableFilter<'Supplier'> | string | null;
    postalCode?: StringFilter<'Supplier'> | string;
    country?: StringFilter<'Supplier'> | string;
    email?: StringFilter<'Supplier'> | string;
    phone?: StringNullableFilter<'Supplier'> | string | null;
    fax?: StringNullableFilter<'Supplier'> | string | null;
    contactPerson?: StringNullableFilter<'Supplier'> | string | null;
    contactMobile?: StringNullableFilter<'Supplier'> | string | null;
    irpfRate?: DecimalNullableFilter<'Supplier'> | Decimal | DecimalJsLike | number | string | null;
    vatRate?: DecimalFilter<'Supplier'> | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFilter<'Supplier'> | number;
    paymentMethod?: StringNullableFilter<'Supplier'> | string | null;
    bankName?: StringNullableFilter<'Supplier'> | string | null;
    bankAccount?: StringNullableFilter<'Supplier'> | string | null;
    swiftCode?: StringNullableFilter<'Supplier'> | string | null;
    iban?: StringNullableFilter<'Supplier'> | string | null;
    currency?: StringFilter<'Supplier'> | string;
    autoApprove?: BoolFilter<'Supplier'> | boolean;
    requirePO?: BoolFilter<'Supplier'> | boolean;
    notes?: StringNullableFilter<'Supplier'> | string | null;
    tags?: StringNullableListFilter<'Supplier'>;
    metadata?: JsonNullableFilter<'Supplier'>;
    isActive?: BoolFilter<'Supplier'> | boolean;
    createdAt?: DateTimeFilter<'Supplier'> | Date | string;
    updatedAt?: DateTimeFilter<'Supplier'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Supplier'> | Date | string | null;
  };

  export type CompanyCreateWithoutAsClientInput = {
    id?: string;
    code: string;
    legalName: string;
    tradeName?: string | null;
    vatNumber: string;
    registrationNo?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    phone: string;
    fax?: string | null;
    email: string;
    website?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    timezone?: string;
    fiscalYearEnd?: string | null;
    invoicePrefix?: string | null;
    logoUrl?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    asSupplier?: SupplierCreateNestedManyWithoutCompanyInput;
  };

  export type CompanyUncheckedCreateWithoutAsClientInput = {
    id?: string;
    code: string;
    legalName: string;
    tradeName?: string | null;
    vatNumber: string;
    registrationNo?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    phone: string;
    fax?: string | null;
    email: string;
    website?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    timezone?: string;
    fiscalYearEnd?: string | null;
    invoicePrefix?: string | null;
    logoUrl?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    asSupplier?: SupplierUncheckedCreateNestedManyWithoutCompanyInput;
  };

  export type CompanyCreateOrConnectWithoutAsClientInput = {
    where: CompanyWhereUniqueInput;
    create: XOR<CompanyCreateWithoutAsClientInput, CompanyUncheckedCreateWithoutAsClientInput>;
  };

  export type ServiceCreateWithoutClientInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    supplier: SupplierCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
    assignedTo?: UserCreateNestedOneWithoutAssignedServicesInput;
    loadingOrders?: ServiceLoadingOrderCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput;
    documents?: DocumentCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutClientInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    supplierId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutClientInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutClientInput, ServiceUncheckedCreateWithoutClientInput>;
  };

  export type ServiceCreateManyClientInputEnvelope = {
    data: ServiceCreateManyClientInput | ServiceCreateManyClientInput[];
    skipDuplicates?: boolean;
  };

  export type ClientContactCreateWithoutClientInput = {
    id?: string;
    name: string;
    position?: string | null;
    email: string;
    phone?: string | null;
    mobile?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ClientContactUncheckedCreateWithoutClientInput = {
    id?: string;
    name: string;
    position?: string | null;
    email: string;
    phone?: string | null;
    mobile?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ClientContactCreateOrConnectWithoutClientInput = {
    where: ClientContactWhereUniqueInput;
    create: XOR<
      ClientContactCreateWithoutClientInput,
      ClientContactUncheckedCreateWithoutClientInput
    >;
  };

  export type ClientContactCreateManyClientInputEnvelope = {
    data: ClientContactCreateManyClientInput | ClientContactCreateManyClientInput[];
    skipDuplicates?: boolean;
  };

  export type DocumentCreateWithoutClientInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
    supplier?: SupplierCreateNestedOneWithoutDocumentsInput;
    service?: ServiceCreateNestedOneWithoutDocumentsInput;
  };

  export type DocumentUncheckedCreateWithoutClientInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    supplierId?: string | null;
    serviceId?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type DocumentCreateOrConnectWithoutClientInput = {
    where: DocumentWhereUniqueInput;
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>;
  };

  export type DocumentCreateManyClientInputEnvelope = {
    data: DocumentCreateManyClientInput | DocumentCreateManyClientInput[];
    skipDuplicates?: boolean;
  };

  export type CompanyUpsertWithoutAsClientInput = {
    update: XOR<CompanyUpdateWithoutAsClientInput, CompanyUncheckedUpdateWithoutAsClientInput>;
    create: XOR<CompanyCreateWithoutAsClientInput, CompanyUncheckedCreateWithoutAsClientInput>;
    where?: CompanyWhereInput;
  };

  export type CompanyUpdateToOneWithWhereWithoutAsClientInput = {
    where?: CompanyWhereInput;
    data: XOR<CompanyUpdateWithoutAsClientInput, CompanyUncheckedUpdateWithoutAsClientInput>;
  };

  export type CompanyUpdateWithoutAsClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    legalName?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: StringFieldUpdateOperationsInput | string;
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    timezone?: StringFieldUpdateOperationsInput | string;
    fiscalYearEnd?: NullableStringFieldUpdateOperationsInput | string | null;
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    asSupplier?: SupplierUpdateManyWithoutCompanyNestedInput;
  };

  export type CompanyUncheckedUpdateWithoutAsClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    legalName?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: StringFieldUpdateOperationsInput | string;
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    timezone?: StringFieldUpdateOperationsInput | string;
    fiscalYearEnd?: NullableStringFieldUpdateOperationsInput | string | null;
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    asSupplier?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput;
  };

  export type ServiceUpsertWithWhereUniqueWithoutClientInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutClientInput, ServiceUncheckedUpdateWithoutClientInput>;
    create: XOR<ServiceCreateWithoutClientInput, ServiceUncheckedCreateWithoutClientInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutClientInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutClientInput, ServiceUncheckedUpdateWithoutClientInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutClientInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutClientInput>;
  };

  export type ClientContactUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientContactWhereUniqueInput;
    update: XOR<
      ClientContactUpdateWithoutClientInput,
      ClientContactUncheckedUpdateWithoutClientInput
    >;
    create: XOR<
      ClientContactCreateWithoutClientInput,
      ClientContactUncheckedCreateWithoutClientInput
    >;
  };

  export type ClientContactUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientContactWhereUniqueInput;
    data: XOR<
      ClientContactUpdateWithoutClientInput,
      ClientContactUncheckedUpdateWithoutClientInput
    >;
  };

  export type ClientContactUpdateManyWithWhereWithoutClientInput = {
    where: ClientContactScalarWhereInput;
    data: XOR<
      ClientContactUpdateManyMutationInput,
      ClientContactUncheckedUpdateManyWithoutClientInput
    >;
  };

  export type ClientContactScalarWhereInput = {
    AND?: ClientContactScalarWhereInput | ClientContactScalarWhereInput[];
    OR?: ClientContactScalarWhereInput[];
    NOT?: ClientContactScalarWhereInput | ClientContactScalarWhereInput[];
    id?: StringFilter<'ClientContact'> | string;
    clientId?: StringFilter<'ClientContact'> | string;
    name?: StringFilter<'ClientContact'> | string;
    position?: StringNullableFilter<'ClientContact'> | string | null;
    email?: StringFilter<'ClientContact'> | string;
    phone?: StringNullableFilter<'ClientContact'> | string | null;
    mobile?: StringNullableFilter<'ClientContact'> | string | null;
    isPrimary?: BoolFilter<'ClientContact'> | boolean;
    createdAt?: DateTimeFilter<'ClientContact'> | Date | string;
    updatedAt?: DateTimeFilter<'ClientContact'> | Date | string;
  };

  export type DocumentUpsertWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput;
    update: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>;
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>;
  };

  export type DocumentUpdateWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput;
    data: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>;
  };

  export type DocumentUpdateManyWithWhereWithoutClientInput = {
    where: DocumentScalarWhereInput;
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClientInput>;
  };

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
    OR?: DocumentScalarWhereInput[];
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
    id?: StringFilter<'Document'> | string;
    documentType?: EnumDocumentTypeFilter<'Document'> | $Enums.DocumentType;
    documentNumber?: StringNullableFilter<'Document'> | string | null;
    clientId?: StringNullableFilter<'Document'> | string | null;
    supplierId?: StringNullableFilter<'Document'> | string | null;
    serviceId?: StringNullableFilter<'Document'> | string | null;
    fileName?: StringFilter<'Document'> | string;
    filePath?: StringFilter<'Document'> | string;
    fileSize?: IntFilter<'Document'> | number;
    mimeType?: StringFilter<'Document'> | string;
    description?: StringNullableFilter<'Document'> | string | null;
    tags?: StringNullableListFilter<'Document'>;
    metadata?: JsonNullableFilter<'Document'>;
    uploadedBy?: StringFilter<'Document'> | string;
    uploadedAt?: DateTimeFilter<'Document'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Document'> | Date | string | null;
  };

  export type ClientCreateWithoutContactsInput = {
    id?: string;
    clientCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    company?: CompanyCreateNestedOneWithoutAsClientInput;
    services?: ServiceCreateNestedManyWithoutClientInput;
    documents?: DocumentCreateNestedManyWithoutClientInput;
  };

  export type ClientUncheckedCreateWithoutContactsInput = {
    id?: string;
    clientCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutClientInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientCreateOrConnectWithoutContactsInput = {
    where: ClientWhereUniqueInput;
    create: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>;
  };

  export type ClientUpsertWithoutContactsInput = {
    update: XOR<ClientUpdateWithoutContactsInput, ClientUncheckedUpdateWithoutContactsInput>;
    create: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>;
    where?: ClientWhereInput;
  };

  export type ClientUpdateToOneWithWhereWithoutContactsInput = {
    where?: ClientWhereInput;
    data: XOR<ClientUpdateWithoutContactsInput, ClientUncheckedUpdateWithoutContactsInput>;
  };

  export type ClientUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    company?: CompanyUpdateOneWithoutAsClientNestedInput;
    services?: ServiceUpdateManyWithoutClientNestedInput;
    documents?: DocumentUpdateManyWithoutClientNestedInput;
  };

  export type ClientUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUncheckedUpdateManyWithoutClientNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type CompanyCreateWithoutAsSupplierInput = {
    id?: string;
    code: string;
    legalName: string;
    tradeName?: string | null;
    vatNumber: string;
    registrationNo?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    phone: string;
    fax?: string | null;
    email: string;
    website?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    timezone?: string;
    fiscalYearEnd?: string | null;
    invoicePrefix?: string | null;
    logoUrl?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    asClient?: ClientCreateNestedManyWithoutCompanyInput;
  };

  export type CompanyUncheckedCreateWithoutAsSupplierInput = {
    id?: string;
    code: string;
    legalName: string;
    tradeName?: string | null;
    vatNumber: string;
    registrationNo?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    phone: string;
    fax?: string | null;
    email: string;
    website?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    timezone?: string;
    fiscalYearEnd?: string | null;
    invoicePrefix?: string | null;
    logoUrl?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    asClient?: ClientUncheckedCreateNestedManyWithoutCompanyInput;
  };

  export type CompanyCreateOrConnectWithoutAsSupplierInput = {
    where: CompanyWhereUniqueInput;
    create: XOR<CompanyCreateWithoutAsSupplierInput, CompanyUncheckedCreateWithoutAsSupplierInput>;
  };

  export type ServiceCreateWithoutSupplierInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    client: ClientCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
    assignedTo?: UserCreateNestedOneWithoutAssignedServicesInput;
    loadingOrders?: ServiceLoadingOrderCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput;
    documents?: DocumentCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutSupplierInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutSupplierInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutSupplierInput, ServiceUncheckedCreateWithoutSupplierInput>;
  };

  export type ServiceCreateManySupplierInputEnvelope = {
    data: ServiceCreateManySupplierInput | ServiceCreateManySupplierInput[];
    skipDuplicates?: boolean;
  };

  export type InvoiceCreateWithoutSupplierInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    createdBy: UserCreateNestedOneWithoutInvoicesInput;
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput;
    payments?: PaymentCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceUncheckedCreateWithoutSupplierInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    createdById: string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceCreateOrConnectWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput;
    create: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>;
  };

  export type InvoiceCreateManySupplierInputEnvelope = {
    data: InvoiceCreateManySupplierInput | InvoiceCreateManySupplierInput[];
    skipDuplicates?: boolean;
  };

  export type DocumentCreateWithoutSupplierInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
    client?: ClientCreateNestedOneWithoutDocumentsInput;
    service?: ServiceCreateNestedOneWithoutDocumentsInput;
  };

  export type DocumentUncheckedCreateWithoutSupplierInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    clientId?: string | null;
    serviceId?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type DocumentCreateOrConnectWithoutSupplierInput = {
    where: DocumentWhereUniqueInput;
    create: XOR<DocumentCreateWithoutSupplierInput, DocumentUncheckedCreateWithoutSupplierInput>;
  };

  export type DocumentCreateManySupplierInputEnvelope = {
    data: DocumentCreateManySupplierInput | DocumentCreateManySupplierInput[];
    skipDuplicates?: boolean;
  };

  export type CompanyUpsertWithoutAsSupplierInput = {
    update: XOR<CompanyUpdateWithoutAsSupplierInput, CompanyUncheckedUpdateWithoutAsSupplierInput>;
    create: XOR<CompanyCreateWithoutAsSupplierInput, CompanyUncheckedCreateWithoutAsSupplierInput>;
    where?: CompanyWhereInput;
  };

  export type CompanyUpdateToOneWithWhereWithoutAsSupplierInput = {
    where?: CompanyWhereInput;
    data: XOR<CompanyUpdateWithoutAsSupplierInput, CompanyUncheckedUpdateWithoutAsSupplierInput>;
  };

  export type CompanyUpdateWithoutAsSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    legalName?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: StringFieldUpdateOperationsInput | string;
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    timezone?: StringFieldUpdateOperationsInput | string;
    fiscalYearEnd?: NullableStringFieldUpdateOperationsInput | string | null;
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    asClient?: ClientUpdateManyWithoutCompanyNestedInput;
  };

  export type CompanyUncheckedUpdateWithoutAsSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    legalName?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: StringFieldUpdateOperationsInput | string;
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    timezone?: StringFieldUpdateOperationsInput | string;
    fiscalYearEnd?: NullableStringFieldUpdateOperationsInput | string | null;
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    asClient?: ClientUncheckedUpdateManyWithoutCompanyNestedInput;
  };

  export type ServiceUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutSupplierInput, ServiceUncheckedUpdateWithoutSupplierInput>;
    create: XOR<ServiceCreateWithoutSupplierInput, ServiceUncheckedCreateWithoutSupplierInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutSupplierInput, ServiceUncheckedUpdateWithoutSupplierInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutSupplierInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutSupplierInput>;
  };

  export type InvoiceUpsertWithWhereUniqueWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput;
    update: XOR<InvoiceUpdateWithoutSupplierInput, InvoiceUncheckedUpdateWithoutSupplierInput>;
    create: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>;
  };

  export type InvoiceUpdateWithWhereUniqueWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput;
    data: XOR<InvoiceUpdateWithoutSupplierInput, InvoiceUncheckedUpdateWithoutSupplierInput>;
  };

  export type InvoiceUpdateManyWithWhereWithoutSupplierInput = {
    where: InvoiceScalarWhereInput;
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSupplierInput>;
  };

  export type DocumentUpsertWithWhereUniqueWithoutSupplierInput = {
    where: DocumentWhereUniqueInput;
    update: XOR<DocumentUpdateWithoutSupplierInput, DocumentUncheckedUpdateWithoutSupplierInput>;
    create: XOR<DocumentCreateWithoutSupplierInput, DocumentUncheckedCreateWithoutSupplierInput>;
  };

  export type DocumentUpdateWithWhereUniqueWithoutSupplierInput = {
    where: DocumentWhereUniqueInput;
    data: XOR<DocumentUpdateWithoutSupplierInput, DocumentUncheckedUpdateWithoutSupplierInput>;
  };

  export type DocumentUpdateManyWithWhereWithoutSupplierInput = {
    where: DocumentScalarWhereInput;
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutSupplierInput>;
  };

  export type ClientCreateWithoutServicesInput = {
    id?: string;
    clientCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    company?: CompanyCreateNestedOneWithoutAsClientInput;
    contacts?: ClientContactCreateNestedManyWithoutClientInput;
    documents?: DocumentCreateNestedManyWithoutClientInput;
  };

  export type ClientUncheckedCreateWithoutServicesInput = {
    id?: string;
    clientCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    contacts?: ClientContactUncheckedCreateNestedManyWithoutClientInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientCreateOrConnectWithoutServicesInput = {
    where: ClientWhereUniqueInput;
    create: XOR<ClientCreateWithoutServicesInput, ClientUncheckedCreateWithoutServicesInput>;
  };

  export type SupplierCreateWithoutServicesInput = {
    id?: string;
    supplierCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    company?: CompanyCreateNestedOneWithoutAsSupplierInput;
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput;
    documents?: DocumentCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierUncheckedCreateWithoutServicesInput = {
    id?: string;
    supplierCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierCreateOrConnectWithoutServicesInput = {
    where: SupplierWhereUniqueInput;
    create: XOR<SupplierCreateWithoutServicesInput, SupplierUncheckedCreateWithoutServicesInput>;
  };

  export type UserCreateWithoutServicesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    assignedServices?: ServiceCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutServicesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    assignedServices?: ServiceUncheckedCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutServicesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>;
  };

  export type UserCreateWithoutAssignedServicesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    loadingOrders?: LoadingOrderCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAssignedServicesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    loadingOrders?: LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAssignedServicesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAssignedServicesInput,
      UserUncheckedCreateWithoutAssignedServicesInput
    >;
  };

  export type ServiceLoadingOrderCreateWithoutServiceInput = {
    id?: string;
    position: number;
    loadingOrder: LoadingOrderCreateNestedOneWithoutServicesInput;
  };

  export type ServiceLoadingOrderUncheckedCreateWithoutServiceInput = {
    id?: string;
    loadingOrderId: string;
    position: number;
  };

  export type ServiceLoadingOrderCreateOrConnectWithoutServiceInput = {
    where: ServiceLoadingOrderWhereUniqueInput;
    create: XOR<
      ServiceLoadingOrderCreateWithoutServiceInput,
      ServiceLoadingOrderUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceLoadingOrderCreateManyServiceInputEnvelope = {
    data: ServiceLoadingOrderCreateManyServiceInput | ServiceLoadingOrderCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type InvoiceItemCreateWithoutServiceInput = {
    id?: string;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    invoice: InvoiceCreateNestedOneWithoutItemsInput;
  };

  export type InvoiceItemUncheckedCreateWithoutServiceInput = {
    id?: string;
    invoiceId: string;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
  };

  export type InvoiceItemCreateOrConnectWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput;
    create: XOR<
      InvoiceItemCreateWithoutServiceInput,
      InvoiceItemUncheckedCreateWithoutServiceInput
    >;
  };

  export type InvoiceItemCreateManyServiceInputEnvelope = {
    data: InvoiceItemCreateManyServiceInput | InvoiceItemCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type DocumentCreateWithoutServiceInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
    client?: ClientCreateNestedOneWithoutDocumentsInput;
    supplier?: SupplierCreateNestedOneWithoutDocumentsInput;
  };

  export type DocumentUncheckedCreateWithoutServiceInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    clientId?: string | null;
    supplierId?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type DocumentCreateOrConnectWithoutServiceInput = {
    where: DocumentWhereUniqueInput;
    create: XOR<DocumentCreateWithoutServiceInput, DocumentUncheckedCreateWithoutServiceInput>;
  };

  export type DocumentCreateManyServiceInputEnvelope = {
    data: DocumentCreateManyServiceInput | DocumentCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceStatusHistoryCreateWithoutServiceInput = {
    id?: string;
    fromStatus?: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus;
    reason?: string | null;
    changedBy: string;
    changedAt?: Date | string;
  };

  export type ServiceStatusHistoryUncheckedCreateWithoutServiceInput = {
    id?: string;
    fromStatus?: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus;
    reason?: string | null;
    changedBy: string;
    changedAt?: Date | string;
  };

  export type ServiceStatusHistoryCreateOrConnectWithoutServiceInput = {
    where: ServiceStatusHistoryWhereUniqueInput;
    create: XOR<
      ServiceStatusHistoryCreateWithoutServiceInput,
      ServiceStatusHistoryUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceStatusHistoryCreateManyServiceInputEnvelope = {
    data: ServiceStatusHistoryCreateManyServiceInput | ServiceStatusHistoryCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type ClientUpsertWithoutServicesInput = {
    update: XOR<ClientUpdateWithoutServicesInput, ClientUncheckedUpdateWithoutServicesInput>;
    create: XOR<ClientCreateWithoutServicesInput, ClientUncheckedCreateWithoutServicesInput>;
    where?: ClientWhereInput;
  };

  export type ClientUpdateToOneWithWhereWithoutServicesInput = {
    where?: ClientWhereInput;
    data: XOR<ClientUpdateWithoutServicesInput, ClientUncheckedUpdateWithoutServicesInput>;
  };

  export type ClientUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    company?: CompanyUpdateOneWithoutAsClientNestedInput;
    contacts?: ClientContactUpdateManyWithoutClientNestedInput;
    documents?: DocumentUpdateManyWithoutClientNestedInput;
  };

  export type ClientUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    contacts?: ClientContactUncheckedUpdateManyWithoutClientNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type SupplierUpsertWithoutServicesInput = {
    update: XOR<SupplierUpdateWithoutServicesInput, SupplierUncheckedUpdateWithoutServicesInput>;
    create: XOR<SupplierCreateWithoutServicesInput, SupplierUncheckedCreateWithoutServicesInput>;
    where?: SupplierWhereInput;
  };

  export type SupplierUpdateToOneWithWhereWithoutServicesInput = {
    where?: SupplierWhereInput;
    data: XOR<SupplierUpdateWithoutServicesInput, SupplierUncheckedUpdateWithoutServicesInput>;
  };

  export type SupplierUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    company?: CompanyUpdateOneWithoutAsSupplierNestedInput;
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput;
    documents?: DocumentUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutSupplierNestedInput;
  };

  export type UserUpsertWithoutServicesInput = {
    update: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>;
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>;
  };

  export type UserUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    assignedServices?: ServiceUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    assignedServices?: ServiceUncheckedUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserUpsertWithoutAssignedServicesInput = {
    update: XOR<
      UserUpdateWithoutAssignedServicesInput,
      UserUncheckedUpdateWithoutAssignedServicesInput
    >;
    create: XOR<
      UserCreateWithoutAssignedServicesInput,
      UserUncheckedCreateWithoutAssignedServicesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAssignedServicesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAssignedServicesInput,
      UserUncheckedUpdateWithoutAssignedServicesInput
    >;
  };

  export type UserUpdateWithoutAssignedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    loadingOrders?: LoadingOrderUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAssignedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    loadingOrders?: LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ServiceLoadingOrderUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceLoadingOrderWhereUniqueInput;
    update: XOR<
      ServiceLoadingOrderUpdateWithoutServiceInput,
      ServiceLoadingOrderUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      ServiceLoadingOrderCreateWithoutServiceInput,
      ServiceLoadingOrderUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceLoadingOrderUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceLoadingOrderWhereUniqueInput;
    data: XOR<
      ServiceLoadingOrderUpdateWithoutServiceInput,
      ServiceLoadingOrderUncheckedUpdateWithoutServiceInput
    >;
  };

  export type ServiceLoadingOrderUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceLoadingOrderScalarWhereInput;
    data: XOR<
      ServiceLoadingOrderUpdateManyMutationInput,
      ServiceLoadingOrderUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type ServiceLoadingOrderScalarWhereInput = {
    AND?: ServiceLoadingOrderScalarWhereInput | ServiceLoadingOrderScalarWhereInput[];
    OR?: ServiceLoadingOrderScalarWhereInput[];
    NOT?: ServiceLoadingOrderScalarWhereInput | ServiceLoadingOrderScalarWhereInput[];
    id?: StringFilter<'ServiceLoadingOrder'> | string;
    serviceId?: StringFilter<'ServiceLoadingOrder'> | string;
    loadingOrderId?: StringFilter<'ServiceLoadingOrder'> | string;
    position?: IntFilter<'ServiceLoadingOrder'> | number;
  };

  export type InvoiceItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput;
    update: XOR<
      InvoiceItemUpdateWithoutServiceInput,
      InvoiceItemUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      InvoiceItemCreateWithoutServiceInput,
      InvoiceItemUncheckedCreateWithoutServiceInput
    >;
  };

  export type InvoiceItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput;
    data: XOR<InvoiceItemUpdateWithoutServiceInput, InvoiceItemUncheckedUpdateWithoutServiceInput>;
  };

  export type InvoiceItemUpdateManyWithWhereWithoutServiceInput = {
    where: InvoiceItemScalarWhereInput;
    data: XOR<
      InvoiceItemUpdateManyMutationInput,
      InvoiceItemUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[];
    OR?: InvoiceItemScalarWhereInput[];
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[];
    id?: StringFilter<'InvoiceItem'> | string;
    invoiceId?: StringFilter<'InvoiceItem'> | string;
    serviceId?: StringNullableFilter<'InvoiceItem'> | string | null;
    description?: StringFilter<'InvoiceItem'> | string;
    quantity?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFilter<'InvoiceItem'> | Decimal | DecimalJsLike | number | string;
  };

  export type DocumentUpsertWithWhereUniqueWithoutServiceInput = {
    where: DocumentWhereUniqueInput;
    update: XOR<DocumentUpdateWithoutServiceInput, DocumentUncheckedUpdateWithoutServiceInput>;
    create: XOR<DocumentCreateWithoutServiceInput, DocumentUncheckedCreateWithoutServiceInput>;
  };

  export type DocumentUpdateWithWhereUniqueWithoutServiceInput = {
    where: DocumentWhereUniqueInput;
    data: XOR<DocumentUpdateWithoutServiceInput, DocumentUncheckedUpdateWithoutServiceInput>;
  };

  export type DocumentUpdateManyWithWhereWithoutServiceInput = {
    where: DocumentScalarWhereInput;
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutServiceInput>;
  };

  export type ServiceStatusHistoryUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceStatusHistoryWhereUniqueInput;
    update: XOR<
      ServiceStatusHistoryUpdateWithoutServiceInput,
      ServiceStatusHistoryUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      ServiceStatusHistoryCreateWithoutServiceInput,
      ServiceStatusHistoryUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceStatusHistoryUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceStatusHistoryWhereUniqueInput;
    data: XOR<
      ServiceStatusHistoryUpdateWithoutServiceInput,
      ServiceStatusHistoryUncheckedUpdateWithoutServiceInput
    >;
  };

  export type ServiceStatusHistoryUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceStatusHistoryScalarWhereInput;
    data: XOR<
      ServiceStatusHistoryUpdateManyMutationInput,
      ServiceStatusHistoryUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type ServiceStatusHistoryScalarWhereInput = {
    AND?: ServiceStatusHistoryScalarWhereInput | ServiceStatusHistoryScalarWhereInput[];
    OR?: ServiceStatusHistoryScalarWhereInput[];
    NOT?: ServiceStatusHistoryScalarWhereInput | ServiceStatusHistoryScalarWhereInput[];
    id?: StringFilter<'ServiceStatusHistory'> | string;
    serviceId?: StringFilter<'ServiceStatusHistory'> | string;
    fromStatus?:
      | EnumServiceStatusNullableFilter<'ServiceStatusHistory'>
      | $Enums.ServiceStatus
      | null;
    toStatus?: EnumServiceStatusFilter<'ServiceStatusHistory'> | $Enums.ServiceStatus;
    reason?: StringNullableFilter<'ServiceStatusHistory'> | string | null;
    changedBy?: StringFilter<'ServiceStatusHistory'> | string;
    changedAt?: DateTimeFilter<'ServiceStatusHistory'> | Date | string;
  };

  export type ServiceCreateWithoutStatusHistoryInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    client: ClientCreateNestedOneWithoutServicesInput;
    supplier: SupplierCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
    assignedTo?: UserCreateNestedOneWithoutAssignedServicesInput;
    loadingOrders?: ServiceLoadingOrderCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput;
    documents?: DocumentCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutStatusHistoryInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutStatusHistoryInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutStatusHistoryInput,
      ServiceUncheckedCreateWithoutStatusHistoryInput
    >;
  };

  export type ServiceUpsertWithoutStatusHistoryInput = {
    update: XOR<
      ServiceUpdateWithoutStatusHistoryInput,
      ServiceUncheckedUpdateWithoutStatusHistoryInput
    >;
    create: XOR<
      ServiceCreateWithoutStatusHistoryInput,
      ServiceUncheckedCreateWithoutStatusHistoryInput
    >;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: ServiceWhereInput;
    data: XOR<
      ServiceUpdateWithoutStatusHistoryInput,
      ServiceUncheckedUpdateWithoutStatusHistoryInput
    >;
  };

  export type ServiceUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneRequiredWithoutServicesNestedInput;
    supplier?: SupplierUpdateOneRequiredWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
    assignedTo?: UserUpdateOneWithoutAssignedServicesNestedInput;
    loadingOrders?: ServiceLoadingOrderUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type UserCreateWithoutLoadingOrdersInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceCreateNestedManyWithoutAssignedToInput;
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutLoadingOrdersInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceUncheckedCreateNestedManyWithoutAssignedToInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutLoadingOrdersInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutLoadingOrdersInput, UserUncheckedCreateWithoutLoadingOrdersInput>;
  };

  export type ServiceLoadingOrderCreateWithoutLoadingOrderInput = {
    id?: string;
    position: number;
    service: ServiceCreateNestedOneWithoutLoadingOrdersInput;
  };

  export type ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput = {
    id?: string;
    serviceId: string;
    position: number;
  };

  export type ServiceLoadingOrderCreateOrConnectWithoutLoadingOrderInput = {
    where: ServiceLoadingOrderWhereUniqueInput;
    create: XOR<
      ServiceLoadingOrderCreateWithoutLoadingOrderInput,
      ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput
    >;
  };

  export type ServiceLoadingOrderCreateManyLoadingOrderInputEnvelope = {
    data:
      | ServiceLoadingOrderCreateManyLoadingOrderInput
      | ServiceLoadingOrderCreateManyLoadingOrderInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutLoadingOrdersInput = {
    update: XOR<UserUpdateWithoutLoadingOrdersInput, UserUncheckedUpdateWithoutLoadingOrdersInput>;
    create: XOR<UserCreateWithoutLoadingOrdersInput, UserUncheckedCreateWithoutLoadingOrdersInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutLoadingOrdersInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutLoadingOrdersInput, UserUncheckedUpdateWithoutLoadingOrdersInput>;
  };

  export type UserUpdateWithoutLoadingOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUpdateManyWithoutAssignedToNestedInput;
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutLoadingOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUncheckedUpdateManyWithoutAssignedToNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ServiceLoadingOrderUpsertWithWhereUniqueWithoutLoadingOrderInput = {
    where: ServiceLoadingOrderWhereUniqueInput;
    update: XOR<
      ServiceLoadingOrderUpdateWithoutLoadingOrderInput,
      ServiceLoadingOrderUncheckedUpdateWithoutLoadingOrderInput
    >;
    create: XOR<
      ServiceLoadingOrderCreateWithoutLoadingOrderInput,
      ServiceLoadingOrderUncheckedCreateWithoutLoadingOrderInput
    >;
  };

  export type ServiceLoadingOrderUpdateWithWhereUniqueWithoutLoadingOrderInput = {
    where: ServiceLoadingOrderWhereUniqueInput;
    data: XOR<
      ServiceLoadingOrderUpdateWithoutLoadingOrderInput,
      ServiceLoadingOrderUncheckedUpdateWithoutLoadingOrderInput
    >;
  };

  export type ServiceLoadingOrderUpdateManyWithWhereWithoutLoadingOrderInput = {
    where: ServiceLoadingOrderScalarWhereInput;
    data: XOR<
      ServiceLoadingOrderUpdateManyMutationInput,
      ServiceLoadingOrderUncheckedUpdateManyWithoutLoadingOrderInput
    >;
  };

  export type ServiceCreateWithoutLoadingOrdersInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    client: ClientCreateNestedOneWithoutServicesInput;
    supplier: SupplierCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
    assignedTo?: UserCreateNestedOneWithoutAssignedServicesInput;
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput;
    documents?: DocumentCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutLoadingOrdersInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutLoadingOrdersInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutLoadingOrdersInput,
      ServiceUncheckedCreateWithoutLoadingOrdersInput
    >;
  };

  export type LoadingOrderCreateWithoutServicesInput = {
    id?: string;
    orderNumber: string;
    generatedAt?: Date | string;
    clientId?: string | null;
    notes?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    pdfSize?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    generatedBy: UserCreateNestedOneWithoutLoadingOrdersInput;
  };

  export type LoadingOrderUncheckedCreateWithoutServicesInput = {
    id?: string;
    orderNumber: string;
    generatedAt?: Date | string;
    generatedById: string;
    clientId?: string | null;
    notes?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    pdfSize?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type LoadingOrderCreateOrConnectWithoutServicesInput = {
    where: LoadingOrderWhereUniqueInput;
    create: XOR<
      LoadingOrderCreateWithoutServicesInput,
      LoadingOrderUncheckedCreateWithoutServicesInput
    >;
  };

  export type ServiceUpsertWithoutLoadingOrdersInput = {
    update: XOR<
      ServiceUpdateWithoutLoadingOrdersInput,
      ServiceUncheckedUpdateWithoutLoadingOrdersInput
    >;
    create: XOR<
      ServiceCreateWithoutLoadingOrdersInput,
      ServiceUncheckedCreateWithoutLoadingOrdersInput
    >;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutLoadingOrdersInput = {
    where?: ServiceWhereInput;
    data: XOR<
      ServiceUpdateWithoutLoadingOrdersInput,
      ServiceUncheckedUpdateWithoutLoadingOrdersInput
    >;
  };

  export type ServiceUpdateWithoutLoadingOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneRequiredWithoutServicesNestedInput;
    supplier?: SupplierUpdateOneRequiredWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
    assignedTo?: UserUpdateOneWithoutAssignedServicesNestedInput;
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutLoadingOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type LoadingOrderUpsertWithoutServicesInput = {
    update: XOR<
      LoadingOrderUpdateWithoutServicesInput,
      LoadingOrderUncheckedUpdateWithoutServicesInput
    >;
    create: XOR<
      LoadingOrderCreateWithoutServicesInput,
      LoadingOrderUncheckedCreateWithoutServicesInput
    >;
    where?: LoadingOrderWhereInput;
  };

  export type LoadingOrderUpdateToOneWithWhereWithoutServicesInput = {
    where?: LoadingOrderWhereInput;
    data: XOR<
      LoadingOrderUpdateWithoutServicesInput,
      LoadingOrderUncheckedUpdateWithoutServicesInput
    >;
  };

  export type LoadingOrderUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    generatedBy?: UserUpdateOneRequiredWithoutLoadingOrdersNestedInput;
  };

  export type LoadingOrderUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    generatedById?: StringFieldUpdateOperationsInput | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type SupplierCreateWithoutInvoicesInput = {
    id?: string;
    supplierCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    company?: CompanyCreateNestedOneWithoutAsSupplierInput;
    services?: ServiceCreateNestedManyWithoutSupplierInput;
    documents?: DocumentCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierUncheckedCreateWithoutInvoicesInput = {
    id?: string;
    supplierCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutSupplierInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierCreateOrConnectWithoutInvoicesInput = {
    where: SupplierWhereUniqueInput;
    create: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>;
  };

  export type UserCreateWithoutInvoicesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderCreateNestedManyWithoutGeneratedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceUncheckedCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>;
  };

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput;
  };

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string;
    serviceId?: string | null;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
  };

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput;
    create: XOR<
      InvoiceItemCreateWithoutInvoiceInput,
      InvoiceItemUncheckedCreateWithoutInvoiceInput
    >;
  };

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[];
    skipDuplicates?: boolean;
  };

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string;
    paymentNumber: string;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    paymentDate: Date | string;
    paymentMethod: string;
    reference?: string | null;
    status?: $Enums.PaymentStatus;
    notes?: string | null;
    receiptPath?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string;
    paymentNumber: string;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    paymentDate: Date | string;
    paymentMethod: string;
    reference?: string | null;
    status?: $Enums.PaymentStatus;
    notes?: string | null;
    receiptPath?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput;
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>;
  };

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[];
    skipDuplicates?: boolean;
  };

  export type SupplierUpsertWithoutInvoicesInput = {
    update: XOR<SupplierUpdateWithoutInvoicesInput, SupplierUncheckedUpdateWithoutInvoicesInput>;
    create: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>;
    where?: SupplierWhereInput;
  };

  export type SupplierUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SupplierWhereInput;
    data: XOR<SupplierUpdateWithoutInvoicesInput, SupplierUncheckedUpdateWithoutInvoicesInput>;
  };

  export type SupplierUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    company?: CompanyUpdateOneWithoutAsSupplierNestedInput;
    services?: ServiceUpdateManyWithoutSupplierNestedInput;
    documents?: DocumentUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUncheckedUpdateManyWithoutSupplierNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutSupplierNestedInput;
  };

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>;
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>;
  };

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUpdateManyWithoutGeneratedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUncheckedUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput;
    update: XOR<
      InvoiceItemUpdateWithoutInvoiceInput,
      InvoiceItemUncheckedUpdateWithoutInvoiceInput
    >;
    create: XOR<
      InvoiceItemCreateWithoutInvoiceInput,
      InvoiceItemUncheckedCreateWithoutInvoiceInput
    >;
  };

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput;
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>;
  };

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput;
    data: XOR<
      InvoiceItemUpdateManyMutationInput,
      InvoiceItemUncheckedUpdateManyWithoutInvoiceInput
    >;
  };

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput;
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>;
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>;
  };

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput;
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>;
  };

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput;
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>;
  };

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    OR?: PaymentScalarWhereInput[];
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    id?: StringFilter<'Payment'> | string;
    paymentNumber?: StringFilter<'Payment'> | string;
    invoiceId?: StringFilter<'Payment'> | string;
    amount?: DecimalFilter<'Payment'> | Decimal | DecimalJsLike | number | string;
    currency?: StringFilter<'Payment'> | string;
    paymentDate?: DateTimeFilter<'Payment'> | Date | string;
    paymentMethod?: StringFilter<'Payment'> | string;
    reference?: StringNullableFilter<'Payment'> | string | null;
    status?: EnumPaymentStatusFilter<'Payment'> | $Enums.PaymentStatus;
    notes?: StringNullableFilter<'Payment'> | string | null;
    receiptPath?: StringNullableFilter<'Payment'> | string | null;
    createdAt?: DateTimeFilter<'Payment'> | Date | string;
    updatedAt?: DateTimeFilter<'Payment'> | Date | string;
  };

  export type InvoiceCreateWithoutItemsInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    supplier: SupplierCreateNestedOneWithoutInvoicesInput;
    createdBy: UserCreateNestedOneWithoutInvoicesInput;
    payments?: PaymentCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    supplierId: string;
    createdById: string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput;
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>;
  };

  export type ServiceCreateWithoutInvoiceItemsInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    client: ClientCreateNestedOneWithoutServicesInput;
    supplier: SupplierCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
    assignedTo?: UserCreateNestedOneWithoutAssignedServicesInput;
    loadingOrders?: ServiceLoadingOrderCreateNestedManyWithoutServiceInput;
    documents?: DocumentCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutInvoiceItemsInput,
      ServiceUncheckedCreateWithoutInvoiceItemsInput
    >;
  };

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>;
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>;
    where?: InvoiceWhereInput;
  };

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput;
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>;
  };

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    supplier?: SupplierUpdateOneRequiredWithoutInvoicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutInvoicesNestedInput;
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type ServiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<
      ServiceUpdateWithoutInvoiceItemsInput,
      ServiceUncheckedUpdateWithoutInvoiceItemsInput
    >;
    create: XOR<
      ServiceCreateWithoutInvoiceItemsInput,
      ServiceUncheckedCreateWithoutInvoiceItemsInput
    >;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ServiceWhereInput;
    data: XOR<
      ServiceUpdateWithoutInvoiceItemsInput,
      ServiceUncheckedUpdateWithoutInvoiceItemsInput
    >;
  };

  export type ServiceUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneRequiredWithoutServicesNestedInput;
    supplier?: SupplierUpdateOneRequiredWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
    assignedTo?: UserUpdateOneWithoutAssignedServicesNestedInput;
    loadingOrders?: ServiceLoadingOrderUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    supplier: SupplierCreateNestedOneWithoutInvoicesInput;
    createdBy: UserCreateNestedOneWithoutInvoicesInput;
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    supplierId: string;
    createdById: string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput;
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>;
  };

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>;
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>;
    where?: InvoiceWhereInput;
  };

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput;
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>;
  };

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    supplier?: SupplierUpdateOneRequiredWithoutInvoicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutInvoicesNestedInput;
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type ClientCreateWithoutDocumentsInput = {
    id?: string;
    clientCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    company?: CompanyCreateNestedOneWithoutAsClientInput;
    services?: ServiceCreateNestedManyWithoutClientInput;
    contacts?: ClientContactCreateNestedManyWithoutClientInput;
  };

  export type ClientUncheckedCreateWithoutDocumentsInput = {
    id?: string;
    clientCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutClientInput;
    contacts?: ClientContactUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientCreateOrConnectWithoutDocumentsInput = {
    where: ClientWhereUniqueInput;
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>;
  };

  export type SupplierCreateWithoutDocumentsInput = {
    id?: string;
    supplierCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    company?: CompanyCreateNestedOneWithoutAsSupplierInput;
    services?: ServiceCreateNestedManyWithoutSupplierInput;
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierUncheckedCreateWithoutDocumentsInput = {
    id?: string;
    supplierCode: string;
    companyId?: string | null;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutSupplierInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierCreateOrConnectWithoutDocumentsInput = {
    where: SupplierWhereUniqueInput;
    create: XOR<SupplierCreateWithoutDocumentsInput, SupplierUncheckedCreateWithoutDocumentsInput>;
  };

  export type ServiceCreateWithoutDocumentsInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    client: ClientCreateNestedOneWithoutServicesInput;
    supplier: SupplierCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
    assignedTo?: UserCreateNestedOneWithoutAssignedServicesInput;
    loadingOrders?: ServiceLoadingOrderCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutDocumentsInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedCreateNestedManyWithoutServiceInput;
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput;
    statusHistory?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutDocumentsInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutDocumentsInput, ServiceUncheckedCreateWithoutDocumentsInput>;
  };

  export type ClientUpsertWithoutDocumentsInput = {
    update: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>;
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>;
    where?: ClientWhereInput;
  };

  export type ClientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClientWhereInput;
    data: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>;
  };

  export type ClientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    company?: CompanyUpdateOneWithoutAsClientNestedInput;
    services?: ServiceUpdateManyWithoutClientNestedInput;
    contacts?: ClientContactUpdateManyWithoutClientNestedInput;
  };

  export type ClientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUncheckedUpdateManyWithoutClientNestedInput;
    contacts?: ClientContactUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type SupplierUpsertWithoutDocumentsInput = {
    update: XOR<SupplierUpdateWithoutDocumentsInput, SupplierUncheckedUpdateWithoutDocumentsInput>;
    create: XOR<SupplierCreateWithoutDocumentsInput, SupplierUncheckedCreateWithoutDocumentsInput>;
    where?: SupplierWhereInput;
  };

  export type SupplierUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: SupplierWhereInput;
    data: XOR<SupplierUpdateWithoutDocumentsInput, SupplierUncheckedUpdateWithoutDocumentsInput>;
  };

  export type SupplierUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    company?: CompanyUpdateOneWithoutAsSupplierNestedInput;
    services?: ServiceUpdateManyWithoutSupplierNestedInput;
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    companyId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUncheckedUpdateManyWithoutSupplierNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput;
  };

  export type ServiceUpsertWithoutDocumentsInput = {
    update: XOR<ServiceUpdateWithoutDocumentsInput, ServiceUncheckedUpdateWithoutDocumentsInput>;
    create: XOR<ServiceCreateWithoutDocumentsInput, ServiceUncheckedCreateWithoutDocumentsInput>;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ServiceWhereInput;
    data: XOR<ServiceUpdateWithoutDocumentsInput, ServiceUncheckedUpdateWithoutDocumentsInput>;
  };

  export type ServiceUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneRequiredWithoutServicesNestedInput;
    supplier?: SupplierUpdateOneRequiredWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
    assignedTo?: UserUpdateOneWithoutAssignedServicesNestedInput;
    loadingOrders?: ServiceLoadingOrderUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type UserCreateWithoutAuditLogsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceUncheckedCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
  };

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>;
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>;
  };

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUncheckedUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    password?: string | null;
    name: string;
    role?: $Enums.UserRole;
    avatar?: string | null;
    phone?: string | null;
    department?: string | null;
    isActive?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLoginAt?: Date | string | null;
    lastLoginIp?: string | null;
    passwordChangedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    assignedServices?: ServiceUncheckedCreateNestedManyWithoutAssignedToInput;
    loadingOrders?: LoadingOrderUncheckedCreateNestedManyWithoutGeneratedByInput;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
  };

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>;
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>;
  };

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    assignedServices?: ServiceUncheckedUpdateManyWithoutAssignedToNestedInput;
    loadingOrders?: LoadingOrderUncheckedUpdateManyWithoutGeneratedByNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AccountCreateManyUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type SessionCreateManyUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type ServiceCreateManyCreatedByInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ServiceCreateManyAssignedToInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    supplierId: string;
    createdById: string;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type LoadingOrderCreateManyGeneratedByInput = {
    id?: string;
    orderNumber: string;
    generatedAt?: Date | string;
    clientId?: string | null;
    notes?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    pdfSize?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type InvoiceCreateManyCreatedByInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    supplierId: string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type AuditLogCreateManyUserInput = {
    id?: string;
    action: $Enums.AuditAction;
    tableName: string;
    recordId: string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    requestId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type NotificationCreateManyUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    category: string;
    actionUrl?: string | null;
    actionLabel?: string | null;
    isRead?: boolean;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneRequiredWithoutServicesNestedInput;
    supplier?: SupplierUpdateOneRequiredWithoutServicesNestedInput;
    assignedTo?: UserUpdateOneWithoutAssignedServicesNestedInput;
    loadingOrders?: ServiceLoadingOrderUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneRequiredWithoutServicesNestedInput;
    supplier?: SupplierUpdateOneRequiredWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
    loadingOrders?: ServiceLoadingOrderUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type LoadingOrderUpdateWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceLoadingOrderUpdateManyWithoutLoadingOrderNestedInput;
  };

  export type LoadingOrderUncheckedUpdateWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceLoadingOrderUncheckedUpdateManyWithoutLoadingOrderNestedInput;
  };

  export type LoadingOrderUncheckedUpdateManyWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    pdfSize?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type InvoiceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    supplier?: SupplierUpdateOneRequiredWithoutInvoicesNestedInput;
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput;
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoiceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoiceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    requestId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    requestId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction;
    tableName?: StringFieldUpdateOperationsInput | string;
    recordId?: StringFieldUpdateOperationsInput | string;
    oldValues?: NullableJsonNullValueInput | InputJsonValue;
    newValues?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    requestId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ClientCreateManyCompanyInput = {
    id?: string;
    clientCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    billingAddress: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail: string;
    trafficEmail?: string | null;
    contactPerson?: string | null;
    contactPhone?: string | null;
    contactMobile?: string | null;
    creditLimit?: Decimal | DecimalJsLike | number | string | null;
    paymentTerms?: number;
    discount?: Decimal | DecimalJsLike | number | string | null;
    currency?: string;
    language?: string;
    sendReminders?: boolean;
    autoInvoice?: boolean;
    notes?: string | null;
    tags?: ClientCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type SupplierCreateManyCompanyInput = {
    id?: string;
    supplierCode: string;
    name: string;
    tradeName?: string | null;
    vatNumber?: string | null;
    addressLine1: string;
    addressLine2?: string | null;
    city: string;
    state?: string | null;
    postalCode: string;
    country?: string;
    email: string;
    phone?: string | null;
    fax?: string | null;
    contactPerson?: string | null;
    contactMobile?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    vatRate?: Decimal | DecimalJsLike | number | string;
    paymentTerms?: number;
    paymentMethod?: string | null;
    bankName?: string | null;
    bankAccount?: string | null;
    swiftCode?: string | null;
    iban?: string | null;
    currency?: string;
    autoApprove?: boolean;
    requirePO?: boolean;
    notes?: string | null;
    tags?: SupplierCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ClientUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUpdateManyWithoutClientNestedInput;
    contacts?: ClientContactUpdateManyWithoutClientNestedInput;
    documents?: DocumentUpdateManyWithoutClientNestedInput;
  };

  export type ClientUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUncheckedUpdateManyWithoutClientNestedInput;
    contacts?: ClientContactUncheckedUpdateManyWithoutClientNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type ClientUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    clientCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    billingAddress?: JsonNullValueInput | InputJsonValue;
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue;
    billingEmail?: StringFieldUpdateOperationsInput | string;
    trafficEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    creditLimit?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    discount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    sendReminders?: BoolFieldUpdateOperationsInput | boolean;
    autoInvoice?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ClientUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type SupplierUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUpdateManyWithoutSupplierNestedInput;
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput;
    documents?: DocumentUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    services?: ServiceUncheckedUpdateManyWithoutSupplierNestedInput;
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    supplierCode?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null;
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    addressLine1?: StringFieldUpdateOperationsInput | string;
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    fax?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null;
    contactMobile?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentTerms?: IntFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    bankName?: NullableStringFieldUpdateOperationsInput | string | null;
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null;
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null;
    iban?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: StringFieldUpdateOperationsInput | string;
    autoApprove?: BoolFieldUpdateOperationsInput | boolean;
    requirePO?: BoolFieldUpdateOperationsInput | boolean;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: SupplierUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceCreateManyClientInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    supplierId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ClientContactCreateManyClientInput = {
    id?: string;
    name: string;
    position?: string | null;
    email: string;
    phone?: string | null;
    mobile?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentCreateManyClientInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    supplierId?: string | null;
    serviceId?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ServiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    supplier?: SupplierUpdateOneRequiredWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
    assignedTo?: UserUpdateOneWithoutAssignedServicesNestedInput;
    loadingOrders?: ServiceLoadingOrderUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ClientContactUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    position?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ClientContactUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    position?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ClientContactUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    position?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    supplier?: SupplierUpdateOneWithoutDocumentsNestedInput;
    service?: ServiceUpdateOneWithoutDocumentsNestedInput;
  };

  export type DocumentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type DocumentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceCreateManySupplierInput = {
    id?: string;
    serviceNumber: string;
    date: Date | string;
    clientId: string;
    createdById: string;
    assignedToId?: string | null;
    description: string;
    reference?: string | null;
    origin: string;
    destination: string;
    distance?: number | null;
    vehicleType?: string | null;
    vehiclePlate?: string | null;
    driverName?: string | null;
    costAmount: Decimal | DecimalJsLike | number | string;
    costCurrency?: string;
    saleAmount: Decimal | DecimalJsLike | number | string;
    saleCurrency?: string;
    margin: Decimal | DecimalJsLike | number | string;
    marginPercentage: Decimal | DecimalJsLike | number | string;
    costVatRate?: Decimal | DecimalJsLike | number | string;
    costVatAmount: Decimal | DecimalJsLike | number | string;
    saleVatRate?: Decimal | DecimalJsLike | number | string;
    saleVatAmount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ServiceStatus;
    completedAt?: Date | string | null;
    cancelledAt?: Date | string | null;
    cancellationReason?: string | null;
    archivedAt?: Date | string | null;
    notes?: string | null;
    internalNotes?: string | null;
    attachments?: ServiceCreateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type InvoiceCreateManySupplierInput = {
    id?: string;
    invoiceNumber: string;
    invoiceDate: Date | string;
    dueDate: Date | string;
    createdById: string;
    subtotal: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    paymentStatus?: $Enums.PaymentStatus;
    paidAmount?: Decimal | DecimalJsLike | number | string;
    paidAt?: Date | string | null;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    irpfRate?: Decimal | DecimalJsLike | number | string | null;
    irpfAmount?: Decimal | DecimalJsLike | number | string | null;
    description?: string | null;
    notes?: string | null;
    termsConditions?: string | null;
    pdfPath?: string | null;
    pdfGeneratedAt?: Date | string | null;
    sentAt?: Date | string | null;
    sentTo?: string | null;
    viewedAt?: Date | string | null;
    reminderSentAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type DocumentCreateManySupplierInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    clientId?: string | null;
    serviceId?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ServiceUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneRequiredWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
    assignedTo?: UserUpdateOneWithoutAssignedServicesNestedInput;
    loadingOrders?: ServiceLoadingOrderUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loadingOrders?: ServiceLoadingOrderUncheckedUpdateManyWithoutServiceNestedInput;
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutServiceNestedInput;
    statusHistory?: ServiceStatusHistoryUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceNumber?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    clientId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    origin?: StringFieldUpdateOperationsInput | string;
    destination?: StringFieldUpdateOperationsInput | string;
    distance?: NullableIntFieldUpdateOperationsInput | number | null;
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null;
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null;
    driverName?: NullableStringFieldUpdateOperationsInput | string | null;
    costAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costCurrency?: StringFieldUpdateOperationsInput | string;
    saleAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleCurrency?: StringFieldUpdateOperationsInput | string;
    margin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    marginPercentage?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    costVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    costVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    saleVatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null;
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    attachments?: ServiceUpdateattachmentsInput | string[];
    customFields?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type InvoiceUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdBy?: UserUpdateOneRequiredWithoutInvoicesNestedInput;
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput;
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoiceUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoiceUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    irpfRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    irpfAmount?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    termsConditions?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null;
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    sentTo?: NullableStringFieldUpdateOperationsInput | string | null;
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    reminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type DocumentUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneWithoutDocumentsNestedInput;
    service?: ServiceUpdateOneWithoutDocumentsNestedInput;
  };

  export type DocumentUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type DocumentUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceLoadingOrderCreateManyServiceInput = {
    id?: string;
    loadingOrderId: string;
    position: number;
  };

  export type InvoiceItemCreateManyServiceInput = {
    id?: string;
    invoiceId: string;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
  };

  export type DocumentCreateManyServiceInput = {
    id?: string;
    documentType: $Enums.DocumentType;
    documentNumber?: string | null;
    clientId?: string | null;
    supplierId?: string | null;
    fileName: string;
    filePath: string;
    fileSize: number;
    mimeType: string;
    description?: string | null;
    tags?: DocumentCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy: string;
    uploadedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ServiceStatusHistoryCreateManyServiceInput = {
    id?: string;
    fromStatus?: $Enums.ServiceStatus | null;
    toStatus: $Enums.ServiceStatus;
    reason?: string | null;
    changedBy: string;
    changedAt?: Date | string;
  };

  export type ServiceLoadingOrderUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
    loadingOrder?: LoadingOrderUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceLoadingOrderUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    loadingOrderId?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type ServiceLoadingOrderUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    loadingOrderId?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type InvoiceItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput;
  };

  export type InvoiceItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
  };

  export type InvoiceItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
  };

  export type DocumentUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    client?: ClientUpdateOneWithoutDocumentsNestedInput;
    supplier?: SupplierUpdateOneWithoutDocumentsNestedInput;
  };

  export type DocumentUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type DocumentUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType;
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    clientId?: NullableStringFieldUpdateOperationsInput | string | null;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    mimeType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: DocumentUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    uploadedBy?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ServiceStatusHistoryUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?: NullableEnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus | null;
    toStatus?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: StringFieldUpdateOperationsInput | string;
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceStatusHistoryUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?: NullableEnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus | null;
    toStatus?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: StringFieldUpdateOperationsInput | string;
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceStatusHistoryUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?: NullableEnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus | null;
    toStatus?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: StringFieldUpdateOperationsInput | string;
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceLoadingOrderCreateManyLoadingOrderInput = {
    id?: string;
    serviceId: string;
    position: number;
  };

  export type ServiceLoadingOrderUpdateWithoutLoadingOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
    service?: ServiceUpdateOneRequiredWithoutLoadingOrdersNestedInput;
  };

  export type ServiceLoadingOrderUncheckedUpdateWithoutLoadingOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type ServiceLoadingOrderUncheckedUpdateManyWithoutLoadingOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string;
    serviceId?: string | null;
    description: string;
    quantity: Decimal | DecimalJsLike | number | string;
    unitPrice: Decimal | DecimalJsLike | number | string;
    amount: Decimal | DecimalJsLike | number | string;
    taxRate: Decimal | DecimalJsLike | number | string;
    taxAmount: Decimal | DecimalJsLike | number | string;
  };

  export type PaymentCreateManyInvoiceInput = {
    id?: string;
    paymentNumber: string;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string;
    paymentDate: Date | string;
    paymentMethod: string;
    reference?: string | null;
    status?: $Enums.PaymentStatus;
    notes?: string | null;
    receiptPath?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput;
  };

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
  };

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: StringFieldUpdateOperationsInput | string;
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
  };

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paymentNumber?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMethod?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paymentNumber?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMethod?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paymentNumber?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    currency?: StringFieldUpdateOperationsInput | string;
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMethod?: StringFieldUpdateOperationsInput | string;
    reference?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
